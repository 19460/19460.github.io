{"meta":{"title":"出其东门","subtitle":"","description":"","author":"WHT","url":"http://110.42.136.235","root":"/"},"pages":[{"title":"","date":"2022-05-02T01:15:19.321Z","updated":"2022-05-02T01:15:19.321Z","comments":true,"path":"about/index.html","permalink":"http://110.42.136.235/about/index.html","excerpt":"","text":"个人信息"},{"title":"所有标签","date":"2022-05-02T01:01:27.541Z","updated":"2022-05-02T01:01:27.541Z","comments":true,"path":"tags/index.html","permalink":"http://110.42.136.235/tags/index.html","excerpt":"","text":""},{"title":"所有分类","date":"2022-05-02T01:01:45.125Z","updated":"2022-05-02T01:01:45.125Z","comments":true,"path":"categories/index.html","permalink":"http://110.42.136.235/categories/index.html","excerpt":"","text":""},{"title":"contact","date":"2022-03-24T02:22:21.000Z","updated":"2022-03-24T02:22:21.384Z","comments":true,"path":"contact/index.html","permalink":"http://110.42.136.235/contact/index.html","excerpt":"","text":""},{"title":"照片","date":"2022-03-23T13:37:12.142Z","updated":"2022-03-23T13:37:12.142Z","comments":true,"path":"pictures/index.html","permalink":"http://110.42.136.235/pictures/index.html","excerpt":"","text":"div.img { margin: 5px; border: 5px solid #ccc; float: left; width: 200px; } div.img:hover { border: 2px solid #777; } div.desc { padding: 15px; text-align: auto; } 1 2 3 4 5 6 7 8"},{"title":"music","date":"2022-03-24T10:48:17.000Z","updated":"2022-03-24T10:48:17.089Z","comments":true,"path":"music/index.html","permalink":"http://110.42.136.235/music/index.html","excerpt":"","text":""},{"title":"comment","date":"2022-05-02T00:45:09.000Z","updated":"2022-05-02T01:12:50.057Z","comments":true,"path":"comment/index.html","permalink":"http://110.42.136.235/comment/index.html","excerpt":"","text":"留言板： 有什么想说的？ 有什么想问的？ 有什么想吐槽的？ 可以在下面留言…"},{"title":"友链","date":"2021-02-18T05:54:26.000Z","updated":"2022-05-02T01:08:48.738Z","comments":false,"path":"link/index.html","permalink":"http://110.42.136.235/link/index.html","excerpt":"","text":""}],"posts":[{"title":"jwt","slug":"jwt","date":"2022-04-28T01:44:59.000Z","updated":"2022-05-05T01:27:39.202Z","comments":true,"path":"2022/04/28/jwt/","link":"","permalink":"http://110.42.136.235/2022/04/28/jwt/","excerpt":"","text":"JWT介绍JWT与shiroshiro和JWT是典型的有状态登陆和无状态登陆的代表，所谓的有状态和无状态，就是看信息存在哪儿，存在服务器端，就叫做有状态，存在客户端，就叫无状态。 有状态就是说把信息存储在session中，因为session是存在服务端的，也就是有状态的，无状态就是把信息存在cookie中，cookie是存在客户端的，也就是无状态。 无状态的好处很明显，不存在服务端，可以减少服务端的压力 JWT的组成JWT由三部分拼接组成，中间用“.”分割 Header alg属性表示签名使用的算法，默认为HMAC SHA256（写为HS256）； typ属性表示令牌的类型，JWT令牌统一写为JWT。最后，使用Base64 URL算法将上述JSON对象转换为字符串保存 1234&#123; &quot;alg&quot;: &quot;HS256&quot;, &quot;typ&quot;: &quot;JWT&quot;&#125; Payload 1234567iss：发行人exp：到期时间sub：主题aud：用户nbf：在此之前不可用iat：发布时间jti：JWT ID用于标识该JWT 该部分不可以将密码等敏感信息存入 Signature 签名哈希部分是对上面两部分数据签名，需要使用base64编码后的header和payload数据，通过指定的算法生成哈希，以确保数据不会被篡改。首先，需要指定一个密钥（secret）。该密码仅仅为保存在服务器中，并且不能向用户公开。然后，使用header中指定的签名算法（默认情况下为HMAC SHA256）根据以下公式生成签名$$HMACSHA256(base64UrlEncode(header)+”.”+base64UrlEncode(payload),secret)$$ JWT验证逻辑 原文链接：https://blog.csdn.net/weixin_45070175/article/details/118559272 JWT使用快速开始第一步 引入依赖 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;!-- https://mvnrepository.com/artifact/io.jsonwebtoken/jjwt --&gt;&lt;dependency&gt; &lt;groupId&gt;io.jsonwebtoken&lt;/groupId&gt; &lt;artifactId&gt;jjwt&lt;/artifactId&gt; &lt;version&gt;0.9.1&lt;/version&gt;&lt;/dependency&gt;&lt;!-- 高版本jdk需要加入以下依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;javax.xml.bind&lt;/groupId&gt; &lt;artifactId&gt;jaxb-api&lt;/artifactId&gt; &lt;version&gt;2.3.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.sun.xml.bind&lt;/groupId&gt; &lt;artifactId&gt;jaxb-impl&lt;/artifactId&gt; &lt;version&gt;2.3.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.sun.xml.bind&lt;/groupId&gt; &lt;artifactId&gt;jaxb-core&lt;/artifactId&gt; &lt;version&gt;2.3.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.activation&lt;/groupId&gt; &lt;artifactId&gt;activation&lt;/artifactId&gt; &lt;version&gt;1.1.1&lt;/version&gt; &lt;/dependency&gt;&lt;!-- jjwt在0.10版本以后发生了较大变化，pom依赖要引入多个--&gt;&lt;dependency&gt; &lt;groupId&gt;io.jsonwebtoken&lt;/groupId&gt; &lt;artifactId&gt;jjwt-api&lt;/artifactId&gt; &lt;version&gt;0.11.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;io.jsonwebtoken&lt;/groupId&gt; &lt;artifactId&gt;jjwt-impl&lt;/artifactId&gt; &lt;version&gt;0.11.2&lt;/version&gt; &lt;scope&gt;runtime&lt;/scope&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;io.jsonwebtoken&lt;/groupId&gt; &lt;artifactId&gt;jjwt-jackson&lt;/artifactId&gt; &lt;!-- or jjwt-gson if Gson is preferred --&gt; &lt;version&gt;0.11.2&lt;/version&gt; &lt;scope&gt;runtime&lt;/scope&gt;&lt;/dependency&gt; 第二步 测试JWT 123456789101112131415161718192021222324252627282930313233343536373839404142@SpringBootTestclass JwtDemoApplicationTests &#123; private long time = 1000*60*60*24;//一小时 private String signature = &quot;admin&quot;; @Test void contextLoads() &#123; &#125; @Test void testJWT() &#123; JwtBuilder jwtBuilder= Jwts.builder(); String jwtToken = jwtBuilder //头信息 .setHeaderParam(&quot;typ&quot;,&quot;JWT&quot;) .setHeaderParam(&quot;alg&quot;,&quot;HS256&quot;) //载荷payload .claim(&quot;username&quot;,&quot;tom&quot;) .claim(&quot;role&quot;,&quot;admin&quot;) .setSubject(&quot;admin-test&quot;) .setExpiration(new Date(System.currentTimeMillis()+time)) .setId(UUID.randomUUID().toString()) //signature .signWith(SignatureAlgorithm.HS256,signature) //拼接 .compact(); System.out.println(jwtToken); &#125; @Test public void parse()&#123; String token = &quot;eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJ1c2VybmFtZSI6InRvbSIsInJvbGUiOiJhZG1pbiIsInN1YiI6ImFkbWluLXRlc3QiLCJleHAiOjE2NTExOTg4NDEsImp0aSI6ImI4NzY2Mzc3LTJjNjEtNDg1Mi04MTQzLTNhMzc3OTRlMGM3MyJ9.fqhPYypuPj0W7qdPqXxmcM9xHTiRJMEHteqz4cJPf_c&quot;; JwtParser jwtParser = Jwts.parser(); Jws&lt;Claims&gt; claimsJws = jwtParser.setSigningKey(signature).parseClaimsJws(token); Claims claims = claimsJws.getBody(); System.out.println(claims.get(&quot;username&quot;)); System.out.println(claims.get(&quot;role&quot;)); System.out.println(claims.getSubject()); System.out.println(claims.getExpiration()); &#125;&#125; 在工程中使用JWTUtils 1234567891011121314151617181920212223242526272829303132333435363738package com.wht.myblogapi.utils;import io.jsonwebtoken.Jwt;import io.jsonwebtoken.JwtBuilder;import io.jsonwebtoken.Jwts;import io.jsonwebtoken.SignatureAlgorithm;import java.util.Date;import java.util.HashMap;import java.util.Map;public class JWTUtils &#123; private static final String jwtToken = &quot;123456Mszlu!@#$$&quot;; private static long time = 1000*60*60*24;//一小时 public static String createToken(Long userId)&#123; Map&lt;String,Object&gt; claims = new HashMap&lt;&gt;(); claims.put(&quot;userId&quot;,userId); JwtBuilder jwtBuilder = Jwts.builder() .signWith(SignatureAlgorithm.HS256, jwtToken) // 签发算法，秘钥为jwtToken .setClaims(claims) // body数据，要唯一，自行设置 .setIssuedAt(new Date()) // 设置签发时间 .setExpiration(new Date(System.currentTimeMillis() + time));// 一小时的有效时间 String token = jwtBuilder.compact(); return token; &#125; public static Map&lt;String, Object&gt; checkToken(String token)&#123; try &#123; Jwt parse = Jwts.parser().setSigningKey(jwtToken).parse(token); return (Map&lt;String, Object&gt;) parse.getBody(); &#125;catch (Exception e)&#123; e.printStackTrace(); &#125; return null; &#125;","categories":[{"name":"安全框架","slug":"安全框架","permalink":"http://110.42.136.235/categories/%E5%AE%89%E5%85%A8%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"安全框架","slug":"安全框架","permalink":"http://110.42.136.235/tags/%E5%AE%89%E5%85%A8%E6%A1%86%E6%9E%B6/"}]},{"title":"shiro","slug":"shiro","date":"2022-04-27T13:25:52.000Z","updated":"2022-05-06T14:29:20.410Z","comments":true,"path":"2022/04/27/shiro/","link":"","permalink":"http://110.42.136.235/2022/04/27/shiro/","excerpt":"","text":"Shiro包含 Subject 用户 SecurityManager 管理所有用户 Realm 连接数据 第一步 引入依赖123456&lt;!-- shiro整合spring的包--&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt; &lt;artifactId&gt;shiro-spring&lt;/artifactId&gt; &lt;version&gt;1.4.1&lt;/version&gt; &lt;/dependency&gt; 第二步 写配置shiro的类认证和授权 123456789101112131415161718192021222324252627282930313233343536373839404142public class UserRealm extends AuthorizingRealm &#123; @Autowired UserService userService; @Autowired UserMapper userMapper; //授权 @Override protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principalCollection) &#123; System.out.println(&quot;执行授权方法=&gt;&quot;+&quot;doGetAuthorizationInfo&quot;); //simpleAuthorizationInfo SimpleAuthorizationInfo simpleAuthorizationInfo = new SimpleAuthorizationInfo(); //simpleAuthorizationInfo.addStringPermission(&quot;user:update&quot;); //获取当前登录对象 Subject subject = SecurityUtils.getSubject(); User currentUser = (User) subject.getPrincipal(); //查询当前用户是否有权限 simpleAuthorizationInfo.addStringPermission(currentUser.getPerm()); return simpleAuthorizationInfo; &#125; //认证 @Override protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken authenticationToken) throws AuthenticationException &#123; System.out.println(&quot;执行认证方法=&gt;&quot;+&quot;doGetAuthenticationInfo&quot;); //用户名和密码 String username = &quot;root&quot;; String password = &quot;123456&quot;; QueryWrapper&lt;User&gt; queryWrapper = new QueryWrapper&lt;&gt;(); queryWrapper.eq(&quot;username&quot;,&quot;zhangsan&quot;); List&lt;User&gt; users = userMapper.selectList(queryWrapper); User user = users.get(0); username=user.getUsername(); password=user.getPassword(); UsernamePasswordToken userToken = (UsernamePasswordToken) authenticationToken; if(!userToken.getUsername().equals(username))&#123; return null;//会自动抛出异常 &#125; //密码认证shiro会自动做 //可以加密：MD5 MD5盐值加密 return new SimpleAuthenticationInfo(user,password,&quot;&quot;); &#125;&#125; 配置 123456789101112131415161718192021222324252627282930313233343536373839404142434445@Configurationpublic class ShiroConfig &#123; //ShiroFilterFactoryBean第三步 @Bean public ShiroFilterFactoryBean getShiroFilterFactoryBean(@Qualifier(&quot;securityManager&quot;) DefaultWebSecurityManager defaultWebSecurityManager)&#123; ShiroFilterFactoryBean shiroFilterFactoryBean = new ShiroFilterFactoryBean(); //关联defaultWebSecurityManager，设置安全管理器 shiroFilterFactoryBean.setSecurityManager(defaultWebSecurityManager); /* anno:无需认证就可以访问 authc:必须认证了才能访问 user：必须拥有记住我才能访问 perms：拥有对某个资源的权限才能访问 role：拥有某个角色属性才能访问 */ Map&lt;String,String&gt; filterChainDefinitionMap = new LinkedHashMap&lt;&gt;(); filterChainDefinitionMap.put(&quot;/user/add&quot;,&quot;perms[user:add]&quot;); filterChainDefinitionMap.put(&quot;/user/update&quot;,&quot;perms[user:update]&quot;); //filterChainDefinitionMap.put(&quot;/user/*&quot;,&quot;authc&quot;); shiroFilterFactoryBean.setFilterChainDefinitionMap(filterChainDefinitionMap); //设置登录的请求 shiroFilterFactoryBean.setLoginUrl(&quot;/toLogin&quot;); shiroFilterFactoryBean.setUnauthorizedUrl(&quot;/unAuthor&quot;); return shiroFilterFactoryBean; &#125; //DefaultWebSecurityManager 第二步 @Bean(name=&quot;securityManager&quot;) public DefaultWebSecurityManager getDefaultWebSecurityManager(@Qualifier(&quot;userRealm&quot;) UserRealm userRealm)&#123; DefaultWebSecurityManager defaultWebSecurityManager = new DefaultWebSecurityManager(); //关联UserRealm defaultWebSecurityManager.setRealm(userRealm); return defaultWebSecurityManager; &#125; //创建Realm对象 需要自定义 第一步 @Bean public UserRealm userRealm()&#123; return new UserRealm(); &#125;&#125;","categories":[{"name":"安全框架","slug":"安全框架","permalink":"http://110.42.136.235/categories/%E5%AE%89%E5%85%A8%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"安全框架","slug":"安全框架","permalink":"http://110.42.136.235/tags/%E5%AE%89%E5%85%A8%E6%A1%86%E6%9E%B6/"}]},{"title":"依赖管理","slug":"依赖管理","date":"2022-04-27T12:58:14.000Z","updated":"2022-05-04T07:47:33.631Z","comments":true,"path":"2022/04/27/依赖管理/","link":"","permalink":"http://110.42.136.235/2022/04/27/%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86/","excerpt":"","text":"解决跨域问题1234567891011121314151617181920212223/** * 解决跨域问题 */@Configurationpublic class CorsConfig implements WebMvcConfigurer &#123; /** * 跨域配置 */ @Override public void addCorsMappings(CorsRegistry registry) &#123; //对那些请求路径进行跨域处理 registry.addMapping(&quot;/**&quot;) // 允许的请求头，默认允许所有的请求头 .allowedHeaders(&quot;*&quot;) // 允许的方法，默认允许GET、POST、HEAD .allowedMethods(&quot;*&quot;) // 探测请求有效时间，单位秒 .maxAge(1800) // 支持的域 .allowedOrigins(&quot;*&quot;); &#125;&#125; thymeleaf123456789&lt;!-- thymeleaf模板 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.thymeleaf&lt;/groupId&gt; &lt;artifactId&gt;thymeleaf-spring5&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.thymeleaf.extras&lt;/groupId&gt; &lt;artifactId&gt;thymeleaf-extras-java8time&lt;/artifactId&gt; &lt;/dependency&gt; MybatisPlus1234567891011121314151617181920&lt;!-- --&gt;&lt;!--MybatisPlus--&gt; &lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt; &lt;version&gt;3.5.1&lt;/version&gt; &lt;/dependency&gt;&lt;!-- lombok用于简化开发--&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;!-- mysql驱动--&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; shiro和Jwt123456789101112&lt;!-- Shiro包含Subject 用户SecurityManager 管理所有用户Realm 连接数据--&gt;&lt;!-- shiro整合spring的包--&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt; &lt;artifactId&gt;shiro-spring&lt;/artifactId&gt; &lt;version&gt;1.4.1&lt;/version&gt; &lt;/dependency&gt; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546JWT依赖&lt;!-- https://mvnrepository.com/artifact/io.jsonwebtoken/jjwt --&gt;&lt;dependency&gt; &lt;groupId&gt;io.jsonwebtoken&lt;/groupId&gt; &lt;artifactId&gt;jjwt&lt;/artifactId&gt; &lt;version&gt;0.9.1&lt;/version&gt;&lt;/dependency&gt;&lt;!-- 高版本jdk需要加入以下依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;javax.xml.bind&lt;/groupId&gt; &lt;artifactId&gt;jaxb-api&lt;/artifactId&gt; &lt;version&gt;2.3.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.sun.xml.bind&lt;/groupId&gt; &lt;artifactId&gt;jaxb-impl&lt;/artifactId&gt; &lt;version&gt;2.3.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.sun.xml.bind&lt;/groupId&gt; &lt;artifactId&gt;jaxb-core&lt;/artifactId&gt; &lt;version&gt;2.3.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.activation&lt;/groupId&gt; &lt;artifactId&gt;activation&lt;/artifactId&gt; &lt;version&gt;1.1.1&lt;/version&gt; &lt;/dependency&gt;&lt;!-- jjwt在0.10版本以后发生了较大变化，pom依赖要引入多个--&gt;&lt;dependency&gt; &lt;groupId&gt;io.jsonwebtoken&lt;/groupId&gt; &lt;artifactId&gt;jjwt-api&lt;/artifactId&gt; &lt;version&gt;0.11.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;io.jsonwebtoken&lt;/groupId&gt; &lt;artifactId&gt;jjwt-impl&lt;/artifactId&gt; &lt;version&gt;0.11.2&lt;/version&gt; &lt;scope&gt;runtime&lt;/scope&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;io.jsonwebtoken&lt;/groupId&gt; &lt;artifactId&gt;jjwt-jackson&lt;/artifactId&gt; &lt;!-- or jjwt-gson if Gson is preferred --&gt; &lt;version&gt;0.11.2&lt;/version&gt; &lt;scope&gt;runtime&lt;/scope&gt;&lt;/dependency&gt;","categories":[{"name":"依赖管理","slug":"依赖管理","permalink":"http://110.42.136.235/categories/%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86/"}],"tags":[{"name":"依赖管理","slug":"依赖管理","permalink":"http://110.42.136.235/tags/%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86/"}]},{"title":"MyBatis Plus","slug":"MyBatis-Plus","date":"2022-04-24T13:56:38.000Z","updated":"2022-05-06T10:49:28.400Z","comments":true,"path":"2022/04/24/MyBatis-Plus/","link":"","permalink":"http://110.42.136.235/2022/04/24/MyBatis-Plus/","excerpt":"","text":"MyBatisPlus的优点 无侵入：只做增强不做改变，引入它不会对现有工程产生影响，如丝般顺滑 损耗小：启动即会自动注入基本 CURD，性能基本无损耗，直接面向对象操作 强大的 CRUD 操作：内置通用 Mapper、通用 Service，仅仅通过少量配置即可实现单表大部分 CRUD 操作，更有强大的条件构造器，满足各类使用需求 支持 Lambda 形式调用：通过 Lambda 表达式，方便的编写各类查询条件，无需再担心字段写错 支持主键自动生成：支持多达 4 种主键策略（内含分布式唯一 ID 生成器 - Sequence），可自由配置，完美解决主键问题 支持 ActiveRecord 模式：支持 ActiveRecord 形式调用，实体类只需继承 Model 类即可进行强大的 CRUD 操作 支持自定义全局通用操作：支持全局通用方法注入（ Write once, use anywhere ） 内置代码生成器：采用代码或者 Maven 插件可快速生成 Mapper 、 Model 、 Service 、 Controller 层代码，支持模板引擎，更有超多自定义配置等您来使用 内置分页插件：基于 MyBatis 物理分页，开发者无需关心具体操作，配置好插件之后，写分页等同于普通 List 查询 分页插件支持多种数据库：支持 MySQL、MariaDB、Oracle、DB2、H2、HSQL、SQLite、Postgre、SQLServer 等多种数据库 内置性能分析插件：可输出 SQL 语句以及其执行时间，建议开发测试时启用该功能，能快速揪出慢查询 内置全局拦截插件：提供全表 delete 、 update 操作智能分析阻断，也可自定义拦截规则，预防误操作MyBatis-Plus使用配置环境配置pom.xml123456789101112131415161718&lt;!--MybatisPlus--&gt; &lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt; &lt;version&gt;3.5.1&lt;/version&gt; &lt;/dependency&gt;&lt;!-- lombok用于简化开发--&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt;&lt;!-- mysql驱动--&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; 配置yml文件12345678910spring:# 配置数据源信息 datasource:# 配置数据源类型 type: com.zaxxer.hikari.HikariDataSource# 配置连接数据库的各个信息 driver-class-name: com.mysql.cj.jdbc.Driver url: jdbc:mysql://localhost:3306/mybatis_plus?characterEncoding=utf-8&amp;useSSL=false&amp;serverTimezone=UTC username: root password: password 在Mapper接口中继承BaseMapper，相当于有了增删改查功能12public interface UserMapper extends BaseMapper&lt;User&gt; &#123;&#125; 启动类 1234567@SpringBootApplication@MapperScan(&quot;com.atguigu.mybatisplus.mapper&quot;)public class MybatisplusApplication &#123;public static void main(String[] args) &#123;SpringApplication.run(MybatisplusApplication.class, args);&#125;&#125; 添加实体 1234567@Data //lombok注解public class User &#123;private Long id;private String name;private Integer age;private String email;&#125; 添加mapper 注意：BaseMapper是MyBatis-Plus提供的模板mapper，其中包含了基本的CRUD方法，泛型为操作的实体类型 12public interface UserMapper extends BaseMapper&lt;User&gt; &#123;&#125; 添加service 12public interface UserService extends IService&lt;User&gt; &#123;&#125; 添加serviceImpl 1234@Servicepublic class UserServiceImpl extends ServiceImpl&lt;UserMapper, User&gt; implements UserService &#123;&#125; 添加日志 1234# 配置MyBatis日志mybatis-plus:configuration:log-impl: org.apache.ibatis.logging.stdout.StdOutImpl 常用注解@TableName在使用MyBatis-Plus实现基本的CRUD时，我们并没有指定要操作的表，只是在Mapper接口继承BaseMapper时，设置了泛型User，而操作的表为user表 由此得出结论，MyBatis-Plus在确定操作的表时，由BaseMapper的泛型决定，即实体类型决定，且默认操作的表名和实体类型的类名一致 可以在实体类上添加TableName(“”)注解,括号里的就是数据库中表的名字 TableIdMyBatis-Plus在实现CRUD时，会默认将id作为主键列，并在插入数据时，默认基于雪花算法的策略生成id，但是当主键并不是id时，需要在实体类的主键上添加@TableId注解 @TableId的value属性 若实体类中主键对应的属性为id，而表中表示主键的是字段uid此时需要通过@TableId注解的value属性，指定表中的主键字段，@TableId(“uid”)或@TableId(value=”uid”) @TableId的type属性 值 描述 IdType.ASSIGN_ID（默认） 基于雪花算法的策略生成数据id，与数据库id是否设置自增无关 IdType.AUTO 使用数据库的自增策略，注意，该类型请确保数据库设置了id自增，否则无效 配置全局主键策略 1234567891011mybatis-plus:configuration:# 配置MyBatis日志log-impl: org.apache.ibatis.logging.stdout.StdOutImplglobal-config:db-config:# 配置MyBatis-Plus操作表的默认前缀table-prefix: t_# 配置MyBatis-Plus的主键策略id-type: auto @TableField情况1 若实体类中的属性使用的是驼峰命名风格，而表中的字段使用的是下划线命名风格例如实体类属性userName，表中字段user_name此时MyBatis-Plus会自动将下划线命名风格转化为驼峰命名风格相当于在MyBatis中配置 情况2 若实体类中的属性和表中的字段不满足情况1例如实体类属性name，表中字段username此时需要在实体类属性上使用@TableField(“username”)设置属性所对应的字段名 @TableLogic逻辑删除 物理删除：真实删除，将对应数据从数据库中删除，之后查询不到此条被删除的数据 逻辑删除：假删除，将对应数据中代表是否被删除字段的状态修改为“被删除状态”，之后在数据库中仍旧能看到此条数据记录 使用场景：可以进行数据恢复 实现逻辑删除 step1：数据库中创建逻辑删除状态列，设置默认值为0 step2：实体类中添加逻辑删除属性 条件构造器和常用接口Wapper Wrapper ： 条件构造抽象类，最顶端父类 AbstractWrapper ： 用于查询条件封装，生成 sql 的 where 条件 QueryWrapper ： 查询条件封装 UpdateWrapper ： Update 条件封装 AbstractLambdaWrapper ： 使用Lambda 语法 LambdaQueryWrapper ：用于Lambda语法使用的查询Wrapper LambdaUpdateWrapper ： Lambda 更新封装Wrapper QueryWrapper12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152组装查询@Testpublic void test01()&#123;//查询用户名包含a，年龄在20到30之间，并且邮箱不为null的用户信息//SELECT id,username AS name,age,email,is_deleted FROM t_user WHEREis_deleted=0 AND (username LIKE ? AND age BETWEEN ? AND ? AND email IS NOT NULL)QueryWrapper&lt;User&gt; queryWrapper = new QueryWrapper&lt;&gt;();queryWrapper.like(&quot;username&quot;, &quot;a&quot;).between(&quot;age&quot;, 20, 30).isNotNull(&quot;email&quot;);List&lt;User&gt; list = userMapper.selectList(queryWrapper);list.forEach(System.out::println);&#125;组装排序@Testpublic void test02()&#123;//按年龄降序查询用户，如果年龄相同则按id升序排列//SELECT id,username AS name,age,email,is_deleted FROM t_user WHEREis_deleted=0 ORDER BY age DESC,id ASCQueryWrapper&lt;User&gt; queryWrapper = new QueryWrapper&lt;&gt;();queryWrapper.orderByDesc(&quot;age&quot;).orderByAsc(&quot;id&quot;);List&lt;User&gt; users = userMapper.selectList(queryWrapper);users.forEach(System.out::println);&#125;组装删除@Testpublic void test03()&#123;//删除email为空的用户//DELETE FROM t_user WHERE (email IS NULL)QueryWrapper&lt;User&gt; queryWrapper = new QueryWrapper&lt;&gt;();queryWrapper.isNull(&quot;email&quot;);//条件构造器也可以构建删除语句的条件int result = userMapper.delete(queryWrapper);System.out.println(&quot;受影响的行数：&quot; + result);&#125;组装select子句@Testpublic void test05() &#123;//查询用户信息的username和age字段//SELECT username,age FROM t_userQueryWrapper&lt;User&gt; queryWrapper = new QueryWrapper&lt;&gt;();queryWrapper.select(&quot;username&quot;, &quot;age&quot;);//selectMaps()返回Map集合列表，通常配合select()使用，避免User对象中没有被查询到的列值为nullList&lt;Map&lt;String, Object&gt;&gt; maps = userMapper.selectMaps(queryWrapper);maps.forEach(System.out::println);&#125; MyBatisPlus分页插件创建配置类 1234567891011@Configuration//扫描mapper包@MapperScan(&quot;com/example/mybatisplus/mapper&quot;)public class MyBatisPlusConfig &#123; @Bean public MybatisPlusInterceptor mybatisPlusInterceptor()&#123; MybatisPlusInterceptor interceptor = new MybatisPlusInterceptor(); interceptor.addInnerInterceptor(new PaginationInnerInterceptor(DbType.MYSQL)); return interceptor; &#125;&#125; 测试方法 1234567891011121314151617181920212223@Test public void testPage()&#123; Page&lt;User&gt; page = new Page&lt;&gt;(1,3); userMapper.selectPage(page,null); System.out.println(page.getRecords()); &#125;@Testpublic void testPage()&#123;//设置分页参数Page&lt;User&gt; page = new Page&lt;&gt;(1, 5);userMapper.selectPage(page, null);//获取分页数据List&lt;User&gt; list = page.getRecords();list.forEach(System.out::println);System.out.println(&quot;当前页：&quot;+page.getCurrent());System.out.println(&quot;每页显示的条数：&quot;+page.getSize());System.out.println(&quot;总记录数：&quot;+page.getTotal());System.out.println(&quot;总页数：&quot;+page.getPages());System.out.println(&quot;是否有上一页：&quot;+page.hasPrevious());System.out.println(&quot;是否有下一页：&quot;+page.hasNext());&#125; Xml自定义分页UserMapper中自定义接口方法 12345678910/*** 根据年龄查询用户列表，分页显示* @param page 分页对象,xml中可以从里面进行取值,传递参数 Page 即自动分页,必须放在第一位* @param age 年龄* @return*/IPage&lt;User&gt; selectPageVo(@Param(&quot;page&quot;) Page&lt;User&gt; page, @Param(&quot;age&quot;)Integer age); UserMapper.xml中编写SQL 1234567&lt;!--SQL片段，记录基础字段--&gt;&lt;sql id=&quot;BaseColumns&quot;&gt;id,username,age,email&lt;/sql&gt;&lt;!--IPage&lt;User&gt; selectPageVo(Page&lt;User&gt; page, Integer age);--&gt;&lt;select id=&quot;selectPageVo&quot; resultType=&quot;User&quot;&gt;SELECT &lt;include refid=&quot;BaseColumns&quot;&gt;&lt;/include&gt; FROM t_user WHERE age = #&#123;age&#125;&lt;/select&gt; 代码生成器第一步引入依赖 1234567891011&lt;!--代码生成器--&gt; &lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-generator&lt;/artifactId&gt; &lt;version&gt;3.5.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.freemarker&lt;/groupId&gt; &lt;artifactId&gt;freemarker&lt;/artifactId&gt; &lt;version&gt;2.3.31&lt;/version&gt; &lt;/dependency&gt; 第二步执行方法 12345678910111213141516171819202122 public static void main(String[] args) &#123; FastAutoGenerator.create(&quot;jdbc:mysql://127.0.0.1:3306/mybatis_plus? characterEncoding=utf-8&amp;userSSL=false&quot;, &quot;root&quot;, &quot;password&quot;) .globalConfig(builder -&gt; &#123; builder.author(&quot;atguigu&quot;) // 设置作者//.enableSwagger() // 开启 swagger 模式 .fileOverride() // 覆盖已生成文件 .outputDir(&quot;D://mybatis_plus&quot;); // 指定输出目录 &#125;) .packageConfig(builder -&gt; &#123; builder.parent(&quot;com.example&quot;) // 设置父包名 .moduleName(&quot;mybatisplus&quot;) // 设置父包模块名 .pathInfo(Collections.singletonMap(OutputFile.mapperXml, &quot;D://mybatis_plus&quot;));// 设置mapperXml生成路径 &#125;) .strategyConfig(builder -&gt; &#123; builder.addInclude(&quot;user&quot;) // 设置需要生成的表名 .addTablePrefix(&quot;t_&quot;, &quot;c_&quot;); // 设置过滤表前缀 &#125;) .templateEngine(new FreemarkerTemplateEngine()) // 使用Freemarker引擎模板，默认的是Velocity引擎模板 .execute(); &#125;","categories":[{"name":"MyBatisPlus","slug":"MyBatisPlus","permalink":"http://110.42.136.235/categories/MyBatisPlus/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://110.42.136.235/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"Redis6学习笔记","slug":"Redis6学习笔记","date":"2022-04-24T12:58:53.000Z","updated":"2022-05-03T01:17:24.069Z","comments":true,"path":"2022/04/24/Redis6学习笔记/","link":"","permalink":"http://110.42.136.235/2022/04/24/Redis6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"","text":"NoSQL数据库概述什么是NoSQL数据库NoSQL(NoSQL = Not Only SQL )，意即“不仅仅是SQL”，泛指非关系型的数据库。 NoSQL 不依赖业务逻辑方式存储，而以简单的key-value模式存储。因此大大的增加了数据库的扩展能力。 不遵循SQL标准。 不支持ACID。原子性 一致性 隔离性 持续性 远超于SQL的性能。 NoSQL适用场景 对数据高并发的读写 海量数据的读写 对数据高可扩展性的 NoSQL不适用场景 需要事务支持 基于sql的结构化查询存储，处理复杂的关系,需要即席查询。 Redis的优点 几乎覆盖了Memcached的绝大部分功能 数据都在内存中，支持持久化，主要用作备份恢复 除了支持简单的key-value模式，还支持多种数据结构的存储，比如**list、set、hash、zset**等。 一般是作为缓存数据库辅助持久化的数据库 Redis是单线程+多路IO复用技术多路复用是指使用一个线程来检查多个文件描述符（Socket）的就绪状态，比如调用select和poll函数，传入多个文件描述符，如果有一个文件描述符就绪，则返回，否则阻塞直到超时。得到就绪状态后进行真正的操作可以在同一个线程里执行，也可以启动线程执行（比如使用线程池） 串行 vs 多线程+锁（memcached） vs 单线程+多路IO复用(Redis) Redis 使用 Windows下使用1234567127.0.0.1:6379&gt; pingPONG127.0.0.1:6379&gt; set name whtOK127.0.0.1:6379&gt; get name&quot;wht&quot;127.0.0.1:6379&gt; Redis linux下使用(常用命令)redis一共有16个数据库，默认使用第一个数据库 ，可以使用select来切换数据库 12345[root@VM-12-7-centos ~]# redis-cli127.0.0.1:6379&gt; select 1OK127.0.0.1:6379[1]&gt; dbsize(integer) 0 插入key值 12127.0.0.1:6379&gt; set name whtOK 查看当前所有key值 12127.0.0.1:6379&gt; keys *1) &quot;name&quot; 查看key值内容 1234127.0.0.1:6379&gt; set name whtOK127.0.0.1:6379&gt; get name&quot;wht&quot; 删除某个key值 mov +key值+当前数据库 12127.0.0.1:6379&gt; move name 1(integer) 1 给某个key值加上过期时间和查看剩余时间 123456789127.0.0.1:6379&gt; set name whtOK127.0.0.1:6379&gt; expire name 10(integer) 1127.0.0.1:6379&gt; ttl name(integer) 7127.0.0.1:6379&gt; ttl name(integer) 1127.0.0.1:6379 查看当前key的类型 1234567127.0.0.1:6379&gt; keys *1) &quot;age&quot;2) &quot;name&quot;127.0.0.1:6379&gt; type agestring127.0.0.1:6379&gt; type namestring 清空当库的全部key值 1234127.0.0.1:6379&gt; flushdbOK127.0.0.1:6379&gt; keys *(empty array) 清除所有数据库 1flushall 查看当前key值是否存在 1exists name Redis是单线程 Redis是基于内存操作的，CPU并不是Redis的性能瓶颈，主要由机器内存和网络带宽决定 为什么单线程还这么快Redis所示c语言写的，官方数据，100000+QPS 核心：Redis将所有数据都放在内存中，所以使用单线程去操作是效率最高的 多线程上下文切换是个耗时的操作 Redis五大基本数据String字符串给key值追加字段 append 1234127.0.0.1:6379&gt; set name whtOK127.0.0.1:6379&gt; append name wht2(integer) 7 查看当前key值得长度 1234127.0.0.1:6379&gt; get name&quot;whtwht2&quot;127.0.0.1:6379&gt; STRLEN name(integer) 7 加一减一操作 12345678910127.0.0.1:6379&gt; get view&quot;0&quot;127.0.0.1:6379&gt; incr view(integer) 1127.0.0.1:6379&gt; get view &quot;1&quot;127.0.0.1:6379&gt; decr view (integer) 0127.0.0.1:6379&gt; get view &quot;0&quot; 连续增加和连续减少 123456127.0.0.1:6379&gt; get view &quot;0&quot;127.0.0.1:6379&gt; INCRBY view 10(integer) 10127.0.0.1:6379&gt; DECRBY view 5(integer) 5 获取某个区间的字符(如果是0到-1表示获取全部字符串) 1234127.0.0.1:6379&gt; get name&quot;whttttttt&quot;127.0.0.1:6379&gt; GETRANGE name 0 3&quot;whtt&quot; setex(set with expire) 设置key3的值为hello 30秒后过期 1234127.0.0.1:6379&gt; setex key3 30 &quot;hello&quot;OK127.0.0.1:6379&gt; ttl key3(integer) 21 setnx (set if not exist) 不存在则设置，在分布式锁中常用 1234127.0.0.1:6379&gt; setnx name &quot;wht2&quot;(integer) 0127.0.0.1:6379&gt; get name&quot;whttttttt&quot;#还是原来的值，因为已经存在，所以创建失败 mset 批量创建 123456127.0.0.1:6379&gt; mset k1 v1 k2 v2 k3 v3OK127.0.0.1:6379&gt; keys *1) &quot;k2&quot;2) &quot;k1&quot;3) &quot;k3&quot; mget 批量获取 1234127.0.0.1:6379&gt; mget k1 k2 k31) &quot;v1&quot;2) &quot;v2&quot;3) &quot;v3&quot; msetnx 如果不存在则批量创建(遵循原子性原则) 123456127.0.0.1:6379&gt; msetnx k1 v1 k2 v2 k4 v4(integer) 0127.0.0.1:6379&gt; keys *1) &quot;k2&quot;2) &quot;k1&quot;3) &quot;k3 #因为k1 和k2存在，所以k4没有创建成功 设置一个json字符串保存数据 1234set user1:1&#123;name:zhangsan,age:3&#125;127.0.0.1:6379&gt; get user1:1&quot;&#123;name:zhangsan,age:3&#125;&quot; user:{id}:{filed} 12345127.0.0.1:6379&gt; mset user2:1:name wht user2:1:age 18OK127.0.0.1:6379&gt; mget user2:1:name user2:1:age1) &quot;wht&quot;2) &quot;18&quot; getset 先get再set，如果不存在则创建,返回的是当前get的值 1234127.0.0.1:6379&gt; GETSET db redis(nil)127.0.0.1:6379&gt; get db&quot;redis&quot; 字符串时应用场景最多的地方，不仅可以是字符串，还可以是数字 List所有list命令都是l开头的 LPUSH LRANGE list作为堆栈使用，先进后出 1234567891011127.0.0.1:6379&gt; LPUSH list one(integer) 1127.0.0.1:6379&gt; LPUSH list two(integer) 2127.0.0.1:6379&gt; LPUSH list three(integer) 3127.0.0.1:6379&gt; LRANGE list 0 -11) &quot;three&quot;2) &quot;two&quot;3) &quot;one&quot; RPUSH LPUSH list作为队列使用,可以从左边或者右边插入 123456789101112131415127.0.0.1:6379&gt; RPUSH list right(integer) 4127.0.0.1:6379&gt; LRANGE list 0 -11) &quot;three&quot;2) &quot;two&quot;3) &quot;one&quot;4) &quot;right&quot;127.0.0.1:6379&gt; LPUSH list left(integer) 5127.0.0.1:6379&gt; LRANGE list 0 -11) &quot;left&quot;2) &quot;three&quot;3) &quot;two&quot;4) &quot;one&quot;5) &quot;right&quot; LPOP RPOP 出栈 1234567127.0.0.1:6379&gt; LPOP list&quot;left&quot;127.0.0.1:6379&gt; LRANGE list 0 -11) &quot;three&quot;2) &quot;two&quot;3) &quot;one&quot;4) &quot;right&quot; LINDEX 通过索引获取元素 12127.0.0.1:6379&gt; LINDEX list 0&quot;three&quot; LLEN获取list长度 12127.0.0.1:6379&gt; LLEN list(integer) 4 LREM 移除指定元素，可以指定数量 12345678910127.0.0.1:6379&gt; LRANGE list 0 -11) &quot;three&quot;2) &quot;three&quot;3) &quot;two&quot;4) &quot;right&quot;127.0.0.1:6379&gt; LREM list 2 three(integer) 2127.0.0.1:6379&gt; lrange list 0 -11) &quot;two&quot;2) &quot;right&quot; ltrim 截取指定list 12345678910127.0.0.1:6379&gt; LRANGE list 0 -11) &quot;three&quot;2) &quot;three&quot;3) &quot;two&quot;4) &quot;right&quot;127.0.0.1:6379&gt; ltrim list 1 2OK127.0.0.1:6379&gt; LRANGE list 0 -1 #list已经被改变了1) &quot;three&quot;2) &quot;two&quot; RPOPLPUSH 移除列表最后一个元素，移入新的lsit 1234127.0.0.1:6379&gt; RPOPLPUSH list newlist&quot;two&quot;127.0.0.1:6379&gt; LRANGE newlist 0 -11) &quot;two&quot; LINSERT +before 和after 在指定字段后面或者前面插入新的值 12345678127.0.0.1:6379&gt; LINSERT list before &quot;three&quot; new (integer) 2127.0.0.1:6379&gt; LINSERT list after three new2(integer) 3127.0.0.1:6379&gt; LRANGE list 0 -11) &quot;new&quot;2) &quot;three&quot;3) &quot;new2&quot; 使用场景 ：消息队列，栈 set（集合）set集合的命令都是以s开头的 集合是不能重复的,且无序 插入sadd 和查询smembers 12345678910127.0.0.1:6379&gt; sadd myset hello(integer) 1127.0.0.1:6379&gt; sadd myset wht(integer) 1127.0.0.1:6379&gt; sadd myset wht2(integer) 1127.0.0.1:6379&gt; smembers myset1) &quot;wht&quot;2) &quot;hello&quot;3) &quot;wht2&quot; sismember判断某一个元素是不是在集合中’ 1sismember myset wht scard 查看当前集合中有多少个元素 12127.0.0.1:6379&gt; SCARD myset(integer) 3 srem(remove)从当前集合中移除某个元素 12127.0.0.1:6379&gt; SREM myset hello(integer) 1 srandmember随机抽取一个集合的元素(类似抽奖) 1234127.0.0.1:6379&gt; srandmember myset&quot;wht2&quot;127.0.0.1:6379&gt; srandmember myset&quot;wht&quot; spop 随机删除一个集合中的元素 1spop myset smove将制定元素移动到另外一个集合中 123456127.0.0.1:6379&gt; smove myset myset2 wht7 (integer) 1127.0.0.1:6379&gt; smembers myset21) &quot;bbb&quot;2) &quot;aaa&quot;3) &quot;wht7&quot; sdiff求差集 sinter求交集 sunion求并集 12345678910111213141516127.0.0.1:6379&gt; smembers myset21) &quot;bbb&quot;2) &quot;aaa&quot;3) &quot;wht7&quot;127.0.0.1:6379&gt; smembers myset1) &quot;wht8&quot;2) &quot;aaa&quot;127.0.0.1:6379&gt; SDIFF myset myset21) &quot;wht8&quot;127.0.0.1:6379&gt; sinter myset myset21) &quot;aaa&quot;127.0.0.1:6379&gt; SUNION myset myset21) &quot;bbb&quot;2) &quot;wht8&quot;3) &quot;aaa&quot;4) &quot;wht7&quot; 交集可以做共同好友，共同关注，可能认识的人等功能 Hash（哈希）Map集合，key-value集合，这时候是map集合 所有hash命令都已h开头！ hset 加入值 ，hget取值 1234127.0.0.1:6379&gt; hset myhash field1 wht1(integer) 1127.0.0.1:6379&gt; hget myhash field1&quot;wht1&quot; hmset加入多个值， mget获取多个值, hgetall获取所有数据 12345678910127.0.0.1:6379&gt; hmset myhash field1 hello1 field2 hello2OK127.0.0.1:6379&gt; hmget myhash field1 field21) &quot;wht1&quot;2) &quot;hello2&quot;127.0.0.1:6379&gt; hgetall myhash1) &quot;field1&quot;2) &quot;hello1&quot;5) &quot;field2&quot;6) &quot;hello2&quot; 设置值若有重复值则会覆盖原来的值 hdel删除指定的key字段 1hdel myhash filed1 hlen获取hash表的字段长度 12127.0.0.1:6379&gt; hlen myhash(integer) 2 exists当前键是否存在 12127.0.0.1:6379&gt; exists myhash field1(integer) 1 hinceby给指定值增加指定值 1234127.0.0.1:6379&gt; hset myhash field3 5(integer) 1127.0.0.1:6379&gt; hincrby myhash field3 2(integer) 7 hsetnx 如果不存在则创建，否则创建失败 设置键值对的方式 1234127.0.0.1:6379&gt; hset user:1 name wht(integer) 1127.0.0.1:6379&gt; hget user:1 name&quot;wht&quot; Zset有序集合zadd添加 ，zrange 查询 12345678127.0.0.1:6379&gt; zadd myset 1 one(integer) 1127.0.0.1:6379&gt; zadd myset 2 two 3 three(integer) 2127.0.0.1:6379&gt; zrange myset 0 -11) &quot;one&quot;2) &quot;two&quot;3) &quot;three&quot; zrangebyscore按照score从小到大排序 1234567127.0.0.1:6379&gt; zrangebyscore myset -inf +inf withscores1) &quot;one&quot;2) &quot;1&quot;3) &quot;two&quot;4) &quot;2&quot;5) &quot;three&quot;6) &quot;3&quot; ZREVRANGEBYSCORE按照score从大到小排序 123127.0.0.1:6379&gt; ZREVRANGEBYSCORE myset +inf -inf1) &quot;three&quot;2) &quot;two&quot; zrevrange按照索引从大到小排序 反之rerange是按照索引从小到大排序 123127.0.0.1:6379&gt; zrevrange myset 0 -11) &quot;three&quot;2) &quot;two&quot; zrem移除某个元素 1zrem myset one zcard获取有序集合中的个数 zcount获取某个区间的个数 12127.0.0.1:6379&gt; ZCOUNT myset 2 3(integer) 2 应用场景：排行榜，班级排序 三种特殊数据类型geospatial地理位置在redis3.2中支持推出地理位置功能，根据经度和纬度 geoadd添加地理位置 12GEOADD china:city 116.40 39.90 beijingGEOADD china:city 121.47 31.23 shanghai geopos获取地理位置 12345127.0.0.1:6379&gt; geopos china:city beijing shanghai1) 1) &quot;116.39999896287918091&quot; 2) &quot;39.90000009167092543&quot;2) 1) &quot;121.47000163793563843&quot; 2) &quot;31.22999903975783553&quot; geodist获取两个位置的距离，单位默认是米，可以在最后指定单位 1234127.0.0.1:6379&gt; geodist china:city beijing shanghai&quot;1067378.7564&quot;127.0.0.1:6379&gt; geodist china:city beijing shanghai km&quot;1067.3788&quot; georadius以给定值为半径，在圆圈内寻找 12127.0.0.1:6379&gt; georadius china:city 110 40 1000 km1) &quot;beijing&quot; 功能：附近的人 georadiusbymember以城市为圆心 12127.0.0.1:6379&gt; georadiusbymember china:city beijing 1000 km1) &quot;beijing&quot; Hyperloglog基数基数就是不重复元素的个数，比如网站的访问人数，一个人访问一个网站多次是记作一次的 会有一定的错误率但在可接受范围内 pfadd增加 pfcount计算基数个数 123456127.0.0.1:6379&gt; pfadd mykey a b c d e f(integer) 1127.0.0.1:6379&gt; pfadd mykey2 a b c d e f g(integer) 1127.0.0.1:6379&gt; pfcount mykey mykey2(integer) 7 如果允许容错，则可以使用hyperloglog，否则应该使用集合 Bitmaps 位存储 占用内存较少 用途：统计用户活跃度，打卡 setbit 设置状态 bitcount查询1的个数 12345678127.0.0.1:6379&gt; setbit sign 0 1(integer) 0127.0.0.1:6379&gt; setbit sign 1 0(integer) 0127.0.0.1:6379&gt; setbit sign 2 1(integer) 0127.0.0.1:6379&gt; bitcount sign(integer) 2 Redis事务redis单条命令是符合原子性的 但redis的事务是没有原子性和隔离级别的 所有命令并没有直接被执行，而是发起执行命令时才会被执行 redis事务 开启事务 命令入队 执行事务 multi开启事务，exec执行队列 123456789101112131415127.0.0.1:6379&gt; MULTIOK127.0.0.1:6379(TX)&gt; set k1 v1QUEUED127.0.0.1:6379(TX)&gt; set k2 v2QUEUED127.0.0.1:6379(TX)&gt; get k1QUEUED127.0.0.1:6379(TX)&gt; get k2QUEUED127.0.0.1:6379(TX)&gt; EXEC1) OK2) OK3) &quot;v1&quot;4) &quot;v2&quot; discard放弃事务,队列里的命令并不会执行 123456127.0.0.1:6379(TX)&gt; set k3 v3QUEUED127.0.0.1:6379(TX)&gt; DISCARDOK127.0.0.1:6379&gt; get k3(nil) 事务错误类型 编译型异常 ，代码或命令有问题，事务中的所有命令都不会执行 运行时出现异常，事务队列中存在语法异常，执行命令时，其他命令可以正常执行，错误命令抛出异常 乐观锁什么是悲观锁和乐观锁悲观锁：认为什么时候都会出问题，无论做什么都会加锁，影响性能 乐观锁：认为不会出问题，所以不会加锁，更新数据的时候去判断一下，在此期间是否有人修改过这个数据 watch可以开启监视对象 Redis发布订阅subscribe订阅wht 12345678127.0.0.1:6379&gt; subscribe whtReading messages... (press Ctrl-C to quit)1) &quot;subscribe&quot;2) &quot;wht&quot;3) (integer) 11) &quot;message&quot;2) &quot;wht&quot;3) &quot;hello redis&quot; publish发布订阅 123127.0.0.1:6379&gt; PUBLISH wht &quot;hello redis&quot;(integer) 1127.0.0.1:6379&gt; Redis集群info replication查看集群信息 12345678910111213127.0.0.1:6379&gt; info replication# Replicationrole:masterconnected_slaves:0master_failover_state:no-failovermaster_replid:8a44af6f2d0b6738eae98e2f3c5f0ef76503378cmaster_replid2:0000000000000000000000000000000000000000master_repl_offset:0second_repl_offset:-1repl_backlog_active:0repl_backlog_size:1048576repl_backlog_first_byte_offset:0repl_backlog_histlen:0","categories":[{"name":"Redis","slug":"Redis","permalink":"http://110.42.136.235/categories/Redis/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://110.42.136.235/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"SpringBoot","slug":"SpringBoot","date":"2022-04-16T12:55:33.000Z","updated":"2022-04-26T03:17:41.519Z","comments":true,"path":"2022/04/16/SpringBoot/","link":"","permalink":"http://110.42.136.235/2022/04/16/SpringBoot/","excerpt":"","text":"SpringBootSpring 缺点1） 配置繁琐虽然Spring的组件代码是轻量级的，但它的配置却是重量级的。一开始，Spring用XML配置，而且是很多XML配置。Spring 2.5引入了基于注解的组件扫描，这消除了大量针对应用程序自身组件的显式XML配置。Spring 3.0引入了基于Java的配置，这是一种类型安全的可重构配置方式，可以代替XML。所有这些配置都代表了开发时的损耗。因为在思考Spring特性配置和解决业务问题之间需要进行思维切换，所以编写配置挤占了编写应用程序逻辑的时间。和所有框架一样，Spring实用，但它要求的回报也不少。 2）依赖繁琐项目的依赖管理也是一件耗时耗力的事情。在环境搭建时，需要分析要导入哪些库的坐标，而且还需要分析导入与之有依赖关系的其他库的坐标，一旦选错了依赖的版本，随之而来的不兼容问题就会严重阻碍项目的开发进度。 SpringBoot 概述SpringBoot 功能1） 自动配置Spring Boot的自动配置是一个运行时（更准确地说，是应用程序启动时）的过程，考虑了众多因素，才决定Spring配置应该用哪个，不该用哪个。该过程是SpringBoot自动完成的。 2） 起步依赖起步依赖本质上是一个Maven项目对象模型（Project Object Model，POM），定义了对其他库的传递依赖，这些东西加在一起即支持某项功能。简单的说，起步依赖就是将具备某种功能的坐标打包到一起，并提供一些默认的功能。 3） 辅助功能提供了一些大型项目中常见的非功能性特性，如嵌入式服务器、安全、指标，健康检测、外部配置等。Spring Boot 并不是对 Spring 功能上的增强，而是提供了一种快速使用 Spring 的方式。 SpringBoot 起步依赖原理分析 在spring-boot-starter-parent中定义了各种技术的版本信息，组合了一套最优搭配的技术版本。 在各种starter中，定义了完成该功能需要的坐标合集，其中大部分版本信息来自于父工程。 我们的工程继承parent，引入starter后，通过依赖传递，就可以简单方便获得需要的jar包，并且不会存在版本冲突等问题。 SpringBoot 配置配置文件分类SpringBoot是基于约定的，所以很多配置都有默认值，但如果想使用自己的配置替换默认配置的话，就可以使用application.properties或者application.yml（application.yaml）进行配置。 properties： server.port=8080 yml: server: port: 8080 YAMLYAML全称是 YAML Ain’t Markup Language 。YAML是一种直观的能够被电脑识别的的数据数据序列化格式，并且容易被人类阅读，容易和脚本语言交互的，可以被支持YAML库的不同的编程语言程序导入，比如： C/C++, Ruby, Python, Java, Perl, C#, PHP等。YML文件是以数据为核心的，比传统的xml方式更加简洁。YAML文件的扩展名可以使用.yml或者.yaml。 YAML：基本语法 大小写敏感 数据值前边必须有空格，作为分隔符 使用缩进表示层级关系 缩进时不允许使用Tab键，只允许使用空格（各个系统 Tab对应的 空格数目可能不同，导致层次混乱）。 缩进的空格数目不重要，只要相同层级的元素左侧对齐即可 ‘#’ 表示注释，从这个字符一直到行尾，都会被解析器忽略。1234server: port: 8080address: 127.0.0.1name: abc YAML：数据格式 对象(map)：键值对的集合。1234person:name: zhangsan# 行内写法person: &#123;name: zhangsan&#125; 数组：一组按次序排列的值12345address:- beijing- shanghai# 行内写法address: [beijing,shanghai] 纯量：单个的、不可再分的值12msg1: &#x27;hello \\n world&#x27; # 单引忽略转义字符msg2: &quot;hello \\n world&quot; # 双引识别转义字符 YAML：参数引用123name: lisiperson:name: $&#123;name&#125; # 引用上边定义的name值 小结 1） 配置文件类型 properties：和以前一样 yml/yaml：注意空格 2） yaml：简洁，以数据为核心 基本语法 • 大小写敏感 • 数据值前边必须有空格，作为分隔符 • 使用空格缩进表示层级关系，相同缩进表示同一级&gt; 数据格式 • 对象 • 数组: 使用 “- ”表示数组每个元素 • 纯量 参数引用 • ${key} SpringBoot注入yml使用value注解123456@Value(&quot;$&#123;name&#125;&quot;)//元素注入private String name1;@Value(&quot;$&#123;person.age&#125;&quot;)//对象注入private int age;@Value(&quot;$&#123;address[0]&#125;&quot;)//数组注入private String address; 使用Environment获取yml对象12345//使用Environment获取yml对象 @Autowired Environment environment; //在方法中 String name = environment.getProperty(&quot;address&quot;); ConfigurationProperties12345@Component@ConfigurationProperties(&quot;person&quot;)public class Person &#123; private String name; private int age; profile我们在开发Spring Boot应用时，通常同一套程序会被安装到不同环境，比如：开发、测试、生产等。其中数据库地址、服务器端口等等配置都不同，如果每次打包时，都要修改配置文件，那么非常麻烦。profile功能就是来进行动态配置切换的。 1） profile配置方式 多profile文件方式 yml多文档方式 2） profile激活方式 配置文件 虚拟机参数 命令行参数","categories":[{"name":"spring","slug":"spring","permalink":"http://110.42.136.235/categories/spring/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://110.42.136.235/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"SpringMVC","slug":"SpringMVC笔记","date":"2022-04-13T13:33:24.000Z","updated":"2022-04-23T02:51:24.974Z","comments":true,"path":"2022/04/13/SpringMVC笔记/","link":"","permalink":"http://110.42.136.235/2022/04/13/SpringMVC%E7%AC%94%E8%AE%B0/","excerpt":"","text":"[TOC] 一、SpringMVC简介1、什么是MVCMVC是一种软件架构的思想，将软件按照模型、视图、控制器来划分 M：Model，模型层，指工程中的JavaBean，作用是处理数据 JavaBean分为两类： 一类称为实体类Bean：专门存储业务数据的，如 Student、User 等 一类称为业务处理 Bean：指 Service 或 Dao 对象，专门用于处理业务逻辑和数据访问。 V：View，视图层，指工程中的html或jsp等页面，作用是与用户进行交互，展示数据 C：Controller，控制层，指工程中的servlet，作用是接收请求和响应浏览器 MVC的工作流程：用户通过视图层发送请求到服务器，在服务器中请求被Controller接收，Controller调用相应的Model层处理请求，处理完毕将结果返回到Controller，Controller再根据请求处理的结果找到相应的View视图，渲染数据后最终响应给浏览器 2、什么是SpringMVCSpringMVC是Spring的一个后续产品，是Spring的一个子项目 SpringMVC 是 Spring 为表述层开发提供的一整套完备的解决方案。在表述层框架历经 Strust、WebWork、Strust2 等诸多产品的历代更迭之后，目前业界普遍选择了 SpringMVC 作为 Java EE 项目表述层开发的首选方案。 注：三层架构分为表述层（或表示层）、业务逻辑层、数据访问层，表述层表示前台页面和后台servlet 3、SpringMVC的特点 Spring 家族原生产品，与 IOC 容器等基础设施无缝对接 基于原生的Servlet，通过了功能强大的前端控制器DispatcherServlet，对请求和响应进行统一处理 表述层各细分领域需要解决的问题全方位覆盖，提供全面解决方案 代码清新简洁，大幅度提升开发效率 内部组件化程度高，可插拔式组件即插即用，想要什么功能配置相应组件即可 性能卓著，尤其适合现代大型、超大型互联网项目要求 二、HelloWorld1、开发环境IDE：idea 2019.2 构建工具：maven3.5.4 服务器：tomcat7 Spring版本：5.3.1 2、创建maven工程a&gt;添加web模块b&gt;打包方式：warc&gt;引入依赖123456789101112131415161718192021222324252627282930&lt;dependencies&gt; &lt;!-- SpringMVC --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;5.3.1&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 日志 --&gt; &lt;dependency&gt; &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt; &lt;artifactId&gt;logback-classic&lt;/artifactId&gt; &lt;version&gt;1.2.3&lt;/version&gt; &lt;/dependency&gt; &lt;!-- ServletAPI --&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;3.1.0&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- Spring5和Thymeleaf整合包 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.thymeleaf&lt;/groupId&gt; &lt;artifactId&gt;thymeleaf-spring5&lt;/artifactId&gt; &lt;version&gt;3.0.12.RELEASE&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 注：由于 Maven 的传递性，我们不必将所有需要的包全部配置依赖，而是配置最顶端的依赖，其他靠传递性导入。 3、配置web.xml注册SpringMVC的前端控制器DispatcherServlet a&gt;默认配置方式此配置作用下，SpringMVC的配置文件默认位于WEB-INF下，默认名称为&lt;servlet-name&gt;-servlet.xml，例如，以下配置所对应SpringMVC的配置文件位于WEB-INF下，文件名为springMVC-servlet.xml 1234567891011121314&lt;!-- 配置SpringMVC的前端控制器，对浏览器发送的请求统一进行处理 --&gt;&lt;servlet&gt; &lt;servlet-name&gt;springMVC&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;springMVC&lt;/servlet-name&gt; &lt;!-- 设置springMVC的核心控制器所能处理的请求的请求路径 /所匹配的请求可以是/login或.html或.js或.css方式的请求路径 但是/不能匹配.jsp请求路径的请求 --&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; b&gt;扩展配置方式可通过init-param标签设置SpringMVC配置文件的位置和名称，通过load-on-startup标签设置SpringMVC前端控制器DispatcherServlet的初始化时间 123456789101112131415161718192021222324252627&lt;!-- 配置SpringMVC的前端控制器，对浏览器发送的请求统一进行处理 --&gt;&lt;servlet&gt; &lt;servlet-name&gt;springMVC&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!-- 通过初始化参数指定SpringMVC配置文件的位置和名称 --&gt; &lt;init-param&gt; &lt;!-- contextConfigLocation为固定值 --&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;!-- 使用classpath:表示从类路径查找配置文件，例如maven工程中的src/main/resources --&gt; &lt;param-value&gt;classpath:springMVC.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;!-- 作为框架的核心组件，在启动过程中有大量的初始化操作要做 而这些操作放在第一次请求时才执行会严重影响访问速度 因此需要通过此标签将启动控制DispatcherServlet的初始化时间提前到服务器启动时 --&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;springMVC&lt;/servlet-name&gt; &lt;!-- 设置springMVC的核心控制器所能处理的请求的请求路径 /所匹配的请求可以是/login或.html或.js或.css方式的请求路径 但是/不能匹配.jsp请求路径的请求 --&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 注： &lt;url-pattern&gt;标签中使用/和/*的区别： /所匹配的请求可以是/login或.html或.js或.css方式的请求路径，但是/不能匹配.jsp请求路径的请求 因此就可以避免在访问jsp页面时，该请求被DispatcherServlet处理，从而找不到相应的页面 /*则能够匹配所有请求，例如在使用过滤器时，若需要对所有请求进行过滤，就需要使用/*的写法 4、创建请求控制器由于前端控制器对浏览器发送的请求进行了统一的处理，但是具体的请求有不同的处理过程，因此需要创建处理具体请求的类，即请求控制器 请求控制器中每一个处理请求的方法成为控制器方法 因为SpringMVC的控制器由一个POJO（普通的Java类）担任，因此需要通过@Controller注解将其标识为一个控制层组件，交给Spring的IoC容器管理，此时SpringMVC才能够识别控制器的存在 1234@Controllerpublic class HelloController &#123; &#125; 5、创建springMVC的配置文件1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;!-- 自动扫描包 --&gt;&lt;context:component-scan base-package=&quot;com.atguigu.mvc.controller&quot;/&gt;&lt;!-- 配置Thymeleaf视图解析器 --&gt;&lt;bean id=&quot;viewResolver&quot; class=&quot;org.thymeleaf.spring5.view.ThymeleafViewResolver&quot;&gt; &lt;property name=&quot;order&quot; value=&quot;1&quot;/&gt; &lt;property name=&quot;characterEncoding&quot; value=&quot;UTF-8&quot;/&gt; &lt;property name=&quot;templateEngine&quot;&gt; &lt;bean class=&quot;org.thymeleaf.spring5.SpringTemplateEngine&quot;&gt; &lt;property name=&quot;templateResolver&quot;&gt; &lt;bean class=&quot;org.thymeleaf.spring5.templateresolver.SpringResourceTemplateResolver&quot;&gt; &lt;!-- 视图前缀 --&gt; &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/templates/&quot;/&gt; &lt;!-- 视图后缀 --&gt; &lt;property name=&quot;suffix&quot; value=&quot;.html&quot;/&gt; &lt;property name=&quot;templateMode&quot; value=&quot;HTML5&quot;/&gt; &lt;property name=&quot;characterEncoding&quot; value=&quot;UTF-8&quot; /&gt; &lt;/bean&gt; &lt;/property&gt; &lt;/bean&gt; &lt;/property&gt;&lt;/bean&gt;&lt;!-- 处理静态资源，例如html、js、css、jpg 若只设置该标签，则只能访问静态资源，其他请求则无法访问 此时必须设置&lt;mvc:annotation-driven/&gt;解决问题 --&gt;&lt;mvc:default-servlet-handler/&gt;&lt;!-- 开启mvc注解驱动 --&gt;&lt;mvc:annotation-driven&gt; &lt;mvc:message-converters&gt; &lt;!-- 处理响应中文内容乱码 --&gt; &lt;bean class=&quot;org.springframework.http.converter.StringHttpMessageConverter&quot;&gt; &lt;property name=&quot;defaultCharset&quot; value=&quot;UTF-8&quot; /&gt; &lt;property name=&quot;supportedMediaTypes&quot;&gt; &lt;list&gt; &lt;value&gt;text/html&lt;/value&gt; &lt;value&gt;application/json&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; &lt;/mvc:message-converters&gt;&lt;/mvc:annotation-driven&gt; 6、测试HelloWorlda&gt;实现对首页的访问在请求控制器中创建处理请求的方法 12345678// @RequestMapping注解：处理请求和控制器方法之间的映射关系// @RequestMapping注解的value属性可以通过请求地址匹配请求，/表示的当前工程的上下文路径// localhost:8080/springMVC/@RequestMapping(&quot;/&quot;)public String index() &#123; //设置视图名称 return &quot;index&quot;;&#125; b&gt;通过超链接跳转到指定页面在主页index.html中设置超链接 1234567891011&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;首页&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;首页&lt;/h1&gt; &lt;a th:href=&quot;@&#123;/hello&#125;&quot;&gt;HelloWorld&lt;/a&gt;&lt;br/&gt;&lt;/body&gt;&lt;/html&gt; 在请求控制器中创建处理请求的方法 1234@RequestMapping(&quot;/hello&quot;)public String HelloWorld() &#123; return &quot;target&quot;;&#125; 7、总结浏览器发送请求，若请求地址符合前端控制器的url-pattern，该请求就会被前端控制器DispatcherServlet处理。前端控制器会读取SpringMVC的核心配置文件，通过扫描组件找到控制器，将请求地址和控制器中@RequestMapping注解的value属性值进行匹配，若匹配成功，该注解所标识的控制器方法就是处理请求的方法。处理请求的方法需要返回一个字符串类型的视图名称，该视图名称会被视图解析器解析，加上前缀和后缀组成视图的路径，通过Thymeleaf对视图进行渲染，最终转发到视图所对应页面 三、@RequestMapping注解1、@RequestMapping注解的功能从注解名称上我们可以看到，@RequestMapping注解的作用就是将请求和处理请求的控制器方法关联起来，建立映射关系。 SpringMVC 接收到指定的请求，就会来找到在映射关系中对应的控制器方法来处理这个请求。 2、@RequestMapping注解的位置@RequestMapping标识一个类：设置映射请求的请求路径的初始信息 @RequestMapping标识一个方法：设置映射请求请求路径的具体信息 1234567891011@Controller@RequestMapping(&quot;/test&quot;)public class RequestMappingController &#123; //此时请求映射所映射的请求的请求路径为：/test/testRequestMapping @RequestMapping(&quot;/testRequestMapping&quot;) public String testRequestMapping()&#123; return &quot;success&quot;; &#125;&#125; 3、@RequestMapping注解的value属性@RequestMapping注解的value属性通过请求的请求地址匹配请求映射 @RequestMapping注解的value属性是一个字符串类型的数组，表示该请求映射能够匹配多个请求地址所对应的请求 @RequestMapping注解的value属性必须设置，至少通过请求地址匹配请求映射 12&lt;a th:href=&quot;@&#123;/testRequestMapping&#125;&quot;&gt;测试@RequestMapping的value属性--&gt;/testRequestMapping&lt;/a&gt;&lt;br&gt;&lt;a th:href=&quot;@&#123;/test&#125;&quot;&gt;测试@RequestMapping的value属性--&gt;/test&lt;/a&gt;&lt;br&gt; 123456@RequestMapping( value = &#123;&quot;/testRequestMapping&quot;, &quot;/test&quot;&#125;)public String testRequestMapping()&#123; return &quot;success&quot;;&#125; 4、@RequestMapping注解的method属性@RequestMapping注解的method属性通过请求的请求方式（get或post）匹配请求映射 @RequestMapping注解的method属性是一个RequestMethod类型的数组，表示该请求映射能够匹配多种请求方式的请求 若当前请求的请求地址满足请求映射的value属性，但是请求方式不满足method属性，则浏览器报错405：Request method ‘POST’ not supported 1234&lt;a th:href=&quot;@&#123;/test&#125;&quot;&gt;测试@RequestMapping的value属性--&gt;/test&lt;/a&gt;&lt;br&gt;&lt;form th:action=&quot;@&#123;/test&#125;&quot; method=&quot;post&quot;&gt; &lt;input type=&quot;submit&quot;&gt;&lt;/form&gt; 1234567@RequestMapping( value = &#123;&quot;/testRequestMapping&quot;, &quot;/test&quot;&#125;, method = &#123;RequestMethod.GET, RequestMethod.POST&#125;)public String testRequestMapping()&#123; return &quot;success&quot;;&#125; 注： 1、对于处理指定请求方式的控制器方法，SpringMVC中提供了@RequestMapping的派生注解 处理get请求的映射–&gt;@GetMapping 处理post请求的映射–&gt;@PostMapping 处理put请求的映射–&gt;@PutMapping 处理delete请求的映射–&gt;@DeleteMapping 2、常用的请求方式有get，post，put，delete 但是目前浏览器只支持get和post，若在form表单提交时，为method设置了其他请求方式的字符串（put或delete），则按照默认的请求方式get处理 若要发送put和delete请求，则需要通过spring提供的过滤器HiddenHttpMethodFilter，在RESTful部分会讲到 5、@RequestMapping注解的params属性（了解）@RequestMapping注解的params属性通过请求的请求参数匹配请求映射 @RequestMapping注解的params属性是一个字符串类型的数组，可以通过四种表达式设置请求参数和请求映射的匹配关系 “param”：要求请求映射所匹配的请求必须携带param请求参数 “!param”：要求请求映射所匹配的请求必须不能携带param请求参数 “param=value”：要求请求映射所匹配的请求必须携带param请求参数且param=value “param!=value”：要求请求映射所匹配的请求必须携带param请求参数但是param!=value 1&lt;a th:href=&quot;@&#123;/test(username=&#x27;admin&#x27;,password=123456)&quot;&gt;测试@RequestMapping的params属性--&gt;/test&lt;/a&gt;&lt;br&gt; 12345678@RequestMapping( value = &#123;&quot;/testRequestMapping&quot;, &quot;/test&quot;&#125; ,method = &#123;RequestMethod.GET, RequestMethod.POST&#125; ,params = &#123;&quot;username&quot;,&quot;password!=123456&quot;&#125;)public String testRequestMapping()&#123; return &quot;success&quot;;&#125; 注： 若当前请求满足@RequestMapping注解的value和method属性，但是不满足params属性，此时页面回报错400：Parameter conditions “username, password!=123456” not met for actual request parameters: username={admin}, password={123456} 6、@RequestMapping注解的headers属性（了解）@RequestMapping注解的headers属性通过请求的请求头信息匹配请求映射 @RequestMapping注解的headers属性是一个字符串类型的数组，可以通过四种表达式设置请求头信息和请求映射的匹配关系 “header”：要求请求映射所匹配的请求必须携带header请求头信息 “!header”：要求请求映射所匹配的请求必须不能携带header请求头信息 “header=value”：要求请求映射所匹配的请求必须携带header请求头信息且header=value “header!=value”：要求请求映射所匹配的请求必须携带header请求头信息且header!=value 若当前请求满足@RequestMapping注解的value和method属性，但是不满足headers属性，此时页面显示404错误，即资源未找到 7、SpringMVC支持ant风格的路径？：表示任意的单个字符 *：表示任意的0个或多个字符 **：表示任意的一层或多层目录 注意：在使用**时，只能使用/**/xxx的方式 8、SpringMVC支持路径中的占位符（重点）原始方式：/deleteUser?id=1 rest方式：/deleteUser/1 SpringMVC路径中的占位符常用于RESTful风格中，当请求路径中将某些数据通过路径的方式传输到服务器中，就可以在相应的@RequestMapping注解的value属性中通过占位符{xxx}表示传输的数据，在通过@PathVariable注解，将占位符所表示的数据赋值给控制器方法的形参 1&lt;a th:href=&quot;@&#123;/testRest/1/admin&#125;&quot;&gt;测试路径中的占位符--&gt;/testRest&lt;/a&gt;&lt;br&gt; 123456@RequestMapping(&quot;/testRest/&#123;id&#125;/&#123;username&#125;&quot;)public String testRest(@PathVariable(&quot;id&quot;) String id, @PathVariable(&quot;username&quot;) String username)&#123; System.out.println(&quot;id:&quot;+id+&quot;,username:&quot;+username); return &quot;success&quot;;&#125;//最终输出的内容为--&gt;id:1,username:admin 四、SpringMVC获取请求参数1、通过ServletAPI获取将HttpServletRequest作为控制器方法的形参，此时HttpServletRequest类型的参数表示封装了当前请求的请求报文的对象 1234567@RequestMapping(&quot;/testParam&quot;)public String testParam(HttpServletRequest request)&#123; String username = request.getParameter(&quot;username&quot;); String password = request.getParameter(&quot;password&quot;); System.out.println(&quot;username:&quot;+username+&quot;,password:&quot;+password); return &quot;success&quot;;&#125; 2、通过控制器方法的形参获取请求参数在控制器方法的形参位置，设置和请求参数同名的形参，当浏览器发送请求，匹配到请求映射时，在DispatcherServlet中就会将请求参数赋值给相应的形参 1&lt;a th:href=&quot;@&#123;/testParam(username=&#x27;admin&#x27;,password=123456)&#125;&quot;&gt;测试获取请求参数--&gt;/testParam&lt;/a&gt;&lt;br&gt; 12345@RequestMapping(&quot;/testParam&quot;)public String testParam(String username, String password)&#123; System.out.println(&quot;username:&quot;+username+&quot;,password:&quot;+password); return &quot;success&quot;;&#125; 注： 若请求所传输的请求参数中有多个同名的请求参数，此时可以在控制器方法的形参中设置字符串数组或者字符串类型的形参接收此请求参数 若使用字符串数组类型的形参，此参数的数组中包含了每一个数据 若使用字符串类型的形参，此参数的值为每个数据中间使用逗号拼接的结果 3、@RequestParam@RequestParam是将请求参数和控制器方法的形参创建映射关系 @RequestParam注解一共有三个属性： value：指定为形参赋值的请求参数的参数名 required：设置是否必须传输此请求参数，默认值为true 若设置为true时，则当前请求必须传输value所指定的请求参数，若没有传输该请求参数，且没有设置defaultValue属性，则页面报错400：Required String parameter ‘xxx’ is not present；若设置为false，则当前请求不是必须传输value所指定的请求参数，若没有传输，则注解所标识的形参的值为null defaultValue：不管required属性值为true或false，当value所指定的请求参数没有传输或传输的值为””时，则使用默认值为形参赋值 4、@RequestHeader@RequestHeader是将请求头信息和控制器方法的形参创建映射关系 @RequestHeader注解一共有三个属性：value、required、defaultValue，用法同@RequestParam 5、@CookieValue@CookieValue是将cookie数据和控制器方法的形参创建映射关系 @CookieValue注解一共有三个属性：value、required、defaultValue，用法同@RequestParam 6、通过POJO获取请求参数可以在控制器方法的形参位置设置一个实体类类型的形参，此时若浏览器传输的请求参数的参数名和实体类中的属性名一致，那么请求参数就会为此属性赋值 12345678&lt;form th:action=&quot;@&#123;/testpojo&#125;&quot; method=&quot;post&quot;&gt; 用户名：&lt;input type=&quot;text&quot; name=&quot;username&quot;&gt;&lt;br&gt; 密码：&lt;input type=&quot;password&quot; name=&quot;password&quot;&gt;&lt;br&gt; 性别：&lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;男&quot;&gt;男&lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;女&quot;&gt;女&lt;br&gt; 年龄：&lt;input type=&quot;text&quot; name=&quot;age&quot;&gt;&lt;br&gt; 邮箱：&lt;input type=&quot;text&quot; name=&quot;email&quot;&gt;&lt;br&gt; &lt;input type=&quot;submit&quot;&gt;&lt;/form&gt; 123456@RequestMapping(&quot;/testpojo&quot;)public String testPOJO(User user)&#123; System.out.println(user); return &quot;success&quot;;&#125;//最终结果--&gt;User&#123;id=null, username=&#x27;张三&#x27;, password=&#x27;123&#x27;, age=23, sex=&#x27;男&#x27;, email=&#x27;123@qq.com&#x27;&#125; 7、解决获取请求参数的乱码问题解决获取请求参数的乱码问题，可以使用SpringMVC提供的编码过滤器CharacterEncodingFilter，但是必须在web.xml中进行注册 1234567891011121314151617&lt;!--配置springMVC的编码过滤器--&gt;&lt;filter&gt; &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;forceResponseEncoding&lt;/param-name&gt; &lt;param-value&gt;true&lt;/param-value&gt; &lt;/init-param&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; 注： SpringMVC中处理编码的过滤器一定要配置到其他过滤器之前，否则无效 五、域对象共享数据1、使用ServletAPI向request域对象共享数据12345@RequestMapping(&quot;/testServletAPI&quot;)public String testServletAPI(HttpServletRequest request)&#123; request.setAttribute(&quot;testScope&quot;, &quot;hello,servletAPI&quot;); return &quot;success&quot;;&#125; 2、使用ModelAndView向request域对象共享数据1234567891011121314@RequestMapping(&quot;/testModelAndView&quot;)public ModelAndView testModelAndView()&#123; /** * ModelAndView有Model和View的功能 * Model主要用于向请求域共享数据 * View主要用于设置视图，实现页面跳转 */ ModelAndView mav = new ModelAndView(); //向请求域共享数据 mav.addObject(&quot;testScope&quot;, &quot;hello,ModelAndView&quot;); //设置视图，实现页面跳转 mav.setViewName(&quot;success&quot;); return mav;&#125; 3、使用Model向request域对象共享数据12345@RequestMapping(&quot;/testModel&quot;)public String testModel(Model model)&#123; model.addAttribute(&quot;testScope&quot;, &quot;hello,Model&quot;); return &quot;success&quot;;&#125; 4、使用map向request域对象共享数据12345@RequestMapping(&quot;/testMap&quot;)public String testMap(Map&lt;String, Object&gt; map)&#123; map.put(&quot;testScope&quot;, &quot;hello,Map&quot;); return &quot;success&quot;;&#125; 5、使用ModelMap向request域对象共享数据12345@RequestMapping(&quot;/testModelMap&quot;)public String testModelMap(ModelMap modelMap)&#123; modelMap.addAttribute(&quot;testScope&quot;, &quot;hello,ModelMap&quot;); return &quot;success&quot;;&#125; 6、Model、ModelMap、Map的关系Model、ModelMap、Map类型的参数其实本质上都是 BindingAwareModelMap 类型的 1234public interface Model&#123;&#125;public class ModelMap extends LinkedHashMap&lt;String, Object&gt; &#123;&#125;public class ExtendedModelMap extends ModelMap implements Model &#123;&#125;public class BindingAwareModelMap extends ExtendedModelMap &#123;&#125; 7、向session域共享数据12345@RequestMapping(&quot;/testSession&quot;)public String testSession(HttpSession session)&#123; session.setAttribute(&quot;testSessionScope&quot;, &quot;hello,session&quot;); return &quot;success&quot;;&#125; 8、向application域共享数据123456@RequestMapping(&quot;/testApplication&quot;)public String testApplication(HttpSession session)&#123; ServletContext application = session.getServletContext(); application.setAttribute(&quot;testApplicationScope&quot;, &quot;hello,application&quot;); return &quot;success&quot;;&#125; 六、SpringMVC的视图SpringMVC中的视图是View接口，视图的作用渲染数据，将模型Model中的数据展示给用户 SpringMVC视图的种类很多，默认有转发视图和重定向视图 当工程引入jstl的依赖，转发视图会自动转换为JstlView 若使用的视图技术为Thymeleaf，在SpringMVC的配置文件中配置了Thymeleaf的视图解析器，由此视图解析器解析之后所得到的是ThymeleafView 1、ThymeleafView当控制器方法中所设置的视图名称没有任何前缀时，此时的视图名称会被SpringMVC配置文件中所配置的视图解析器解析，视图名称拼接视图前缀和视图后缀所得到的最终路径，会通过转发的方式实现跳转 1234@RequestMapping(&quot;/testHello&quot;)public String testHello()&#123; return &quot;hello&quot;;&#125; 2、转发视图SpringMVC中默认的转发视图是InternalResourceView SpringMVC中创建转发视图的情况： 当控制器方法中所设置的视图名称以”forward:”为前缀时，创建InternalResourceView视图，此时的视图名称不会被SpringMVC配置文件中所配置的视图解析器解析，而是会将前缀”forward:”去掉，剩余部分作为最终路径通过转发的方式实现跳转 例如”forward:/“，”forward:/employee” 1234@RequestMapping(&quot;/testForward&quot;)public String testForward()&#123; return &quot;forward:/testHello&quot;;&#125; 3、重定向视图SpringMVC中默认的重定向视图是RedirectView 当控制器方法中所设置的视图名称以”redirect:”为前缀时，创建RedirectView视图，此时的视图名称不会被SpringMVC配置文件中所配置的视图解析器解析，而是会将前缀”redirect:”去掉，剩余部分作为最终路径通过重定向的方式实现跳转 例如”redirect:/“，”redirect:/employee” 1234@RequestMapping(&quot;/testRedirect&quot;)public String testRedirect()&#123; return &quot;redirect:/testHello&quot;;&#125; 注： 重定向视图在解析时，会先将redirect:前缀去掉，然后会判断剩余部分是否以/开头，若是则会自动拼接上下文路径 4、视图控制器view-controller当控制器方法中，仅仅用来实现页面跳转，即只需要设置视图名称时，可以将处理器方法使用view-controller标签进行表示 12345&lt;!-- path：设置处理的请求地址 view-name：设置请求地址所对应的视图名称--&gt;&lt;mvc:view-controller path=&quot;/testView&quot; view-name=&quot;success&quot;&gt;&lt;/mvc:view-controller&gt; 注： 当SpringMVC中设置任何一个view-controller时，其他控制器中的请求映射将全部失效，此时需要在SpringMVC的核心配置文件中设置开启mvc注解驱动的标签： &lt;mvc:annotation-driven /&gt; 七、RESTful1、RESTful简介REST：Representational State Transfer，表现层资源状态转移。 a&gt;资源资源是一种看待服务器的方式，即，将服务器看作是由很多离散的资源组成。每个资源是服务器上一个可命名的抽象概念。因为资源是一个抽象的概念，所以它不仅仅能代表服务器文件系统中的一个文件、数据库中的一张表等等具体的东西，可以将资源设计的要多抽象有多抽象，只要想象力允许而且客户端应用开发者能够理解。与面向对象设计类似，资源是以名词为核心来组织的，首先关注的是名词。一个资源可以由一个或多个URI来标识。URI既是资源的名称，也是资源在Web上的地址。对某个资源感兴趣的客户端应用，可以通过资源的URI与其进行交互。 b&gt;资源的表述资源的表述是一段对于资源在某个特定时刻的状态的描述。可以在客户端-服务器端之间转移（交换）。资源的表述可以有多种格式，例如HTML/XML/JSON/纯文本/图片/视频/音频等等。资源的表述格式可以通过协商机制来确定。请求-响应方向的表述通常使用不同的格式。 c&gt;状态转移状态转移说的是：在客户端和服务器端之间转移（transfer）代表资源状态的表述。通过转移和操作资源的表述，来间接实现操作资源的目的。 2、RESTful的实现具体说，就是 HTTP 协议里面，四个表示操作方式的动词：GET、POST、PUT、DELETE。 它们分别对应四种基本操作：GET 用来获取资源，POST 用来新建资源，PUT 用来更新资源，DELETE 用来删除资源。 REST 风格提倡 URL 地址使用统一的风格设计，从前到后各个单词使用斜杠分开，不使用问号键值对方式携带请求参数，而是将要发送给服务器的数据作为 URL 地址的一部分，以保证整体风格的一致性。 操作 传统方式 REST风格 查询操作 getUserById?id=1 user/1–&gt;get请求方式 保存操作 saveUser user–&gt;post请求方式 删除操作 deleteUser?id=1 user/1–&gt;delete请求方式 更新操作 updateUser user–&gt;put请求方式 3、HiddenHttpMethodFilter由于浏览器只支持发送get和post方式的请求，那么该如何发送put和delete请求呢？ SpringMVC 提供了 HiddenHttpMethodFilter 帮助我们将 POST 请求转换为 DELETE 或 PUT 请求 HiddenHttpMethodFilter 处理put和delete请求的条件： a&gt;当前请求的请求方式必须为post b&gt;当前请求必须传输请求参数_method 满足以上条件，HiddenHttpMethodFilter 过滤器就会将当前请求的请求方式转换为请求参数_method的值，因此请求参数_method的值才是最终的请求方式 在web.xml中注册HiddenHttpMethodFilter 12345678&lt;filter&gt; &lt;filter-name&gt;HiddenHttpMethodFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.HiddenHttpMethodFilter&lt;/filter-class&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;HiddenHttpMethodFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; 注： 目前为止，SpringMVC中提供了两个过滤器：CharacterEncodingFilter和HiddenHttpMethodFilter 在web.xml中注册时，必须先注册CharacterEncodingFilter，再注册HiddenHttpMethodFilter 原因： 在 CharacterEncodingFilter 中通过 request.setCharacterEncoding(encoding) 方法设置字符集的 request.setCharacterEncoding(encoding) 方法要求前面不能有任何获取请求参数的操作 而 HiddenHttpMethodFilter 恰恰有一个获取请求方式的操作： 1String paramValue = request.getParameter(this.methodParam); 八、RESTful案例1、准备工作和传统 CRUD 一样，实现对员工信息的增删改查。 搭建环境 准备实体类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354package com.atguigu.mvc.bean;public class Employee &#123; private Integer id; private String lastName; private String email; //1 male, 0 female private Integer gender; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getLastName() &#123; return lastName; &#125; public void setLastName(String lastName) &#123; this.lastName = lastName; &#125; public String getEmail() &#123; return email; &#125; public void setEmail(String email) &#123; this.email = email; &#125; public Integer getGender() &#123; return gender; &#125; public void setGender(Integer gender) &#123; this.gender = gender; &#125; public Employee(Integer id, String lastName, String email, Integer gender) &#123; super(); this.id = id; this.lastName = lastName; this.email = email; this.gender = gender; &#125; public Employee() &#123; &#125;&#125; 准备dao模拟数据 12345678910111213141516171819202122232425262728293031323334353637383940414243444546package com.atguigu.mvc.dao;import java.util.Collection;import java.util.HashMap;import java.util.Map;import com.atguigu.mvc.bean.Employee;import org.springframework.stereotype.Repository;@Repositorypublic class EmployeeDao &#123; private static Map&lt;Integer, Employee&gt; employees = null; static&#123; employees = new HashMap&lt;Integer, Employee&gt;(); employees.put(1001, new Employee(1001, &quot;E-AA&quot;, &quot;aa@163.com&quot;, 1)); employees.put(1002, new Employee(1002, &quot;E-BB&quot;, &quot;bb@163.com&quot;, 1)); employees.put(1003, new Employee(1003, &quot;E-CC&quot;, &quot;cc@163.com&quot;, 0)); employees.put(1004, new Employee(1004, &quot;E-DD&quot;, &quot;dd@163.com&quot;, 0)); employees.put(1005, new Employee(1005, &quot;E-EE&quot;, &quot;ee@163.com&quot;, 1)); &#125; private static Integer initId = 1006; public void save(Employee employee)&#123; if(employee.getId() == null)&#123; employee.setId(initId++); &#125; employees.put(employee.getId(), employee); &#125; public Collection&lt;Employee&gt; getAll()&#123; return employees.values(); &#125; public Employee get(Integer id)&#123; return employees.get(id); &#125; public void delete(Integer id)&#123; employees.remove(id); &#125;&#125; 2、功能清单 功能 URL 地址 请求方式 访问首页√ / GET 查询全部数据√ /employee GET 删除√ /employee/2 DELETE 跳转到添加数据页面√ /toAdd GET 执行保存√ /employee POST 跳转到更新数据页面√ /employee/2 GET 执行更新√ /employee PUT 3、具体功能：访问首页a&gt;配置view-controller1&lt;mvc:view-controller path=&quot;/&quot; view-name=&quot;index&quot;/&gt; b&gt;创建页面1234567891011&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; &gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;首页&lt;/h1&gt;&lt;a th:href=&quot;@&#123;/employee&#125;&quot;&gt;访问员工信息&lt;/a&gt;&lt;/body&gt;&lt;/html&gt; 4、具体功能：查询所有员工数据a&gt;控制器方法123456@RequestMapping(value = &quot;/employee&quot;, method = RequestMethod.GET)public String getEmployeeList(Model model)&#123; Collection&lt;Employee&gt; employeeList = employeeDao.getAll(); model.addAttribute(&quot;employeeList&quot;, employeeList); return &quot;employee_list&quot;;&#125; b&gt;创建employee_list.html123456789101112131415161718192021222324252627282930313233&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Employee Info&lt;/title&gt; &lt;script type=&quot;text/javascript&quot; th:src=&quot;@&#123;/static/js/vue.js&#125;&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;table border=&quot;1&quot; cellpadding=&quot;0&quot; cellspacing=&quot;0&quot; style=&quot;text-align: center;&quot; id=&quot;dataTable&quot;&gt; &lt;tr&gt; &lt;th colspan=&quot;5&quot;&gt;Employee Info&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;th&gt;id&lt;/th&gt; &lt;th&gt;lastName&lt;/th&gt; &lt;th&gt;email&lt;/th&gt; &lt;th&gt;gender&lt;/th&gt; &lt;th&gt;options(&lt;a th:href=&quot;@&#123;/toAdd&#125;&quot;&gt;add&lt;/a&gt;)&lt;/th&gt; &lt;/tr&gt; &lt;tr th:each=&quot;employee : $&#123;employeeList&#125;&quot;&gt; &lt;td th:text=&quot;$&#123;employee.id&#125;&quot;&gt;&lt;/td&gt; &lt;td th:text=&quot;$&#123;employee.lastName&#125;&quot;&gt;&lt;/td&gt; &lt;td th:text=&quot;$&#123;employee.email&#125;&quot;&gt;&lt;/td&gt; &lt;td th:text=&quot;$&#123;employee.gender&#125;&quot;&gt;&lt;/td&gt; &lt;td&gt; &lt;a class=&quot;deleteA&quot; @click=&quot;deleteEmployee&quot; th:href=&quot;@&#123;&#x27;/employee/&#x27;+$&#123;employee.id&#125;&#125;&quot;&gt;delete&lt;/a&gt; &lt;a th:href=&quot;@&#123;&#x27;/employee/&#x27;+$&#123;employee.id&#125;&#125;&quot;&gt;update&lt;/a&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt;&lt;/body&gt;&lt;/html&gt; 5、具体功能：删除a&gt;创建处理delete请求方式的表单12345&lt;!-- 作用：通过超链接控制表单的提交，将post请求转换为delete请求 --&gt;&lt;form id=&quot;delete_form&quot; method=&quot;post&quot;&gt; &lt;!-- HiddenHttpMethodFilter要求：必须传输_method请求参数，并且值为最终的请求方式 --&gt; &lt;input type=&quot;hidden&quot; name=&quot;_method&quot; value=&quot;delete&quot;/&gt;&lt;/form&gt; b&gt;删除超链接绑定点击事件引入vue.js 1&lt;script type=&quot;text/javascript&quot; th:src=&quot;@&#123;/static/js/vue.js&#125;&quot;&gt;&lt;/script&gt; 删除超链接 1&lt;a class=&quot;deleteA&quot; @click=&quot;deleteEmployee&quot; th:href=&quot;@&#123;&#x27;/employee/&#x27;+$&#123;employee.id&#125;&#125;&quot;&gt;delete&lt;/a&gt; 通过vue处理点击事件 123456789101112131415161718&lt;script type=&quot;text/javascript&quot;&gt; var vue = new Vue(&#123; el:&quot;#dataTable&quot;, methods:&#123; //event表示当前事件 deleteEmployee:function (event) &#123; //通过id获取表单标签 var delete_form = document.getElementById(&quot;delete_form&quot;); //将触发事件的超链接的href属性为表单的action属性赋值 delete_form.action = event.target.href; //提交表单 delete_form.submit(); //阻止超链接的默认跳转行为 event.preventDefault(); &#125; &#125; &#125;);&lt;/script&gt; c&gt;控制器方法12345@RequestMapping(value = &quot;/employee/&#123;id&#125;&quot;, method = RequestMethod.DELETE)public String deleteEmployee(@PathVariable(&quot;id&quot;) Integer id)&#123; employeeDao.delete(id); return &quot;redirect:/employee&quot;;&#125; 6、具体功能：跳转到添加数据页面a&gt;配置view-controller1&lt;mvc:view-controller path=&quot;/toAdd&quot; view-name=&quot;employee_add&quot;&gt;&lt;/mvc:view-controller&gt; b&gt;创建employee_add.html123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Add Employee&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form th:action=&quot;@&#123;/employee&#125;&quot; method=&quot;post&quot;&gt; lastName:&lt;input type=&quot;text&quot; name=&quot;lastName&quot;&gt;&lt;br&gt; email:&lt;input type=&quot;text&quot; name=&quot;email&quot;&gt;&lt;br&gt; gender:&lt;input type=&quot;radio&quot; name=&quot;gender&quot; value=&quot;1&quot;&gt;male &lt;input type=&quot;radio&quot; name=&quot;gender&quot; value=&quot;0&quot;&gt;female&lt;br&gt; &lt;input type=&quot;submit&quot; value=&quot;add&quot;&gt;&lt;br&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 7、具体功能：执行保存a&gt;控制器方法12345@RequestMapping(value = &quot;/employee&quot;, method = RequestMethod.POST)public String addEmployee(Employee employee)&#123; employeeDao.save(employee); return &quot;redirect:/employee&quot;;&#125; 8、具体功能：跳转到更新数据页面a&gt;修改超链接1&lt;a th:href=&quot;@&#123;&#x27;/employee/&#x27;+$&#123;employee.id&#125;&#125;&quot;&gt;update&lt;/a&gt; b&gt;控制器方法123456@RequestMapping(value = &quot;/employee/&#123;id&#125;&quot;, method = RequestMethod.GET)public String getEmployeeById(@PathVariable(&quot;id&quot;) Integer id, Model model)&#123; Employee employee = employeeDao.get(id); model.addAttribute(&quot;employee&quot;, employee); return &quot;employee_update&quot;;&#125; c&gt;创建employee_update.html123456789101112131415161718192021222324&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Update Employee&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form th:action=&quot;@&#123;/employee&#125;&quot; method=&quot;post&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;_method&quot; value=&quot;put&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;id&quot; th:value=&quot;$&#123;employee.id&#125;&quot;&gt; lastName:&lt;input type=&quot;text&quot; name=&quot;lastName&quot; th:value=&quot;$&#123;employee.lastName&#125;&quot;&gt;&lt;br&gt; email:&lt;input type=&quot;text&quot; name=&quot;email&quot; th:value=&quot;$&#123;employee.email&#125;&quot;&gt;&lt;br&gt; &lt;!-- th:field=&quot;$&#123;employee.gender&#125;&quot;可用于单选框或复选框的回显 若单选框的value和employee.gender的值一致，则添加checked=&quot;checked&quot;属性 --&gt; gender:&lt;input type=&quot;radio&quot; name=&quot;gender&quot; value=&quot;1&quot; th:field=&quot;$&#123;employee.gender&#125;&quot;&gt;male &lt;input type=&quot;radio&quot; name=&quot;gender&quot; value=&quot;0&quot; th:field=&quot;$&#123;employee.gender&#125;&quot;&gt;female&lt;br&gt; &lt;input type=&quot;submit&quot; value=&quot;update&quot;&gt;&lt;br&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 9、具体功能：执行更新a&gt;控制器方法12345@RequestMapping(value = &quot;/employee&quot;, method = RequestMethod.PUT)public String updateEmployee(Employee employee)&#123; employeeDao.save(employee); return &quot;redirect:/employee&quot;;&#125; 八、HttpMessageConverterHttpMessageConverter，报文信息转换器，将请求报文转换为Java对象，或将Java对象转换为响应报文 HttpMessageConverter提供了两个注解和两个类型：@RequestBody，@ResponseBody，RequestEntity， ResponseEntity 1、@RequestBody@RequestBody可以获取请求体，需要在控制器方法设置一个形参，使用@RequestBody进行标识，当前请求的请求体就会为当前注解所标识的形参赋值 12345&lt;form th:action=&quot;@&#123;/testRequestBody&#125;&quot; method=&quot;post&quot;&gt; 用户名：&lt;input type=&quot;text&quot; name=&quot;username&quot;&gt;&lt;br&gt; 密码：&lt;input type=&quot;password&quot; name=&quot;password&quot;&gt;&lt;br&gt; &lt;input type=&quot;submit&quot;&gt;&lt;/form&gt; 12345@RequestMapping(&quot;/testRequestBody&quot;)public String testRequestBody(@RequestBody String requestBody)&#123; System.out.println(&quot;requestBody:&quot;+requestBody); return &quot;success&quot;;&#125; 输出结果： requestBody:username=admin&amp;password=123456 2、RequestEntityRequestEntity封装请求报文的一种类型，需要在控制器方法的形参中设置该类型的形参，当前请求的请求报文就会赋值给该形参，可以通过getHeaders()获取请求头信息，通过getBody()获取请求体信息 123456@RequestMapping(&quot;/testRequestEntity&quot;)public String testRequestEntity(RequestEntity&lt;String&gt; requestEntity)&#123; System.out.println(&quot;requestHeader:&quot;+requestEntity.getHeaders()); System.out.println(&quot;requestBody:&quot;+requestEntity.getBody()); return &quot;success&quot;;&#125; 输出结果：requestHeader:[host:”localhost:8080”, connection:”keep-alive”, content-length:”27”, cache-control:”max-age=0”, sec-ch-ua:”” Not A;Brand”;v=”99”, “Chromium”;v=”90”, “Google Chrome”;v=”90””, sec-ch-ua-mobile:”?0”, upgrade-insecure-requests:”1”, origin:”http://localhost:8080&quot;, user-agent:”Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/90.0.4430.93 Safari/537.36”]requestBody:username=admin&amp;password=123 3、@ResponseBody@ResponseBody用于标识一个控制器方法，可以将该方法的返回值直接作为响应报文的响应体响应到浏览器 12345@RequestMapping(&quot;/testResponseBody&quot;)@ResponseBodypublic String testResponseBody()&#123; return &quot;success&quot;;&#125; 结果：浏览器页面显示success 4、SpringMVC处理json@ResponseBody处理json的步骤： a&gt;导入jackson的依赖 12345&lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.12.1&lt;/version&gt;&lt;/dependency&gt; b&gt;在SpringMVC的核心配置文件中开启mvc的注解驱动，此时在HandlerAdaptor中会自动装配一个消息转换器：MappingJackson2HttpMessageConverter，可以将响应到浏览器的Java对象转换为Json格式的字符串 1&lt;mvc:annotation-driven /&gt; c&gt;在处理器方法上使用@ResponseBody注解进行标识 d&gt;将Java对象直接作为控制器方法的返回值返回，就会自动转换为Json格式的字符串 12345@RequestMapping(&quot;/testResponseUser&quot;)@ResponseBodypublic User testResponseUser()&#123; return new User(1001,&quot;admin&quot;,&quot;123456&quot;,23,&quot;男&quot;);&#125; 浏览器的页面中展示的结果： {“id”:1001,”username”:”admin”,”password”:”123456”,”age”:23,”sex”:”男”} 5、SpringMVC处理ajaxa&gt;请求超链接： 123&lt;div id=&quot;app&quot;&gt; &lt;a th:href=&quot;@&#123;/testAjax&#125;&quot; @click=&quot;testAjax&quot;&gt;testAjax&lt;/a&gt;&lt;br&gt;&lt;/div&gt; b&gt;通过vue和axios处理点击事件： 12345678910111213141516171819202122&lt;script type=&quot;text/javascript&quot; th:src=&quot;@&#123;/static/js/vue.js&#125;&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot; th:src=&quot;@&#123;/static/js/axios.min.js&#125;&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot;&gt; var vue = new Vue(&#123; el:&quot;#app&quot;, methods:&#123; testAjax:function (event) &#123; axios(&#123; method:&quot;post&quot;, url:event.target.href, params:&#123; username:&quot;admin&quot;, password:&quot;123456&quot; &#125; &#125;).then(function (response) &#123; alert(response.data); &#125;); event.preventDefault(); &#125; &#125; &#125;);&lt;/script&gt; c&gt;控制器方法： 123456@RequestMapping(&quot;/testAjax&quot;)@ResponseBodypublic String testAjax(String username, String password)&#123; System.out.println(&quot;username:&quot;+username+&quot;,password:&quot;+password); return &quot;hello,ajax&quot;;&#125; 6、@RestController注解@RestController注解是springMVC提供的一个复合注解，标识在控制器的类上，就相当于为类添加了@Controller注解，并且为其中的每个方法添加了@ResponseBody注解 7、ResponseEntityResponseEntity用于控制器方法的返回值类型，该控制器方法的返回值就是响应到浏览器的响应报文 九、文件上传和下载1、文件下载使用ResponseEntity实现下载文件的功能 123456789101112131415161718192021222324@RequestMapping(&quot;/testDown&quot;)public ResponseEntity&lt;byte[]&gt; testResponseEntity(HttpSession session) throws IOException &#123; //获取ServletContext对象 ServletContext servletContext = session.getServletContext(); //获取服务器中文件的真实路径 String realPath = servletContext.getRealPath(&quot;/static/img/1.jpg&quot;); //创建输入流 InputStream is = new FileInputStream(realPath); //创建字节数组 byte[] bytes = new byte[is.available()]; //将流读到字节数组中 is.read(bytes); //创建HttpHeaders对象设置响应头信息 MultiValueMap&lt;String, String&gt; headers = new HttpHeaders(); //设置要下载方式以及下载文件的名字 headers.add(&quot;Content-Disposition&quot;, &quot;attachment;filename=1.jpg&quot;); //设置响应状态码 HttpStatus statusCode = HttpStatus.OK; //创建ResponseEntity对象 ResponseEntity&lt;byte[]&gt; responseEntity = new ResponseEntity&lt;&gt;(bytes, headers, statusCode); //关闭输入流 is.close(); return responseEntity;&#125; 2、文件上传文件上传要求form表单的请求方式必须为post，并且添加属性enctype=”multipart/form-data” SpringMVC中将上传的文件封装到MultipartFile对象中，通过此对象可以获取文件相关信息 上传步骤： a&gt;添加依赖： 123456&lt;!-- https://mvnrepository.com/artifact/commons-fileupload/commons-fileupload --&gt;&lt;dependency&gt; &lt;groupId&gt;commons-fileupload&lt;/groupId&gt; &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt; &lt;version&gt;1.3.1&lt;/version&gt;&lt;/dependency&gt; b&gt;在SpringMVC的配置文件中添加配置： 12&lt;!--必须通过文件解析器的解析才能将文件转换为MultipartFile对象--&gt;&lt;bean id=&quot;multipartResolver&quot; class=&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;&gt;&lt;/bean&gt; c&gt;控制器方法： 12345678910111213141516171819@RequestMapping(&quot;/testUp&quot;)public String testUp(MultipartFile photo, HttpSession session) throws IOException &#123; //获取上传的文件的文件名 String fileName = photo.getOriginalFilename(); //处理文件重名问题 String hzName = fileName.substring(fileName.lastIndexOf(&quot;.&quot;)); fileName = UUID.randomUUID().toString() + hzName; //获取服务器中photo目录的路径 ServletContext servletContext = session.getServletContext(); String photoPath = servletContext.getRealPath(&quot;photo&quot;); File file = new File(photoPath); if(!file.exists())&#123; file.mkdir(); &#125; String finalPath = photoPath + File.separator + fileName; //实现上传功能 photo.transferTo(new File(finalPath)); return &quot;success&quot;;&#125; 十、拦截器1、拦截器的配置SpringMVC中的拦截器用于拦截控制器方法的执行 SpringMVC中的拦截器需要实现HandlerInterceptor SpringMVC的拦截器必须在SpringMVC的配置文件中进行配置： 1234567891011&lt;bean class=&quot;com.atguigu.interceptor.FirstInterceptor&quot;&gt;&lt;/bean&gt;&lt;ref bean=&quot;firstInterceptor&quot;&gt;&lt;/ref&gt;&lt;!-- 以上两种配置方式都是对DispatcherServlet所处理的所有的请求进行拦截 --&gt;&lt;mvc:interceptor&gt; &lt;mvc:mapping path=&quot;/**&quot;/&gt; &lt;mvc:exclude-mapping path=&quot;/testRequestEntity&quot;/&gt; &lt;ref bean=&quot;firstInterceptor&quot;&gt;&lt;/ref&gt;&lt;/mvc:interceptor&gt;&lt;!-- 以上配置方式可以通过ref或bean标签设置拦截器，通过mvc:mapping设置需要拦截的请求，通过mvc:exclude-mapping设置需要排除的请求，即不需要拦截的请求--&gt; 2、拦截器的三个抽象方法SpringMVC中的拦截器有三个抽象方法： preHandle：控制器方法执行之前执行preHandle()，其boolean类型的返回值表示是否拦截或放行，返回true为放行，即调用控制器方法；返回false表示拦截，即不调用控制器方法 postHandle：控制器方法执行之后执行postHandle() afterComplation：处理完视图和模型数据，渲染视图完毕之后执行afterComplation() 3、多个拦截器的执行顺序a&gt;若每个拦截器的preHandle()都返回true 此时多个拦截器的执行顺序和拦截器在SpringMVC的配置文件的配置顺序有关： preHandle()会按照配置的顺序执行，而postHandle()和afterComplation()会按照配置的反序执行 b&gt;若某个拦截器的preHandle()返回了false preHandle()返回false和它之前的拦截器的preHandle()都会执行，postHandle()都不执行，返回false的拦截器之前的拦截器的afterComplation()会执行 十一、异常处理器1、基于配置的异常处理SpringMVC提供了一个处理控制器方法执行过程中所出现的异常的接口：HandlerExceptionResolver HandlerExceptionResolver接口的实现类有：DefaultHandlerExceptionResolver和SimpleMappingExceptionResolver SpringMVC提供了自定义的异常处理器SimpleMappingExceptionResolver，使用方式： 123456789101112131415&lt;bean class=&quot;org.springframework.web.servlet.handler.SimpleMappingExceptionResolver&quot;&gt; &lt;property name=&quot;exceptionMappings&quot;&gt; &lt;props&gt; &lt;!-- properties的键表示处理器方法执行过程中出现的异常 properties的值表示若出现指定异常时，设置一个新的视图名称，跳转到指定页面 --&gt; &lt;prop key=&quot;java.lang.ArithmeticException&quot;&gt;error&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt; &lt;!-- exceptionAttribute属性设置一个属性名，将出现的异常信息在请求域中进行共享 --&gt; &lt;property name=&quot;exceptionAttribute&quot; value=&quot;ex&quot;&gt;&lt;/property&gt;&lt;/bean&gt; 2、基于注解的异常处理12345678910111213//@ControllerAdvice将当前类标识为异常处理的组件@ControllerAdvicepublic class ExceptionController &#123; //@ExceptionHandler用于设置所标识方法处理的异常 @ExceptionHandler(ArithmeticException.class) //ex表示当前请求处理中出现的异常对象 public String handleArithmeticException(Exception ex, Model model)&#123; model.addAttribute(&quot;ex&quot;, ex); return &quot;error&quot;; &#125;&#125; 十二、注解配置SpringMVC使用配置类和注解代替web.xml和SpringMVC配置文件的功能 1、创建初始化类，代替web.xml在Servlet3.0环境中，容器会在类路径中查找实现javax.servlet.ServletContainerInitializer接口的类，如果找到的话就用它来配置Servlet容器。Spring提供了这个接口的实现，名为SpringServletContainerInitializer，这个类反过来又会查找实现WebApplicationInitializer的类并将配置的任务交给它们来完成。Spring3.2引入了一个便利的WebApplicationInitializer基础实现，名为AbstractAnnotationConfigDispatcherServletInitializer，当我们的类扩展了AbstractAnnotationConfigDispatcherServletInitializer并将其部署到Servlet3.0容器的时候，容器会自动发现它，并用它来配置Servlet上下文。 123456789101112131415161718192021222324252627282930313233343536373839404142public class WebInit extends AbstractAnnotationConfigDispatcherServletInitializer &#123; /** * 指定spring的配置类 * @return */ @Override protected Class&lt;?&gt;[] getRootConfigClasses() &#123; return new Class[]&#123;SpringConfig.class&#125;; &#125; /** * 指定SpringMVC的配置类 * @return */ @Override protected Class&lt;?&gt;[] getServletConfigClasses() &#123; return new Class[]&#123;WebConfig.class&#125;; &#125; /** * 指定DispatcherServlet的映射规则，即url-pattern * @return */ @Override protected String[] getServletMappings() &#123; return new String[]&#123;&quot;/&quot;&#125;; &#125; /** * 添加过滤器 * @return */ @Override protected Filter[] getServletFilters() &#123; CharacterEncodingFilter encodingFilter = new CharacterEncodingFilter(); encodingFilter.setEncoding(&quot;UTF-8&quot;); encodingFilter.setForceRequestEncoding(true); HiddenHttpMethodFilter hiddenHttpMethodFilter = new HiddenHttpMethodFilter(); return new Filter[]&#123;encodingFilter, hiddenHttpMethodFilter&#125;; &#125;&#125; 2、创建SpringConfig配置类，代替spring的配置文件1234@Configurationpublic class SpringConfig &#123; //ssm整合之后，spring的配置信息写在此类中&#125; 3、创建WebConfig配置类，代替SpringMVC的配置文件12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879@Configuration//扫描组件@ComponentScan(&quot;com.atguigu.mvc.controller&quot;)//开启MVC注解驱动@EnableWebMvcpublic class WebConfig implements WebMvcConfigurer &#123; //使用默认的servlet处理静态资源 @Override public void configureDefaultServletHandling(DefaultServletHandlerConfigurer configurer) &#123; configurer.enable(); &#125; //配置文件上传解析器 @Bean public CommonsMultipartResolver multipartResolver()&#123; return new CommonsMultipartResolver(); &#125; //配置拦截器 @Override public void addInterceptors(InterceptorRegistry registry) &#123; FirstInterceptor firstInterceptor = new FirstInterceptor(); registry.addInterceptor(firstInterceptor).addPathPatterns(&quot;/**&quot;); &#125; //配置视图控制 /*@Override public void addViewControllers(ViewControllerRegistry registry) &#123; registry.addViewController(&quot;/&quot;).setViewName(&quot;index&quot;); &#125;*/ //配置异常映射 /*@Override public void configureHandlerExceptionResolvers(List&lt;HandlerExceptionResolver&gt; resolvers) &#123; SimpleMappingExceptionResolver exceptionResolver = new SimpleMappingExceptionResolver(); Properties prop = new Properties(); prop.setProperty(&quot;java.lang.ArithmeticException&quot;, &quot;error&quot;); //设置异常映射 exceptionResolver.setExceptionMappings(prop); //设置共享异常信息的键 exceptionResolver.setExceptionAttribute(&quot;ex&quot;); resolvers.add(exceptionResolver); &#125;*/ //配置生成模板解析器 @Bean public ITemplateResolver templateResolver() &#123; WebApplicationContext webApplicationContext = ContextLoader.getCurrentWebApplicationContext(); // ServletContextTemplateResolver需要一个ServletContext作为构造参数，可通过WebApplicationContext 的方法获得 ServletContextTemplateResolver templateResolver = new ServletContextTemplateResolver( webApplicationContext.getServletContext()); templateResolver.setPrefix(&quot;/WEB-INF/templates/&quot;); templateResolver.setSuffix(&quot;.html&quot;); templateResolver.setCharacterEncoding(&quot;UTF-8&quot;); templateResolver.setTemplateMode(TemplateMode.HTML); return templateResolver; &#125; //生成模板引擎并为模板引擎注入模板解析器 @Bean public SpringTemplateEngine templateEngine(ITemplateResolver templateResolver) &#123; SpringTemplateEngine templateEngine = new SpringTemplateEngine(); templateEngine.setTemplateResolver(templateResolver); return templateEngine; &#125; //生成视图解析器并未解析器注入模板引擎 @Bean public ViewResolver viewResolver(SpringTemplateEngine templateEngine) &#123; ThymeleafViewResolver viewResolver = new ThymeleafViewResolver(); viewResolver.setCharacterEncoding(&quot;UTF-8&quot;); viewResolver.setTemplateEngine(templateEngine); return viewResolver; &#125;&#125; 4、测试功能1234@RequestMapping(&quot;/&quot;)public String index()&#123; return &quot;index&quot;;&#125; 十三、SpringMVC执行流程1、SpringMVC常用组件 DispatcherServlet：前端控制器，不需要工程师开发，由框架提供 作用：统一处理请求和响应，整个流程控制的中心，由它调用其它组件处理用户的请求 HandlerMapping：处理器映射器，不需要工程师开发，由框架提供 作用：根据请求的url、method等信息查找Handler，即控制器方法 Handler：处理器，需要工程师开发 作用：在DispatcherServlet的控制下Handler对具体的用户请求进行处理 HandlerAdapter：处理器适配器，不需要工程师开发，由框架提供 作用：通过HandlerAdapter对处理器（控制器方法）进行执行 ViewResolver：视图解析器，不需要工程师开发，由框架提供 作用：进行视图解析，得到相应的视图，例如：ThymeleafView、InternalResourceView、RedirectView View：视图 作用：将模型数据通过页面展示给用户 2、DispatcherServlet初始化过程DispatcherServlet 本质上是一个 Servlet，所以天然的遵循 Servlet 的生命周期。所以宏观上是 Servlet 生命周期来进行调度。 a&gt;初始化WebApplicationContext所在类：org.springframework.web.servlet.FrameworkServlet 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354protected WebApplicationContext initWebApplicationContext() &#123; WebApplicationContext rootContext = WebApplicationContextUtils.getWebApplicationContext(getServletContext()); WebApplicationContext wac = null; if (this.webApplicationContext != null) &#123; // A context instance was injected at construction time -&gt; use it wac = this.webApplicationContext; if (wac instanceof ConfigurableWebApplicationContext) &#123; ConfigurableWebApplicationContext cwac = (ConfigurableWebApplicationContext) wac; if (!cwac.isActive()) &#123; // The context has not yet been refreshed -&gt; provide services such as // setting the parent context, setting the application context id, etc if (cwac.getParent() == null) &#123; // The context instance was injected without an explicit parent -&gt; set // the root application context (if any; may be null) as the parent cwac.setParent(rootContext); &#125; configureAndRefreshWebApplicationContext(cwac); &#125; &#125; &#125; if (wac == null) &#123; // No context instance was injected at construction time -&gt; see if one // has been registered in the servlet context. If one exists, it is assumed // that the parent context (if any) has already been set and that the // user has performed any initialization such as setting the context id wac = findWebApplicationContext(); &#125; if (wac == null) &#123; // No context instance is defined for this servlet -&gt; create a local one // 创建WebApplicationContext wac = createWebApplicationContext(rootContext); &#125; if (!this.refreshEventReceived) &#123; // Either the context is not a ConfigurableApplicationContext with refresh // support or the context injected at construction time had already been // refreshed -&gt; trigger initial onRefresh manually here. synchronized (this.onRefreshMonitor) &#123; // 刷新WebApplicationContext onRefresh(wac); &#125; &#125; if (this.publishContext) &#123; // Publish the context as a servlet context attribute. // 将IOC容器在应用域共享 String attrName = getServletContextAttributeName(); getServletContext().setAttribute(attrName, wac); &#125; return wac;&#125; b&gt;创建WebApplicationContext所在类：org.springframework.web.servlet.FrameworkServlet 1234567891011121314151617181920212223protected WebApplicationContext createWebApplicationContext(@Nullable ApplicationContext parent) &#123; Class&lt;?&gt; contextClass = getContextClass(); if (!ConfigurableWebApplicationContext.class.isAssignableFrom(contextClass)) &#123; throw new ApplicationContextException( &quot;Fatal initialization error in servlet with name &#x27;&quot; + getServletName() + &quot;&#x27;: custom WebApplicationContext class [&quot; + contextClass.getName() + &quot;] is not of type ConfigurableWebApplicationContext&quot;); &#125; // 通过反射创建 IOC 容器对象 ConfigurableWebApplicationContext wac = (ConfigurableWebApplicationContext) BeanUtils.instantiateClass(contextClass); wac.setEnvironment(getEnvironment()); // 设置父容器 wac.setParent(parent); String configLocation = getContextConfigLocation(); if (configLocation != null) &#123; wac.setConfigLocation(configLocation); &#125; configureAndRefreshWebApplicationContext(wac); return wac;&#125; c&gt;DispatcherServlet初始化策略FrameworkServlet创建WebApplicationContext后，刷新容器，调用onRefresh(wac)，此方法在DispatcherServlet中进行了重写，调用了initStrategies(context)方法，初始化策略，即初始化DispatcherServlet的各个组件 所在类：org.springframework.web.servlet.DispatcherServlet 1234567891011protected void initStrategies(ApplicationContext context) &#123; initMultipartResolver(context); initLocaleResolver(context); initThemeResolver(context); initHandlerMappings(context); initHandlerAdapters(context); initHandlerExceptionResolvers(context); initRequestToViewNameTranslator(context); initViewResolvers(context); initFlashMapManager(context);&#125; 3、DispatcherServlet调用组件处理请求a&gt;processRequest()FrameworkServlet重写HttpServlet中的service()和doXxx()，这些方法中调用了processRequest(request, response) 所在类：org.springframework.web.servlet.FrameworkServlet 123456789101112131415161718192021222324252627282930313233343536373839protected final void processRequest(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; long startTime = System.currentTimeMillis(); Throwable failureCause = null; LocaleContext previousLocaleContext = LocaleContextHolder.getLocaleContext(); LocaleContext localeContext = buildLocaleContext(request); RequestAttributes previousAttributes = RequestContextHolder.getRequestAttributes(); ServletRequestAttributes requestAttributes = buildRequestAttributes(request, response, previousAttributes); WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request); asyncManager.registerCallableInterceptor(FrameworkServlet.class.getName(), new RequestBindingInterceptor()); initContextHolders(request, localeContext, requestAttributes); try &#123; // 执行服务，doService()是一个抽象方法，在DispatcherServlet中进行了重写 doService(request, response); &#125; catch (ServletException | IOException ex) &#123; failureCause = ex; throw ex; &#125; catch (Throwable ex) &#123; failureCause = ex; throw new NestedServletException(&quot;Request processing failed&quot;, ex); &#125; finally &#123; resetContextHolders(request, previousLocaleContext, previousAttributes); if (requestAttributes != null) &#123; requestAttributes.requestCompleted(); &#125; logResult(request, response, failureCause, asyncManager); publishRequestHandledEvent(request, response, startTime, failureCause); &#125;&#125; b&gt;doService()所在类：org.springframework.web.servlet.DispatcherServlet 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354@Overrideprotected void doService(HttpServletRequest request, HttpServletResponse response) throws Exception &#123; logRequest(request); // Keep a snapshot of the request attributes in case of an include, // to be able to restore the original attributes after the include. Map&lt;String, Object&gt; attributesSnapshot = null; if (WebUtils.isIncludeRequest(request)) &#123; attributesSnapshot = new HashMap&lt;&gt;(); Enumeration&lt;?&gt; attrNames = request.getAttributeNames(); while (attrNames.hasMoreElements()) &#123; String attrName = (String) attrNames.nextElement(); if (this.cleanupAfterInclude || attrName.startsWith(DEFAULT_STRATEGIES_PREFIX)) &#123; attributesSnapshot.put(attrName, request.getAttribute(attrName)); &#125; &#125; &#125; // Make framework objects available to handlers and view objects. request.setAttribute(WEB_APPLICATION_CONTEXT_ATTRIBUTE, getWebApplicationContext()); request.setAttribute(LOCALE_RESOLVER_ATTRIBUTE, this.localeResolver); request.setAttribute(THEME_RESOLVER_ATTRIBUTE, this.themeResolver); request.setAttribute(THEME_SOURCE_ATTRIBUTE, getThemeSource()); if (this.flashMapManager != null) &#123; FlashMap inputFlashMap = this.flashMapManager.retrieveAndUpdate(request, response); if (inputFlashMap != null) &#123; request.setAttribute(INPUT_FLASH_MAP_ATTRIBUTE, Collections.unmodifiableMap(inputFlashMap)); &#125; request.setAttribute(OUTPUT_FLASH_MAP_ATTRIBUTE, new FlashMap()); request.setAttribute(FLASH_MAP_MANAGER_ATTRIBUTE, this.flashMapManager); &#125; RequestPath requestPath = null; if (this.parseRequestPath &amp;&amp; !ServletRequestPathUtils.hasParsedRequestPath(request)) &#123; requestPath = ServletRequestPathUtils.parseAndCache(request); &#125; try &#123; // 处理请求和响应 doDispatch(request, response); &#125; finally &#123; if (!WebAsyncUtils.getAsyncManager(request).isConcurrentHandlingStarted()) &#123; // Restore the original attribute snapshot, in case of an include. if (attributesSnapshot != null) &#123; restoreAttributesAfterInclude(request, attributesSnapshot); &#125; &#125; if (requestPath != null) &#123; ServletRequestPathUtils.clearParsedRequestPath(request); &#125; &#125;&#125; c&gt;doDispatch()所在类：org.springframework.web.servlet.DispatcherServlet 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293protected void doDispatch(HttpServletRequest request, HttpServletResponse response) throws Exception &#123; HttpServletRequest processedRequest = request; HandlerExecutionChain mappedHandler = null; boolean multipartRequestParsed = false; WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request); try &#123; ModelAndView mv = null; Exception dispatchException = null; try &#123; processedRequest = checkMultipart(request); multipartRequestParsed = (processedRequest != request); // Determine handler for the current request. /* mappedHandler：调用链 包含handler、interceptorList、interceptorIndex handler：浏览器发送的请求所匹配的控制器方法 interceptorList：处理控制器方法的所有拦截器集合 interceptorIndex：拦截器索引，控制拦截器afterCompletion()的执行 */ mappedHandler = getHandler(processedRequest); if (mappedHandler == null) &#123; noHandlerFound(processedRequest, response); return; &#125; // Determine handler adapter for the current request. // 通过控制器方法创建相应的处理器适配器，调用所对应的控制器方法 HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler()); // Process last-modified header, if supported by the handler. String method = request.getMethod(); boolean isGet = &quot;GET&quot;.equals(method); if (isGet || &quot;HEAD&quot;.equals(method)) &#123; long lastModified = ha.getLastModified(request, mappedHandler.getHandler()); if (new ServletWebRequest(request, response).checkNotModified(lastModified) &amp;&amp; isGet) &#123; return; &#125; &#125; // 调用拦截器的preHandle() if (!mappedHandler.applyPreHandle(processedRequest, response)) &#123; return; &#125; // Actually invoke the handler. // 由处理器适配器调用具体的控制器方法，最终获得ModelAndView对象 mv = ha.handle(processedRequest, response, mappedHandler.getHandler()); if (asyncManager.isConcurrentHandlingStarted()) &#123; return; &#125; applyDefaultViewName(processedRequest, mv); // 调用拦截器的postHandle() mappedHandler.applyPostHandle(processedRequest, response, mv); &#125; catch (Exception ex) &#123; dispatchException = ex; &#125; catch (Throwable err) &#123; // As of 4.3, we&#x27;re processing Errors thrown from handler methods as well, // making them available for @ExceptionHandler methods and other scenarios. dispatchException = new NestedServletException(&quot;Handler dispatch failed&quot;, err); &#125; // 后续处理：处理模型数据和渲染视图 processDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException); &#125; catch (Exception ex) &#123; triggerAfterCompletion(processedRequest, response, mappedHandler, ex); &#125; catch (Throwable err) &#123; triggerAfterCompletion(processedRequest, response, mappedHandler, new NestedServletException(&quot;Handler processing failed&quot;, err)); &#125; finally &#123; if (asyncManager.isConcurrentHandlingStarted()) &#123; // Instead of postHandle and afterCompletion if (mappedHandler != null) &#123; mappedHandler.applyAfterConcurrentHandlingStarted(processedRequest, response); &#125; &#125; else &#123; // Clean up any resources used by a multipart request. if (multipartRequestParsed) &#123; cleanupMultipart(processedRequest); &#125; &#125; &#125;&#125; d&gt;processDispatchResult()12345678910111213141516171819202122232425262728293031323334353637383940414243private void processDispatchResult(HttpServletRequest request, HttpServletResponse response, @Nullable HandlerExecutionChain mappedHandler, @Nullable ModelAndView mv, @Nullable Exception exception) throws Exception &#123; boolean errorView = false; if (exception != null) &#123; if (exception instanceof ModelAndViewDefiningException) &#123; logger.debug(&quot;ModelAndViewDefiningException encountered&quot;, exception); mv = ((ModelAndViewDefiningException) exception).getModelAndView(); &#125; else &#123; Object handler = (mappedHandler != null ? mappedHandler.getHandler() : null); mv = processHandlerException(request, response, handler, exception); errorView = (mv != null); &#125; &#125; // Did the handler return a view to render? if (mv != null &amp;&amp; !mv.wasCleared()) &#123; // 处理模型数据和渲染视图 render(mv, request, response); if (errorView) &#123; WebUtils.clearErrorRequestAttributes(request); &#125; &#125; else &#123; if (logger.isTraceEnabled()) &#123; logger.trace(&quot;No view rendering, null ModelAndView returned.&quot;); &#125; &#125; if (WebAsyncUtils.getAsyncManager(request).isConcurrentHandlingStarted()) &#123; // Concurrent handling started during a forward return; &#125; if (mappedHandler != null) &#123; // Exception (if any) is already handled.. // 调用拦截器的afterCompletion() mappedHandler.triggerAfterCompletion(request, response, null); &#125;&#125; 4、SpringMVC的执行流程 用户向服务器发送请求，请求被SpringMVC 前端控制器 DispatcherServlet捕获。 DispatcherServlet对请求URL进行解析，得到请求资源标识符（URI），判断请求URI对应的映射： a) 不存在 i. 再判断是否配置了mvc:default-servlet-handler ii. 如果没配置，则控制台报映射查找不到，客户端展示404错误 iii. 如果有配置，则访问目标资源（一般为静态资源，如：JS,CSS,HTML），找不到客户端也会展示404错误 b) 存在则执行下面的流程 根据该URI，调用HandlerMapping获得该Handler配置的所有相关的对象（包括Handler对象以及Handler对象对应的拦截器），最后以HandlerExecutionChain执行链对象的形式返回。 DispatcherServlet 根据获得的Handler，选择一个合适的HandlerAdapter。 如果成功获得HandlerAdapter，此时将开始执行拦截器的preHandler(…)方法【正向】 提取Request中的模型数据，填充Handler入参，开始执行Handler（Controller)方法，处理请求。在填充Handler的入参过程中，根据你的配置，Spring将帮你做一些额外的工作： a) HttpMessageConveter： 将请求消息（如Json、xml等数据）转换成一个对象，将对象转换为指定的响应信息 b) 数据转换：对请求消息进行数据转换。如String转换成Integer、Double等 c) 数据格式化：对请求消息进行数据格式化。 如将字符串转换成格式化数字或格式化日期等 d) 数据验证： 验证数据的有效性（长度、格式等），验证结果存储到BindingResult或Error中 Handler执行完成后，向DispatcherServlet 返回一个ModelAndView对象。 此时将开始执行拦截器的postHandle(…)方法【逆向】。 根据返回的ModelAndView（此时会判断是否存在异常：如果存在异常，则执行HandlerExceptionResolver进行异常处理）选择一个适合的ViewResolver进行视图解析，根据Model和View，来渲染视图。 渲染视图完毕执行拦截器的afterCompletion(…)方法【逆向】。 将渲染结果返回给客户端。","categories":[{"name":"spring","slug":"spring","permalink":"http://110.42.136.235/categories/spring/"}],"tags":[{"name":"spring","slug":"spring","permalink":"http://110.42.136.235/tags/spring/"}]},{"title":"Spring5","slug":"Spring5","date":"2022-04-11T01:11:02.000Z","updated":"2022-05-05T14:31:16.228Z","comments":true,"path":"2022/04/11/Spring5/","link":"","permalink":"http://110.42.136.235/2022/04/11/Spring5/","excerpt":"","text":"IOC什么是IOC 控制反转，把对象创建和对象之间的调用过程，交给Spring进行管理 使用IOC的目的：降低耦合度 IOC 底层原理 xml解析，工厂模式，反射IOC过程 第一步 xml配置文件，配置创建的对象 &lt;bean id=&quot;user&quot; class=&quot;com.wht.User&quot;&gt;&lt;/bean&gt; 第二部 有service类和dao类，创建工厂类 public static UserDao getDao()&#123; String classValue = class属性值;//通过xml解析 Class class = Class.forNmae(classValue);//反射 return (UserDao)class.newInstance(); &#125; IOC(接口) IOC思想基于IOC容器完成，IOC容器底层就是对象工厂 Spring提供IOC容器实现的两种方式：（两个接口） BeanFactory：IOC容器基本实现，是Spring内部使用的接口，不提供开发人员使用，加载配置文件时不会创建对象，在获取对象时才去创建对象 ApplicationContext：BeanFactory接口的子接口，提供更多功能，开发人员使用，加载配置文件时就会把配置文件中的对象创建 第二种更好，因为在可以做到慢启动，快响应 IOC 操作 Bean管理 Bean管理是指两个操作 Spring创建对象 Spring注入属性 Bean 管理操作的两种方式 xml创建对象 默认执行无参构造函数 id属性：唯一标识 class属性：类全路径 xml 注入属性 1.使用set方法 2.使用有参构造 DI：IOC的一种方法，依赖注入，就是注入属性 第一种注入方式：使用set方法 第二种注入方式：使用有参构造 注入空值 &lt;constructor-arg name=&quot;bName&quot;&gt; &lt;null&gt;&lt;/null&gt; &lt;/constructor-arg&gt; 注入特殊字符 1.可以使用转义 2.使用CDATA &lt;constructor-arg name=&quot;bName&quot;&gt; &lt;value&gt; &lt;![CDATA[&lt;&lt;数据结构&gt;&gt;]]&gt; &lt;/value&gt; &lt;/constructor-arg&gt; 注入外部bean &lt;!-- 注入外部bean--&gt; &lt;property name=&quot;userDao&quot; ref=&quot;userDaoImpl&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean id=&quot;userDaoImpl&quot; class=&quot;com.wht.dao.UserDaoImpl&quot;&gt;&lt;/bean&gt; 注入内部bean(实现一对多的关系) 也叫级联赋值 比如一个员工属于一个部门，但一个部门有多个员工，可以在员工类内加上一个部门对象，通过给部门这个属性赋值来规定员工的部门，这时可以用Spring来实现这种关系 &lt;!--注入内部bean--&gt; &lt;bean id=&quot;Emp&quot; class=&quot;com.wht.pojo.Emp&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;wht&quot;&gt;&lt;/property&gt; &lt;property name=&quot;dept&quot; ref=&quot;Dept&quot;&gt;&lt;/property&gt;&lt;/bean&gt; &lt;bean id=&quot;Dept&quot; class=&quot;com.wht.pojo.Dept&quot;&gt; &lt;property name=&quot;dName&quot; value=&quot;安保部门&quot;&gt;&lt;/property&gt; &lt;/bean&gt; 注入数组类型的属性 &lt;property name=&quot;strings&quot;&gt; &lt;array&gt; &lt;value&gt;数组1&lt;/value&gt; &lt;value&gt;数组2&lt;/value&gt; &lt;/array&gt; &lt;/property&gt; 注入List集合类型属性 &lt;property name=&quot;list&quot;&gt; &lt;list&gt; &lt;value&gt;list1&lt;/value&gt; &lt;value&gt;list2&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; 注入Map集合类型的属性 &lt;property name=&quot;map&quot;&gt; &lt;map&gt; &lt;entry key=&quot;key1&quot; value=&quot;value1&quot;&gt;&lt;/entry&gt; &lt;entry key=&quot;key2&quot; value=&quot;value2&quot;&gt;&lt;/entry&gt; &lt;/map&gt; &lt;/property&gt; 注入Set集合类型的属性 &lt;property name=&quot;set&quot;&gt; &lt;set&gt; &lt;value&gt;set1&lt;/value&gt; &lt;value&gt;set2&lt;/value&gt; &lt;/set&gt; &lt;/property&gt; set类型： set集合不允许有重复的如果内容重复，就只存进去第一次的，后面的就存不进去 set类型集合没有索引 如果注入的list集合类型是对象，则把value标签换成ref标签即可 提取list集合类型属性注入 第一步 在xml中使用util 第二步 提取list集合 &lt;util:list id=&quot;booklist&quot;&gt; &lt;value&gt;list-1&lt;/value&gt; &lt;value&gt;list-2&lt;/value&gt; &lt;value&gt;list-3&lt;/value&gt; &lt;/util:list&gt; 第三步 注入list集合 &lt;bean id=&quot;book&quot; class=&quot;com.wht.pojo.Book&quot;&gt; &lt;property name=&quot;bAuthor&quot; value=&quot;author&quot;&gt;&lt;/property&gt; &lt;property name=&quot;bName&quot; value=&quot;book&quot;&gt;&lt;/property&gt; &lt;property name=&quot;booklist&quot; ref=&quot;booklist&quot;&gt;&lt;/property&gt; &lt;/bean&gt; IOC操作Bean管理（FactoryBean）Spring有两种bean，一种普通bean，另一种工厂bean（FactoryBean） 普通bean：在配置文件中定义的bean类型就是返回类型 工厂bean：在配置文件定义bean类型可以和返回值不一样 IOC操作Bean管理（bran作用域）在Spring中，默认情况下，bean时单实例对象，也就是多次创建都是同一个对象 可以设置成多实例 使用scope设置 scope属性值 第一个值 singleton 单实例 第二个值 prototype 多实例 区别 单实例在加载配置文件时完成对象创建 不是在加载Spring对象时调用，而是在调用时才创建，每次创建的都是不同的对象 scope还有不常用的属性request和session IOC操作Bean管理(bean生命周期) bean生命周期 1.通过构造器创建bean实例（默认无参构造） 2.为bean的属性设置值和对其他bean引用（调用set方法） 3.调用bean初始化的方法（需要进行配置） 4.bean可以使用 5.当容器关闭时，调用bean销毁方法（需要配置销毁的方法） 配置bean初始化的方法 init-method 手动销毁bean context.close() 会自动强转 配置bean销毁的方法 destory-method bean后置处理器 配置后置处理器后，会在第三步，调用bean初始化之前和调用bean初始化之后分别执行 把bean实例传递给后置处理器的方法 把bean实例传递给后置处理器后的方法 bean配置后置处理器的方法 在对应的对象类中实现BeanPostProducer接口并实现其两个方法 @Override public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException &#123; System.out.println(&quot;1.bean传递给后置处理器&quot;); return bean; &#125; @Override public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException &#123; System.out.println(&quot;2.bean传递给后置处理器&quot;); return bean; &#125; IOC操作Bean管理（xml自动装配） byName自动装配 &lt;bean id=&quot;emp&quot; class=&quot;com.wht.autowire.Emp&quot; autowire=&quot;byName&quot;&gt;&lt;/bean&gt; 123&lt;bean id=&quot;dept&quot; class=&quot;com.wht.autowire.Dept&quot;&gt; &lt;property name=&quot;dName&quot; value=&quot;划水部门&quot;&gt;&lt;/property&gt;&lt;/bean&gt; 通过name属性自动装配，其中要装配的对象（划水部门）的name必须和bean内对应的属性name一致才可以 根据属性内容装配byType IOC操作Bean管理（引入外部属性文件） 普通连接方式 &lt;bean id=&quot;dataSource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot;&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.jdbc.Driver&quot;&gt;&lt;/property&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/users&quot;&gt;&lt;/property&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot;&gt;&lt;/property&gt; &lt;property name=&quot;password&quot; value=&quot;password&quot;&gt;&lt;/property&gt; &lt;/bean&gt; 使用外部属性文件进行连接的方式 第一步：在src下创建properties文件 第二步:在properties文件中写入信息 prop.driverClass=com.mysql.jdbc.Driver prop.url=jdbc:mysql://localhost:3306/users prop.username=root prop.password=password 第三步：在xml文件中引入context第四步：引入外部属性文件 &lt;!--引入外部属性文件--&gt; &lt;context:property-placeholder location=&quot;jdbc.properties&quot;&gt;&lt;/context:property-placeholder&gt; &lt;bean id=&quot;dataSource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot;&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;$&#123;prop.driverClass&#125;&quot;&gt;&lt;/property&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql:$&#123;prop.url&#125;&quot;&gt;&lt;/property&gt; &lt;property name=&quot;username&quot; value=&quot;$&#123;prop.username&#125;&quot;&gt;&lt;/property&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;prop.password&#125;&quot;&gt;&lt;/property&gt; &lt;/bean&gt; IOC操作Bean管理(基于注解方式)Spring针对Bean管理中创建对象提供的注解 @Component @Service @Controller @Repository 四个注解的功能都是一样的，都可以创建bean实例 基于注解方式实现对象创建第一步：引入依赖 第二步：开启组件扫描 &lt;context:component-scan base-package=&quot;com.wht&quot;&gt;&lt;/context:component-scan&gt; 第三步：开始使用注解创建对象 在xml中可以配置哪些扫描哪些不扫描 注解方式注入属性 @AutoWired 根据属性类型进行输入 @Qualifier 根据属性名称注入 @Resource 可以根据类型注入，也可以根据名称注入 使用Qualifier必须和AutoWired一起使用，在一个接口有多个实现类的时候可以进行使用 //使用注解进行注入不需要设置set方法 @Autowired //根据类型进行注入 @Qualifier(value = &quot;userDaoImpl&quot;)//如果一个接口有多个实现类，需要用名称 private UserDao userDao; 使用Resource注入 @Resource//根据类型 @Resource(name = &quot;userDaoImpl&quot;)//根据名称 使用Value注入 @Value(value = &quot;test1&quot;) private String test; 完全注解开发首先创建一个config类，在类中加入如下注解 @Configuration//替代配置文件 @ComponentScan(basePackages = &quot;com.wht&quot;) 然后在测试类中把加载配置文件换成加载配置类 ApplicationContext context = new AnnotationConfigApplicationContext(SpringConfig.class); AOP什么是AOPAOP是面向切面（方面）编程的缩写降低业务逻辑的耦合度，提高程序的可重用性，同时提高开发的效率 通俗理解：不通过修改源代码来增加一些新的功能 AOP底层原理 AOP底层使用动态代理 有两种情况 第一种：有接口 使用JDK动态代理，创建接口的代理对象，来增加一些新的功能 第二种：没有接口 CGLIB动态代理，创建子类的代理对象，增强类中的方法 AOP术语 连接点 类里面哪些方法可以被增强，这些方法称为连接点 切入点 实际真正增强的方法称为切入点 通知（增强） 实际增强的逻辑部分就叫通知 通知有多种类型 前置 后置 环绕 异常 最终 切面 是一个动作，把通知应用到切入点的过程就叫切面 AOP操作 Spring框架一般基于AspectJ实现AOP操作 AspectJ本身是一个单独的框架，一般把AspectJ和Spring框架一起使用，进行AOP操作 基于AspectJ实现AOP操作 基于xml配置文件实现 基于注解方式实现（使用较多） 第一步 导入依赖 &lt;!-- Aop相关依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aspects&lt;/artifactId&gt; &lt;version&gt;5.2.6.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.9.3&lt;/version&gt; &lt;--注意版本问题--&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;aopalliance&lt;/groupId&gt; &lt;artifactId&gt;aopalliance&lt;/artifactId&gt; &lt;version&gt;1.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;net.sourceforge.cglib&lt;/groupId&gt; &lt;artifactId&gt;com.springsource.net.sf.cglib&lt;/artifactId&gt; &lt;version&gt;2.2.0&lt;/version&gt; &lt;/dependency&gt; 切入点表达式语法结构 execution([权限修饰符][返回类型][类全路径][方法名称][参数列表]) 例如 对Book类中的add方法进行修改 execution(* com.wht.dao.Book.add(..)) 对dao包里面所有类，类里面的所有方法进行增强 execution(* com.wht.dao..(..)) AOP操作（AspectJ注解）第一步：开启注解扫描和Aspect &lt;!--开启注解扫描--&gt; &lt;context:component-scan base-package=&quot;com.wht&quot;&gt;&lt;/context:component-scan&gt; &lt;!-- 开启Aspect生成代理对象--&gt; &lt;aop:aspectj-autoproxy&gt;&lt;/aop:aspectj-autoproxy&gt; 第二部：在增强类和被增强类中分别加入注解其他通知 //前置通知 @Before(value = &quot;execution(* com.wht.pojo.User.add(..))&quot;) public void before()&#123; System.out.println(&quot;before...&quot;); &#125; //最终通知 @After(value = &quot;execution(* com.wht.pojo.User.add(..))&quot;) public void after()&#123; System.out.println(&quot;after...&quot;); &#125; //异常通知，当有异常时执行 @AfterThrowing(value = &quot;execution(* com.wht.pojo.User.add(..))&quot;) public void afterThrowing()&#123; System.out.println(&quot;afterThrowing...&quot;); &#125; //后置通知 @AfterReturning(value = &quot;execution(* com.wht.pojo.User.add(..))&quot;) public void afterReturning()&#123; System.out.println(&quot;afterReturning...&quot;); &#125; //环绕通知，在被增强方法之前和之后执行 @Around(value = &quot;execution(* com.wht.pojo.User.add(..))&quot;) public void around(ProceedingJoinPoint proceedingJoinPoint) throws Throwable &#123; System.out.println(&quot;around before&quot;); proceedingJoinPoint.proceed(); System.out.println(&quot;around after&quot;); &#125; after是最终通知，不管有没有异常都会执行 AfterThrowing是异常通知，当有异常时执行 当有异常是，环绕通知和后置通知(afterReturn)都不会执行 相同切入点抽取因为每个通知后面的切入点都是一样的，所以可以进行相同切入点抽取 @Pointcut(value = “execution(* com.wht.pojo.User.add(..))”) public void pointcut(){ //相同切入点抽取 } //前置通知 @Before(value = “pointcut()”) public void before(){ System.out.println(&quot;before...&quot;); } 多个增强类对同一个方法进行增强当多个增强类对同一个方法进行增强时，可以设置增强类优先级 //增强的类 @Component @Aspect //生成代理对象 @Order(1)//设置优先级，值越小，越优先执行 AOP操作（AspectJ配置文件）&lt;!-- 创建对象--&gt; &lt;bean id=&quot;user&quot; class=&quot;com.wht.pojo.User&quot;&gt;&lt;/bean&gt; &lt;bean id=&quot;userProxy&quot; class=&quot;com.wht.aopxml.UserProxy&quot;&gt;&lt;/bean&gt; &lt;aop:config&gt; &lt;!-- 切入点--&gt; &lt;aop:pointcut id=&quot;p&quot; expression=&quot;execution(* com.wht.pojo.User.add(..))&quot;/&gt; &lt;!--配置切面--&gt; &lt;aop:aspect ref=&quot;userProxy&quot;&gt; &lt;aop:before method=&quot;before&quot; pointcut-ref=&quot;p&quot;&gt;&lt;/aop:before&gt; &lt;/aop:aspect&gt; &lt;/aop:config&gt; AOP全注解开发创建一个配置类，不需要xml文件 @Configuration//配置类 @ComponentScan(basePackages = &quot;com.wht&quot;)//开启注解扫描 @EnableAspectJAutoProxy(proxyTargetClass = true)//开启Aspect生成代理对象 public class ConfigAop &#123; &#125; JdbcTemplate什么是JdbcTemplateSpring框架对JDBC进行了封装，使用JdbcTemplate对数据库进行操作 JdbcTemple操作数据库第一步 ： 配置xml文件 &lt;!--开启注解扫描--&gt; &lt;context:component-scan base-package=&quot;com.wht&quot;&gt;&lt;/context:component-scan&gt; &lt;!--引入外部属性文件--&gt; &lt;context:property-placeholder location=&quot;jdbc.properties&quot;&gt;&lt;/context:property-placeholder&gt; &lt;!--数据库连接池--&gt; &lt;bean id=&quot;dataSource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot;&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;$&#123;prop.driverClass&#125;&quot;&gt;&lt;/property&gt; &lt;property name=&quot;url&quot; value=&quot;$&#123;prop.url&#125;&quot;&gt;&lt;/property&gt; &lt;property name=&quot;username&quot; value=&quot;$&#123;prop.username&#125;&quot;&gt;&lt;/property&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;prop.password&#125;&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- JdbcTemplate对象--&gt; &lt;bean id=&quot;jdbcTemplate&quot; class=&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&gt; &lt;!-- 注入dataSource--&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt; &lt;/bean&gt; 第二步： 添加注解 在userdao的实现方法中 @Repository public class UserDaoImpl implements UserDao&#123; //注入JdbcTemplate @Autowired private JdbcTemplate jdbcTemplate; @Override public void add(User user) &#123; String sql=&quot;insert into users values(?,?)&quot;; int update = jdbcTemplate.update(sql, user.getPassword(), user.getUsername()); System.out.println(update); &#125; &#125; 在UserService中 @Service(value = &quot;userService&quot;) public class UserService &#123; @Autowired private UserDao userDao; public void add(User user)&#123; userDao.add(user); &#125; &#125; 第三步：在Test类中调用 事务什么是事务事务时数据库操作的最基本单元，逻辑上的一组操作，要么都成功，要么都失败 事务的四个特性 原子性（不可分割） 一致性 隔离性 持久性 //事务操作 public void account() &#123; try &#123; //开启事务 //没有出现异常,提交事务 &#125; catch (Exception e) &#123; //出现异常,事务回滚 &#125; &#125;//account 事务操作（Spring事务管理介绍） 事务一般添加在JavaEE三层结构里面的Service层(业务逻辑层) 在Spring中进行事务操作有两种方式 编程式 声明式（使用较多） 在Spring中进行声明式事务管理，底层使用AOP原理 Spring事务管理APISpring提供一个接口，代表事务管理器，这个接口针对不同框架提供不同的实现类 在Spring配置文件配置事务管理器第一步：配置事务管理器 &lt;!-- 配置事务管理器--&gt; &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt; 第二步：注入数据源，并开启事务管理 &lt;!-- 注入数据源--&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 开启事务管理--&gt; &lt;tx:annotation-driven transaction-manager=&quot;transactionManager&quot;&gt;&lt;/tx:annotation-driven&gt; 第三步：添加注解 @Transactional，这个注解可以添加到类上面，也可以添加到方法上面 注解添加到类上面，这个类里面的所有方法都添加了事务 注解添加到方法上，为这个方法添加事务Transactional中配置事务相关参数 propagation：事务传播行为 默认 @Transactional(propagation = Propagation.REQUIRED)也就是在其他方法中如果没有事务，会自动添加事务 ioslation：事务隔离级别 事务有隔离性的特性，多事务操作之间不会产生影响，不考虑隔离性产生很多问题 有三个问题：脏读，不可重复读，虚读（幻读） 脏读：一个未提交事务读取到另一个未提交事务的数据 不可重复读：一个未提交事务读取到另一个已经提交的事务的数据（是一种现象而不是一个问题） 虚读： 一个未提交事务读取到另一提交事务添加数据 timeout：超时时间 事务需要在一定时间内提交，否则回滚 timeout默认是-1，可以设置以秒为单位 readOnly：是否只读 默认值是false，可以查询也可以添加修改删除操作 rollBackFor：回滚 设置出现哪些异常进行事务回滚 noRollbackFor：不回滚 设置出现哪些异常不进行回滚 事务操作（XML声明式事务管理）第一步：配置事务管理器 第二步：配置通知 第三步：配置切入点和切面 &lt;!-- 1. 配置事务管理器--&gt; &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt; &lt;!-- 注入数据源--&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!--2.配置通知--&gt; &lt;tx:advice id=&quot;txadvice&quot;&gt; &lt;tx:attributes&gt; &lt;!-- 指定那种规则的方法上面添加事务--&gt; &lt;tx:method name=&quot;accountMoney&quot; propagation=&quot;REQUIRED&quot;/&gt;&lt;!--指定accountMoney方法--&gt; &lt;tx:method name=&quot;account*&quot;/&gt; &lt;!--指定以account开头的方法--&gt; &lt;/tx:attributes&gt; &lt;/tx:advice&gt; &lt;!-- 3.配置切入点和切入面--&gt; &lt;aop:config&gt; &lt;!-- 配置切入点--&gt; &lt;aop:pointcut id=&quot;pt&quot; expression=&quot;execution(* com.wht.service.UserService.add(..))&quot;/&gt; &lt;!-- 配置切面--&gt; &lt;aop:advisor advice-ref=&quot;txadvice&quot; pointcut-ref=&quot;pt&quot;/&gt; &lt;/aop:config&gt; 事务操作（完全注解声明式事务管理）第一步：创建配置类 @Configuration//配置类 @ComponentScan(basePackages = &quot;com.wht&quot;)//组件扫描 @EnableTransactionManagement//开启事务 public class TxConfig &#123; //创建数据库连接池 @Bean public DruidDataSource getDruidDataSource()&#123; DruidDataSource dataSource = new DruidDataSource(); dataSource.setDriverClassName(&quot;com.mysql.jdbc.Driver&quot;); dataSource.setUrl(&quot;jdbc:mysql://localhost:3306/student&quot;); dataSource.setUsername(&quot;root&quot;); dataSource.setPassword(&quot;password&quot;); return dataSource; &#125; //创建JdbcTemplate对象 @Bean public JdbcTemplate jdbcTemplate(DataSource dataSource)&#123; JdbcTemplate jdbcTemplate = new JdbcTemplate(); //注入datasource jdbcTemplate.setDataSource(dataSource); return jdbcTemplate; &#125; //创建事务管理器 @Bean public DataSourceTransactionManager dataSourceTransactionManager(DataSource dataSource)&#123; DataSourceTransactionManager dataSourceTransactionManager = new DataSourceTransactionManager(); dataSourceTransactionManager.setDataSource(dataSource); return dataSourceTransactionManager; &#125; &#125; Spring 5新特性 基于jdk8 日志 新增@nullable注解，可以使方法返回值为空，也可以使用在方法参数中和属性值中 函数式风格Lambda表达式 SpringWebflux介绍2022/4/13","categories":[{"name":"spring","slug":"spring","permalink":"http://110.42.136.235/categories/spring/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://110.42.136.235/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"JavaWeb","slug":"JavaWeb","date":"2022-04-07T09:45:16.000Z","updated":"2022-04-08T09:15:07.980Z","comments":true,"path":"2022/04/07/JavaWeb/","link":"","permalink":"http://110.42.136.235/2022/04/07/JavaWeb/","excerpt":"","text":"JavaWeb TomCat服务器 Tomcat 服务器是一个免费的开放源代码的Web应用服务器，属于轻量级应用服务器，在中小型系统和并发访问用户不是很多的场合下被普遍使用，是开发和调试JSP程序的首选 Http (超文本传输协议）是一个简单的请求-响应协议，它通常运行在TCP之上。 HTTP 的请求 get：请求能够携带的参数比较少，大小有限制，会在浏览器的URL地址栏显示数据内容，不安全，但高效 post:请求能够携带的参数没有限制，大小没有限制，不会在浏览器的URL地址栏显示数据内容，安全，但不高效 HTTP 的请求报文结构： 请求行：由请求方法（Method）、URL 字段和 HTTP 的协议版本组成，注意其中的空格、回车符和换行符均不可省略，所以我们的请求方法实际上就是位于请求行中的了。 请求头部：位于请求行之后，个数可以为 0~若干个，每个请求头部都包含一个头部字段名和一个值，它们之间用冒号 “:” 分隔，在最后用回车符和换行符表示结束。 请求数据：如果请求方法为 GET，那么请求数据为空。它主要是在 POST 中进行使用，适用于需要填表单（FORM）的场景。 请求方法：Get,Post,HEAD,DELETE,PUT,TRACT.…","categories":[],"tags":[]},{"title":"JDBC java数据库连接","slug":"JDBC","date":"2022-03-25T02:24:25.000Z","updated":"2022-03-25T11:56:44.436Z","comments":true,"path":"2022/03/25/JDBC/","link":"","permalink":"http://110.42.136.235/2022/03/25/JDBC/","excerpt":"","text":"下载安装驱动MYSQL驱动jar包下载 将jar包导入idea在项目下创建新文件夹，将jar包复制进去，右键jar包，选择add as library 开始操作数据库public static void main(String[] args) throws Exception &#123; //注册驱动 Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;); //获取连接,依次输入ip,端口号和连接的数据库名称 String url=&quot;jdbc:mysql://127.0.0.1:3306/student&quot;; String username=&quot;root&quot;; String password=&quot;password&quot;; Connection conn=DriverManager.getConnection(url,username,password); //定义sql String sql=&quot;UPDATE stu set math=88 WHERE stuname=\\&quot;王洪涛\\&quot;&quot;; //获取执行sql对象的statement Statement stmt = conn.createStatement(); //执行sql int count = stmt.executeUpdate(sql);//受影响的行数 //处理结果 System.out.println(count); //关闭资源 stmt.close(); conn.close(); &#125; JDBC APIDriverManager获取数据库连接 .getConnection(url,username,password) Connection1.获取执行SQL的对象 conn.createStatement(); 2.管理事务 try &#123; //开启事务 conn.setAutoCommit(false); //执行完毕，提交事务 conn.commit(); &#125;catch (SQLException throwables) &#123; //如果出现异常,回滚事务 conn.rollback(); throwables.printStackTrace(); &#125; statement 执行sql语句执行sql语句 .executeUpdate(sql);//更新数据库 .executeQuery(sql1);//查询数据库 ResultSetresultset可以对查询结果进行操作，比如获取查询结果中的各种字段 Statement stmt = conn.createStatement(); //执行sql ResultSet rs = stmt.executeQuery(sql1); re.getInt(列数);//获取相应列的int类型数据 re.getString(列数);//获取string类型的数据 PreparedStatement","categories":[],"tags":[]},{"title":"css学习日记","slug":"css学习日记","date":"2022-03-21T11:33:08.000Z","updated":"2022-03-23T08:48:25.429Z","comments":true,"path":"2022/03/21/css学习日记/","link":"","permalink":"http://110.42.136.235/2022/03/21/css%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/","excerpt":"","text":"css简介css是层叠样式表（cascading style sheets） css是用来美化网页页面的 css语法规范css由两大块组成，分别是选择器和样式 style的位置应该在head里 &lt;head&gt; &lt;style&gt; p &#123; &lt;!-- 修改文字为红色 --&gt; color: red &lt;!-- 修改字体大小 --&gt; font-size: 12px &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt;颜色&lt;/p&gt; &lt;/body&gt; css代码风格 样式格式展开式 p &#123; &lt;!-- 修改文字为红色 --&gt; color: red &lt;!-- 修改字体大小 --&gt; font-size: 12px &#125; 样式大小写：一般用小写 空格规范属性值前面和冒号后面，保留一个空格，选择器和大括号中间保留空格 css基础选择器css选择器分类 基础选择器、复合选择器 基础选择器分为：标签选择器、类选择器、id选择器、通配符选择器 标签选择器以html的标签名作为选择器，按照标签名分类，为页面中同一类别的标签统一css格式 例如：将p标签改为绿色，div标签改为红色 &lt;style&gt; p &#123; color: green; &#125; div &#123; color: red; &#125; &lt;/style&gt; 类选择器可以差异化选择不同的标签，单独选一个或者某几个标签 例如，将所有拥有red类的html元素均为红色 .red &#123; color: red; &#125; 在html中给某个标签添加class属性即可 &lt;li class=&quot;red&quot;&gt; 红色&lt;/li&gt; 类选择器-多类名标签可以选择多个类名，中间必须用空格隔开 &lt;div class=&quot;lei1 lei2&quot;&gt; &lt;/div&gt; id选择器定义格式 #idname &#123; color: red; &#125; 调用格式 &lt;li id=&quot;idname&quot;&gt;&lt;/li&gt; id选择器与类选择器的区别：id选择器定义方式不同，且只能调用一次 通配符选择器在css中，通配符选择器表示选取页面中所有标签 *&#123; 属性值1：属性值1； ... &#125; 通配符选择器不需要调用，会自动调用 css复合选择器后代选择器后代选择器用于选取某元素的后代元素。 div p &#123; background-color:yellow; &#125; 子元素选择器与后代选择器相比，子元素选择器（Child selectors）只能选择作为某元素直接/一级子元素的元素 div&gt;p &#123; background-color:yellow; &#125; 相邻兄弟选择器选取了所有位于 div 元素后的第一个 p 元素 div+p &#123; background-color:yellow; &#125; 后续兄弟选择器后续兄弟选择器选取所有指定元素之后的相邻兄弟元素 div~p &#123; background-color:yellow; &#125; css字体属性字体系列&lt;style&gt; P &#123; font-family: &#39;宋体&#39;,Times,serif &#125; &lt;/style&gt; 当有多个字体时，系统会默认使用第一种，如果第一种不可用在用后面的字体 字体大小 p &#123; font-size: 20px &#125; 字体粗细 p &#123; font-weight: bold 或 700 &#125; 文字样式文字斜体 P &#123; font-style: italic &#125; 文字不倾斜 p &#123; font-style: normal &#125; 文字复合属性 font-style font-weight font-size font-family 顺序不可颠倒 p &#123; font: italic 700 16px &#39;Microsoft yahei&#39; &#125; css文本属性文本颜色颜色&lt;style&gt; div &#123; &lt;!-- color: pink --&gt; &lt;!-- color: #ff0000 --&gt; &lt;!-- color: rgb(255,0,0) --&gt; &#125; &lt;/style&gt; 对齐文本div &#123; text-align: center; right left &#125; 装饰文本div &#123; text-decoration: underline;//下划线 text-decoration: line-through;//删除线 text-decoration: none;//默认没有装饰线（用的最多） &#125; 文本缩进p &#123; text-indent: 20px //文本首行缩进 text-indent: 2em //常用单位，1em就是缩进一个文字大小 &#125; 行间距p &#123; text-height: 26px;//是包括文字和上下间距 &#125; css引入方式内部样式表css写在html内部，放在style标签内部 一般用于控制整个html页面 行内样式表直接在标签内部修改样式 &lt;p style=&quot;color:red&quot;&gt; 红色&lt;/p&gt; 红色 一般不推荐使用 外部样式表单独写一个css文件，引入到html中 引入方式: &lt;link rel=&quot;stylesheet&quot; href=&quot;01.css&quot;&gt;//快捷键:link+tab css盒子 div &#123; width: 300px; border: 25px solid green; padding: 25px; margin: 25px; &#125; border-style :none: 默认无边框 dotted: 定义一个点线边框 dashed: 定义一个虚线边框 solid: 定义实线边框 double: 定义两个边框。 两个边框的宽度和 border-width 的值相同 groove: 定义3D沟槽边框。效果取决于边框的颜色值 ridge: 定义3D脊边框。效果取决于边框的颜色值 inset:定义一个3D的嵌入边框。效果取决于边框的颜色值 outset: 定义一个3D突出边框。 效果取决于边框的颜色值 p.none{ border-style:none; } p.dotted{ border-style:dotted; } p.dashed{ border-style:dashed; } p.ridge{ border-style: ridge; } p.ridge2{ border-style: ridge; border-color:red; border-width:5px } p.ridge3{ border-style: ridge; border-color:red; border-width:5px; outline-style: ridge; outline-color:green } css边框-border none dotted dashed ridge 指定边框宽度和边框颜色 p.ridge2&#123; border-style: ridge; border-color:red;//必须在style后面 border-width:5px &#125; ridge2 css轮廓-outline指定轮廓样式和颜色 p.ridge3&#123; border-style: ridge; border-color:red; border-width:5px; outline-style: ridge; outline-color:green &#125; ridge3 外边距-margin 填充-padding css可视指定h1不可见，但依然占有空间 h1.hidden &#123; visibility:hidden; &#125; css定位static relative fixed absolute sticky css伪类a:link &#123;color:#FF0000;&#125; /* 未访问的链接 */ a:visited &#123;color:#00FF00;&#125; /* 已访问的链接 */ a:hover &#123;color:#FF00FF;&#125; /* 鼠标划过链接 */ a:active &#123;color:#0000FF;&#125; /* 已选中的链接 */ css伪元素p:first-letter &#123; color:#ff0000; font-size:xx-large; &#125; first-letter表示首字母 first-line表示首行 css before元素h1:before &#123; content:url(smiley.gif); &#125; css导航栏&lt;ul&gt; &lt;li&gt;&lt;a href=&quot;#home&quot;&gt;主页&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#news&quot;&gt;新闻&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#contact&quot;&gt;联系&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#about&quot;&gt;关于&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; 主页 新闻 联系 关于 加入修饰 &lt;style&gt; .daohang &#123; list-style-type:none;//去掉小黑点 margin:0;//边距设为0 padding:0;//填充设为0 &#125; &lt;/style&gt; .daohang { border:1px solid #555; list-style-type:none; margin:0; padding:0; background-color:#f1f1f1; height:50%; /* position:fixed; */ overflow:auto } .daohang li { border-bottom:1px solid #555; } .daohang li:last-child{ border-bottom: none; } .daohang a{ text-align:center; display:block; color: #000; padding:8px 16px; text-decoration:none; } .daohang a:hover:not(.active) { background-color: #555; color: white; } ul a.active { background-color: #4CAF50; color: white; } 主页 新闻 联系 关于 css图片廊&lt;style&gt; div.img &#123; margin: 5px; border: 5px solid #ccc; float: center; width: 180px; &#125; div.img:hover &#123; border: 1px solid #777; &#125; div.desc &#123; padding: 15px; text-align: auto; &#125; &lt;/style&gt; &lt;div&gt; &lt;div class=&quot;img&quot;&gt; &lt;a target=&quot;_blank&quot; href=&quot;https://static.runoob.com/images/demo/demo1.jpg&quot;&gt; &lt;img src=&quot;https://static.runoob.com/images/demo/demo1.jpg&quot; alt=&quot;图片描述&quot;&gt; &lt;/a&gt; &lt;div class=&quot;desc&quot;&gt; 图文描述 &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; div.img { margin: 5px; border: 5px solid #ccc; float: center; width: 180px; } div.img:hover { border: 1px solid #777; } div.desc { padding: 15px; text-align: auto; } 图文描述","categories":[],"tags":[]},{"title":"java学习日记","slug":"java学习日记","date":"2022-03-20T10:37:02.000Z","updated":"2022-04-08T13:30:48.272Z","comments":true,"path":"2022/03/20/java学习日记/","link":"","permalink":"http://110.42.136.235/2022/03/20/java%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/","excerpt":"","text":"java学习路线： java基础：韩顺平 尚硅谷：spring5=》springMVC=》springboot git linux java基本知识 Class（类）是java中最小单元，java所有内容都是放在类中的 每一个.java文件都是由类组成 一个java文件可以有多个class(不提倡),但只能有一个public class public class的名字必须和文件名字一样，大小写都要完全一致 main函数的基本格式PSVM public static void main(String[] args) 自定义函数调用方法 public class hello &#123; public static void main(String[] args)&#123; System.out.println(&quot;hello&quot;); hello.in(); &#125; public static void in()&#123;//自定义函数在调用时才会执行 System.out.println(&quot;in函数&quot;); &#125; &#125; java 进阶 junit单元测试 @Test public void testAdd()&#123; int a=1; int b=2; int c=a+b; assert.assertEquals(3,c);//断言 &#125; 在所有方法执行前都会自动执行 @Before 在所有方法结束后都会执行 @After 反射反射：将类的各个部分封装为其他对象，这就是反射机制 .java文件被编译成字节码文件.class是类加载器会把成员变量封装进Filed ，构造方法会被封装进Constructor中，成员方法也会被封装进Method 好处 可以在程序运行过程中操作这些对象 可以解耦，提高程序的可扩展性 获取class对象的方式： class.forName(“全类名”)：将字节码文件加载进内存，返回class对象 多用于配置文件 类名.class:通过类名的属性class获取 多用于参数传递 对象.getClass() getClass()方法在Object类中定义着 多用于对象的获取字节码的方式","categories":[],"tags":[]},{"title":"hexo搭建个人博客","slug":"hexo搭建个人博客","date":"2022-03-20T02:54:07.000Z","updated":"2022-05-01T09:22:09.701Z","comments":true,"path":"2022/03/20/hexo搭建个人博客/","link":"","permalink":"http://110.42.136.235/2022/03/20/hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/","excerpt":"","text":"安装Nodejs安装 查看node版本node -v 查看npm版本npm -v 安装淘宝的cnpm 管理器npm install -g cnpm –registry=http://registry.npm.taobao.org 查看cnpm版本cnpm -v 安装hexo框架cnpm install -g hexo-cli 查看hexo版本hexo -v 创建blog目录mkdir blog 进入blog目录cd blog 生成博客 初始化博客sudo hexo init 启动本地博客服务hexo s 本地访问地址http://localhost:4000/ 创建新的文章hexo n “我的第一篇文章” 清理hexo clean 生成hexo g Github创建一个新的仓库 YourGithubName.github.io在blog目录下安装git部署插件ocnpm install –save hexo-deployer-git 配置_config.ymlDeploymentDocs: https://hexo.io/docs/deployment.html deploy: type: git repo: https://github.com/YourGithubName/YourGithubName.github.io.git branch: master 部署到Github仓库里hexo d 访问这个地址可以查看博客https://YourGithubName.github.io/ 下载yilia主题到本地 git clone https://github.com/litten/hexo-theme-yilia.git themes/yilia 修改hexo根目录下的 _config.yml 文件 theme: yilia 清理一下hexo c 生成hexo g 部署到远程Github仓库hexo d 查看博客https://YourGithubName.github.io/","categories":[],"tags":[]},{"title":"HTML学习日记","slug":"HTML学习日记","date":"2022-03-19T01:12:51.000Z","updated":"2022-03-21T12:20:49.449Z","comments":true,"path":"2022/03/19/HTML学习日记/","link":"","permalink":"http://110.42.136.235/2022/03/19/HTML%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/","excerpt":"","text":"HTML简介HTML是超文本标记语言(Hyper Text Markup Language)，是用来描述网页的一种语言HTML不是编程语言，而是一种标记语言，标记语言是一套标记标签 Web标准Web标准的构成 标准 说明 结构 用于对网页元素进行整理和分类，主要是HTML 表现 用于设置网页元素的板式、颜色、大小等外观，主要是css 行为 指网页模型的定义及交互的编写，主要是JavaScript HTML语法规范基本语法 HTML一般成对出现,有单标签，但是很少标签关系 包含关系123&lt;head&gt;&lt; title&gt; &lt; /title&gt;&lt;/head&gt; 并列关系12&lt;head&gt; &lt;/head&gt;&lt;body&gt; &lt;/body&gt; HTML基本结构标签 标签名 定义 说明 &lt;html&gt;&lt;/html&gt; HTML标签 页面最大标签，也称根标签 &lt;head&gt;&lt;/head&gt; 文档的头部 在head中必须设置title标签 &lt;title&gt;&lt;/title&gt; 文档的标题 让页面有自己的标题 &lt;body&gt;&lt;/body&gt; 文档的主体 页面内容基本都是在body中 文档类型声明标签&lt;!DOCTYPE html&gt;意思是告诉浏览器使用了那种HTML版本来显示网页这个标签表示使用最新的HTML5显示页面 lang语言类型用来定义当前文档显示的语言，en为英语，zh-CN定义为中文网页不影响页面显示，只是对浏览器提示 字符集在&lt;head&gt;标签中，可以通过&lt;meta&gt;标签的charset属性来规定HTML文档应该使用哪种字符编码,例如&lt;meta charset=&quot;UTF-8&quot;&gt; HTML常用标签标题标签&lt;h1&gt;-&lt;h6&gt;&lt;h1&gt;是一级标签,以此类推特点： 加了标题的文字会变大变粗 每个标题都是独占一行 段落标签和换行标签在HTML中，多个空格或者多个回车并不会起作用，必须使用标签&lt;p&gt;&lt;/p&gt;是一个段落标签（paragraph的缩写）特点： 文本会根据浏览器窗口大小自动换行 段落和段落间会有空隙&lt;br /&gt;是一个换行标签（break的缩写）特点： 这是一个单标签 会另起一行但不会有上下间距 文本格式化标签设置文字粗体、斜体或下划线等效果 语义 标签 说明 加粗 &lt;strong&gt;&lt;/strong&gt;或&lt;b&gt;&lt;/b&gt; 推荐用&lt;strong&gt; 倾斜 &lt;em&gt;&lt;/em&gt;或&lt;i&gt;&lt;/i&gt; 推荐使用&lt;em&gt; 删除线 &lt;del&gt;&lt;/del&gt;或&lt;s&gt;&lt;/s&gt; 推荐&lt;del&gt; 下划线 &lt;ins&gt;&lt;/ins&gt;或&lt;u&gt;&lt;/u&gt; 推荐&lt;ins&gt;&lt;/ins&gt; &lt;div&gt;和&lt;span&gt;标签&lt;div&gt;和&lt;span&gt;是没有语义的，它们就是一个盒子，用来装内容的 特点： div是division的缩写(分割，分区),单独占一行，用作大盒子 span(跨度、跨距)，一行可以放好多个，用作小盒子 图像标签和路径图像标签在HTML标签中，&lt;img&gt;标签用于定义HTML页面中的图像&lt;img src=&quot;狐狸.jpg&quot;/&gt;图像标签的其他属性 属性 属性值 说明 src 图片路径 必须属性 alt 文本 替换文本，图像不能正常显示，用该文字替代 title 文本 提示文本，鼠标放到图像上的提示文字 width 像素 设置图像的宽度 height 像素 设置图像的高度 border 像素 设置图像的边框粗细 例如：&lt;img src=&quot;img.png&quot; title=&quot;图像&quot;/&gt;属性之间不分顺序 路径相对路径 相对路径分类 符号 说明 同一级路径 图像与html文件处于同一级如&lt;img src=&quot;1.png&quot;/&gt; 下一级路径 / 图像在HTML文件的下一级如&lt;img src=&quot;/img/1.png&quot;/&gt; 上一级路径 ../ 图像在html文件的上一级&lt;img src=&quot;../1.png/&gt; 绝对路径完整的路径或网络地址&quot;C:\\Users\\1.png&quot;或&quot;www.xxx.com&quot; 超链接标签 a是anchor（锚）的缩写，herf是网站地址，是必须属性，target是打开方式，可选”_blank”或”_self”,标签中间可以是文字或者图片 链接可以分为内部链接和外部链接 下载链接:herf地址是一个文件或压缩包，会下载这个文件 空链接：herf里是#即可 &lt;a href=&quot;https://home.firefoxchina.cn&quot; target=&quot;_blank&quot;&gt; 火狐&lt;/a&gt; 火狐 &lt;a href=&quot;http://www.qq.com&quot; target=&quot;_self&quot;&gt; 腾讯&lt;/a&gt; 腾讯 锚点链接1.在链接文本的href属性中，设置属性值为#名字的形式,如： &lt;a href=&quot;#two&quot;&gt; 第二季&lt;/a&gt; 2.在目标位置添加id属性 &lt;h3 id=&quot;two&quot;&gt; 第二季&lt;/a&gt; 注释和特殊字符&lt;!--注释文字--&gt; 快捷键ctrl + / 表格标签 &lt;table&gt;&lt;/table&gt;是定义表格的标签 &lt;td&gt;&lt;/td&gt;是定义表格中的行的标签 &lt;td&gt;&lt;/td&gt;定义表格中行的单元格 &lt;table&gt; &lt;tr&gt;&lt;td&gt; 年龄&lt;/td&gt; &lt;td&gt;性别 &lt;/td&gt; &lt;td&gt;姓名&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;19&lt;/td&gt; &lt;td&gt;男&lt;/td&gt;&lt;td&gt; 王洪涛&lt;/td&gt;&lt;/tr&gt; &lt;/table&gt; 效果： 年龄 性别 姓名 19 男 王洪涛 表头单元格&lt;th&gt;&lt;/th&gt; 在表头加入表头标签会使表头文字加粗并居中，效果如下 年龄 性别 姓名 19 男 王洪涛 表格属性不建议在html中使用，一般在css中使用 属性名 属性值 描述 align left、center、right 规定表格在网页中的对齐方式 border 1或”” 规定表格单元是否拥有边框，默认没有，1表示有 cellpadding 像素值 规定单元边沿与其内容之间的空白，默认为1 cellspacing 像素值 规定单元格之间的空白，默认为2 width 像素值或百分比 规定表格的宽度 height 像素 规定表格的高度 表格结构标签&lt;thead&gt;&lt;/thead&gt; &lt;tbody&gt;&lt;/tbody&gt; thead内必须有tr 合并单元格 跨行合并 rowspan=“合并单元格的个数”，最上侧单元格为目标单元格，写合并代码 跨列合并 colspan=“合并单元格的个数”，最左侧单元格为目标单元格，写合并代码 &lt;table width=&quot;500&quot; height=&quot;249&quot; border=&quot;1&quot; cellspacing=&quot;0&quot;&gt; &lt;tr&gt; &lt;td&gt; &lt;/td&gt;&lt;td colspan=2&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt; &lt;/td&gt;&lt;td&gt; &lt;/td&gt;&lt;td&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt; &lt;/td&gt;&lt;td&gt; &lt;/td&gt;&lt;td&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; 效果如下： 列表标签无序列表&lt;ul&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;/ul&gt; 效果如下 1 2 注意：ul中只能放li标签，但li里面可以放任意标签 有序列表&lt;ol&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;/ol&gt; 效果如下 第一 第二 自定义列表&lt;dl&gt; &lt;dt&gt;联系方式&lt;/dt&gt; &lt;dd&gt;QQ&lt;/dd&gt; &lt;dd&gt;微信&lt;/dd&gt; &lt;/dl&gt; 效果如下： 联系方式 QQ 微信 表单标签表单的组成在HTML中，一个完整的表单由三部分组成，分别是 表单域 表单控件 提示信息 表单域在HTML标签中，&lt;form&gt;&lt;/form&gt;标签用于定义表单域form会把它范围内的表单元素提交给服务器 &lt;form action=&quot;url地址&quot; method= &quot;提交方式&quot; name=&quot;表单域名称&quot;&gt; 各种表单元素控件 &lt;/form&gt; 常用属性： 属性 属性值 作用 action url地址 用于指定接收并处理表单数据的服务器程序的url地址 method get/post 用于设置表单数据的提交方式，取其值为get或post name 名称 用于指定表单的名称，以区分同一个页面中的多个表单域 表单元素&lt;input&gt;表单元素&lt;input type=&quot;属性值&quot;/&gt; &lt;form&gt; 用户名：&lt;input type=&quot;text&quot; name=&quot;username&quot; value=&quot;请输入用户名&quot;/&gt;&lt;br&gt; 密码:&lt;input type=&quot;password&quot; name=&quot;password&quot;&gt; 性别:男&lt;input type=&quot;radio&quot; name=&quot;sex&quot;&gt;女&lt;input type=&quot;radio&quot; name=&quot;sex&quot;&gt; 爱好:男&lt;input type=&quot;chekbox&quot; name=&quot;hobby&quot;&gt;女&lt;input type=&quot;chekbox&quot; name=&quot;hobby&quot;&gt; &lt;input type=&quot;submit&quot;&gt; &lt;input type=&quot;button&quot; value=&quot;按钮&quot;&gt; 上传文件:&lt;input type=&quot;file&quot;&gt; &lt;/form&gt; 效果如下： 用户名： 密码: 性别:男女 选框组件可以选择checked属性为checked，默认勾选 爱好:男女 上传文件: lable标签lable标签可以绑定表单组件，使操作更快捷 &lt;label for=&quot;text&quot;&gt; 用户名:&lt;/label&gt;&lt;input type=&quot;checkbox&quot; id=&quot;text&quot;&gt; 效果如下: 用户名: 下拉标签&lt;select&gt; &lt;option selected=&quot;selected&quot;&gt;男&lt;/option&gt; &lt;option&gt;女&lt;/option&gt; &lt;/select&gt; 效果： 性别: 男 女 文本域标签&lt;textarea cols=&quot;50&quot; rows=&quot;5&quot;&gt;输入反馈&lt;/textarea&gt; cols和rows表示显示的列数和行数 今日反馈: 输入反馈","categories":[],"tags":[]},{"title":"互联网行业职业分析","slug":"互联网行业职业分析/互联网行业职业分析","date":"2022-03-18T13:46:04.000Z","updated":"2022-03-19T00:55:57.428Z","comments":true,"path":"2022/03/18/互联网行业职业分析/互联网行业职业分析/","link":"","permalink":"http://110.42.136.235/2022/03/18/%E4%BA%92%E8%81%94%E7%BD%91%E8%A1%8C%E4%B8%9A%E8%81%8C%E4%B8%9A%E5%88%86%E6%9E%90/%E4%BA%92%E8%81%94%E7%BD%91%E8%A1%8C%E4%B8%9A%E8%81%8C%E4%B8%9A%E5%88%86%E6%9E%90/","excerpt":"","text":"互联网公司职业之间的关系 以下对这些岗位的工作内容做更详细的讲解和说明： 销售/客服/商务 销售，将商品推销售卖出去的人； 客服，为客服服务解答疑问的人，售前、售中、售后都需要客服； 商务，为公司业务发展谈合作的人。 产品经理产品经理接受来自高层、销售、客服、商务、运营等同学提出的需求，其工作内容是明确以下内容，并督促大家按预期完成。 产品需要设计成什么样子才能满足需求方的要求？ 完成本次需求实现需要调动哪些产品组？ 各产品组之间分别需要负责什么改动? 各产品预期何时开发，何时测试，何时上线？ 分析 商业分析负责对竞品、行业进行调研分析，并完成行业报告，为业务的战略发展提供支持。 数据分析负责建设业务数据指标体系，并从数据指标变化观察业务异常、洞察行业机会、提出业务改进机会。 工程师 服务端开发工程师/前端工程师/算法工程师负责根据产品经理提出的需求，设计具体的技术方案，并完成代码实现和上线。 测试(开发)工程师负责根据产品需求、技术方案，设计测试用例验证需求实现并且代码无缺陷，开发完成的代码必须测试无误后才能上线。 运营 运营产品上线后，运营同学会建设关键运营指标，并通过各种手段提高关键运营指标，如与用户做沟通调查。 运维(开发)工程师负责代码上线后，服务器、部署环境方面的维护工作。 心得体会 了解互联网行业各个职位的工作和关系之后，我对自己的目标有了重新的定位，互联网行业并不是清一色的代码，也有许多需要沟通和交流的工作，结合我的自身性格，我觉得我更适合做开发岗。在以后的学习生活中，我要多学习和接触前端和后端的技术，争取能够独立开发项目。","categories":[],"tags":[]},{"title":"vscode连接使用MySQL","slug":"vscode连接使用MySQL","date":"2022-03-18T01:18:02.000Z","updated":"2022-03-18T13:26:27.853Z","comments":true,"path":"2022/03/18/vscode连接使用MySQL/","link":"","permalink":"http://110.42.136.235/2022/03/18/vscode%E8%BF%9E%E6%8E%A5%E4%BD%BF%E7%94%A8MySQL/","excerpt":"","text":"下载MySQL去官网下载MySQL 配置vscode下载Mysql安装配置Mysql 修改c_cpp_properties在c_cpp_properties中做出如下修改 修改launch在launch中做出如下修改 修改tasks在tasks中作出如下修改 连接MySQL安装MySQL插件安装完成后会在左下角出现该图标，点击加号如果找不到该图标可以检查资源管理器旁边的设置并勾选上MySQL依次输入localhost(或127.0.0.1)，用户名(默认是root),密码(MySQL设置的密码),端口号一般默认是3306,后面直接回车跳过即可 连接成功之后会出现下图所示，系统会自带几个database 使用MySQL此时可以正式在vscode中使用Mysql了，右击数据库会生成一个.sql文件使用sql语句，右击，选择Run MySQL Querysql语句 运行结果截图 参考文献","categories":[],"tags":[]},{"title":"SQL Server学习日记","slug":"SQL-Server学习日记","date":"2022-03-17T13:09:29.000Z","updated":"2022-03-22T13:24:43.775Z","comments":true,"path":"2022/03/17/SQL-Server学习日记/","link":"","permalink":"http://110.42.136.235/2022/03/17/SQL-Server%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/","excerpt":"","text":"创建数据库（1） 数据库名称 Test2。（2） 主要数据文件：逻辑文件名为Test2_data1，物理文件名为Test2_data1.mdf，初始容量为10MB，最大容量为100MB，增幅为10MB。次要数据文件会自动生成 create database Test2 on primary (name = Test2_data1, filename = &#39;d:\\SQL Server Project\\Test2\\Test2_data1.mdf&#39;, size=10,maxsize=100,filegrowth=10) log on(name=Test2_log1, filename = &#39;d:\\SQL Server Project\\Test2\\Test2_data2.ndf&#39;, size=10,maxsize=50,filegrowth=20) 修改数据库数据库更名alter database test1 modify name=new_test1 修改数据库属性alter database Test2 modify file(name=Test2_data1, size=50,maxsize=200,filegrowth=20), (name=Test2_data2, size=50,maxsize=300,filegrowth=20), (name=Test2_log1, size=30,maxsize=100,filegrowth=10%） 创建表格 学生表格 create table student( Student_id char(10) not null primary key, Student_name char(10) not null , sex char(1) not null constraint sex check(sex=&#39;F&#39; or sex=&#39;M&#39;) , birth smalldatetime not null, age int, department char(15) not null default &#39;计算机系&#39;) 课程表格 create table course (Course_id char(6)not null primary key clustered, Course_name char(20) not null , PreCloud char(6), credits tinyint not null ) score 表格 create table score (Student_id char(10) references student(Student_id), Course_id char(6) references course(Course_id), Grade tinyint constraint Grade check(Grade&gt;0 and Grade&lt;100)) 修改表格（1） 为表student增加一个memo（备注）字段，类型为varchar（200）。 alter table student add memo varchar(200) （2） 将memo字段的数据类型更改为varchar（300）。 alter table student Alter column memo varchar(300) （3） 删除memo字段 alter table student drop column memo （4） 添加记录 insert into 表格名字 values(数据) 删除表格drop table course","categories":[],"tags":[{"name":"学习日记","slug":"学习日记","permalink":"http://110.42.136.235/tags/%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/"}]}],"categories":[{"name":"安全框架","slug":"安全框架","permalink":"http://110.42.136.235/categories/%E5%AE%89%E5%85%A8%E6%A1%86%E6%9E%B6/"},{"name":"依赖管理","slug":"依赖管理","permalink":"http://110.42.136.235/categories/%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86/"},{"name":"MyBatisPlus","slug":"MyBatisPlus","permalink":"http://110.42.136.235/categories/MyBatisPlus/"},{"name":"Redis","slug":"Redis","permalink":"http://110.42.136.235/categories/Redis/"},{"name":"spring","slug":"spring","permalink":"http://110.42.136.235/categories/spring/"}],"tags":[{"name":"安全框架","slug":"安全框架","permalink":"http://110.42.136.235/tags/%E5%AE%89%E5%85%A8%E6%A1%86%E6%9E%B6/"},{"name":"依赖管理","slug":"依赖管理","permalink":"http://110.42.136.235/tags/%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86/"},{"name":"学习笔记","slug":"学习笔记","permalink":"http://110.42.136.235/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"spring","slug":"spring","permalink":"http://110.42.136.235/tags/spring/"},{"name":"学习日记","slug":"学习日记","permalink":"http://110.42.136.235/tags/%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/"}]}