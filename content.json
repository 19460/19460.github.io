{"meta":{"title":"出其东门","subtitle":"","description":"","author":"WHT","url":"http://110.42.136.235","root":"/"},"pages":[{"title":"","date":"2022-05-07T14:32:22.493Z","updated":"2022-05-07T14:32:22.493Z","comments":true,"path":"about/index.html","permalink":"http://110.42.136.235/about/index.html","excerpt":"","text":"个人信息"},{"title":"所有标签","date":"2022-05-02T01:01:27.541Z","updated":"2022-05-02T01:01:27.541Z","comments":true,"path":"tags/index.html","permalink":"http://110.42.136.235/tags/index.html","excerpt":"","text":""},{"title":"所有分类","date":"2022-05-02T01:01:45.125Z","updated":"2022-05-02T01:01:45.125Z","comments":true,"path":"categories/index.html","permalink":"http://110.42.136.235/categories/index.html","excerpt":"","text":""},{"title":"contact","date":"2022-03-24T02:22:21.000Z","updated":"2022-03-24T02:22:21.384Z","comments":true,"path":"contact/index.html","permalink":"http://110.42.136.235/contact/index.html","excerpt":"","text":""},{"title":"照片","date":"2022-03-23T13:37:12.142Z","updated":"2022-03-23T13:37:12.142Z","comments":true,"path":"pictures/index.html","permalink":"http://110.42.136.235/pictures/index.html","excerpt":"","text":"div.img { margin: 5px; border: 5px solid #ccc; float: left; width: 200px; } div.img:hover { border: 2px solid #777; } div.desc { padding: 15px; text-align: auto; } 1 2 3 4 5 6 7 8"},{"title":"music","date":"2022-03-24T10:48:17.000Z","updated":"2022-03-24T10:48:17.089Z","comments":true,"path":"music/index.html","permalink":"http://110.42.136.235/music/index.html","excerpt":"","text":""},{"title":"comment","date":"2022-05-02T00:45:09.000Z","updated":"2022-05-02T01:12:50.057Z","comments":true,"path":"comment/index.html","permalink":"http://110.42.136.235/comment/index.html","excerpt":"","text":"留言板： 有什么想说的？ 有什么想问的？ 有什么想吐槽的？ 可以在下面留言…"},{"title":"友链","date":"2021-02-18T05:54:26.000Z","updated":"2022-05-02T01:08:48.738Z","comments":false,"path":"link/index.html","permalink":"http://110.42.136.235/link/index.html","excerpt":"","text":""}],"posts":[{"title":"人工智能导论","slug":"人工智能导论","date":"2022-05-09T01:31:02.000Z","updated":"2022-05-11T01:52:32.883Z","comments":true,"path":"2022/05/09/人工智能导论/","link":"","permalink":"http://110.42.136.235/2022/05/09/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AF%BC%E8%AE%BA/","excerpt":"","text":"无信息搜索什么是树搜索和图搜索搜索树（search trees）对于一个状态出现的次数没有限制。 通过移除一个与部分计划对应的节点（用给定的策略来选择）并用它所有的子节点代替它，我们不断地扩展（expand）我们的边缘。用子节点代替边缘上的元素,相当于丢弃一个长度为n的计划并考虑所有源于它的长度为（n+1）的计划。我们继续这一操作，直到最终将目标从边缘移除为止。 图搜索（graph search）跟踪哪些状态已经扩展过，确保每一个节点在扩展前不在这个集合中，并且在扩展后将其加入集合里。经过这种优化的树搜索称为图搜索（graph search） DFS 深度优先 完备性：深度优先搜索并不具有完备性。如果在状态空间图中存在回路，这必然意味着相应搜索树的深度将是无限的。因此，存在这样一种可能性，即DFS老实地在无限大的搜索树中搜索最深的节点而不幸地陷入僵局，注定无法找到解。 最优性：深度优先搜索只是在搜索树中找到“最左边”的解，而没有考虑路径的代价，因此不是最优的。 时间复杂度：在最坏情况下，深度优先搜索最终可能会搜遍整个搜索树。因此，给定一棵最大深度为m的树，DFS的时间复杂度为 空间复杂度：在最坏情况下，DFS在边缘上m个深度级别上都有b个节点。这是一个简单的结果，因为一旦某个父节点的b个子节点进入队列，DFS的本性在任意时间点都只允许研究任意一个子节点的一棵子树。因此，DFS的空间复杂度是 BFS 广度优先 完备性：如果存在一个解，那么最浅节点s的深度一定是有限的，所以BFS最终一定会搜索这个深度。所以它是完备的。 最优性：BFS一般不是最优的，因为它在选择边缘上被替换的节点时不会考虑代价问题。在所有边的代价都相等的特殊情况下BFS可以保证是最优的，因为这会让BFS退化为一致代价搜索，我们将会在下面讨论这个特殊情况。 时间复杂度：在最坏情况下我们必须搜索 个节点，因为我们得在从1到s每一个深度下都遍历所有节点。因此，时间复杂度是 空间复杂度：在最坏情况下，边缘所有节点都在对应最浅解的那一层。由于最浅解位于深度s处，在这一深度有 个节点。 Uniform Cost Search 一致代价搜索描述：一致代价搜索（UCS），我们的最后一种方案，总是选择距离起始节点代价最小的边缘节点来扩展。 完备性：一致代价搜索是完备的。如果存在一个目标状态，它一定有一些有限长度最短路径；因此，UCS最终一定能找到这条长度最短路径。 最优性：如果我们假设所有的边都是非负的，那么UCS也是最优的。通过构造，由于我们按照路径代价递增的顺序来搜索节点，我们肯定能找到到达一个目标状态的最低代价路径。一致代价搜索的策略与Dijkstra算法相同，主要区别在于UCS在找到一个解状态时终止，而不是找到通往所有状态的最短路径。 时间复杂度：我们定义最优路径代价为 ，状态空间图内两节点之间最小代价为 。那么，我们得简单粗暴地遍历深度为从 到 范围内的所有节点，导致运行时间为 空间复杂度：又是简单粗暴地，边缘会包括代价最低解所在层的所有节点，所以UCS空间复杂度大约为 对于人类会怎么做,需要更聪明的算法 深度受限搜索深度优先搜索在无限状态空间会失败，深度受限就是为了解决这一问题的 对深度优先搜索设置深度限制，但是缺失了完备性和最优性。 迭代加深的深度优先搜索描述：从深度为0开始，深度不断增大，直到找到目标 最优性：具有最优性 完备性：具备完备性 时间复杂度和空间复杂度都是$$O(b^d)$$ 双向搜索描述：一个从初始状态向前搜索，一个从目标状态向后搜索，希望他们在中间某点相遇 具有完备性和最优性 时间复杂度和空间复杂度都是：$$O(b^{d\\frac{b}{2}})$$ 有信息搜索(启发式)启发式搜索是允许估计到目标状态距离的驱动力——它们是将状态作为输入并输出相应估计的函数。由这样一个函数执行的计算是专门针对所解决的搜索问题的。例如采用曼哈顿距离计算下一节点是否距离目标节点更近，这就是有信息搜索的一个例子 曼哈顿距离法（Manhattan Distance），对于两个点 和 的定义为： 贪婪最佳优先搜素 greedy best-first search描述：贪婪搜索总是选择有最小启发值（lowest heuristic value）的节点来扩展，这些节点对应的是它认为最接近目标的状态。 通过一个启发式函数估算我们离目标有多近，并且注意启发式函数并不代表实际到达的步数，有墙可能会更远 完备性和最优性：如果存在一个目标状态，贪婪搜索无法保证能找到它，它也不是最优的，尤其是在选择了非常糟糕的启发函数的情况下。在不同场景中。它的行为通常是不可预测的，有可能一路直奔目标状态，也有可能像一个被错误引导的DFS一样并遍历所有的错误区域。 A*搜索在下面的图中，如果使用贪婪最优算法，并不会选择最优路径，原因是在于贪婪最优只考虑了距离终点的距离，而不会考虑到达当前节点所需要的的代价，在后续节点中代价逐渐增大，但贪婪最优无法作出调整 如何改进？判断权值是否再选择一个较小的结果后，又发现回升。 A*搜索不仅考虑启发式函数，还考虑多长时间达到特定状态。$$f(n)=g(n)+h(n)$$ g(n)代表到达当前节点的代价， h(n)代表从n到达目标解的代价的启发函数 f(n):A*搜索使用的估计总代价函数 如果启发式函数不高估实际成本，那么它是可接受的，每个节点的结果或者与实际相同，或者小于实际值，但是不能认为我离目标比实际更远。。选择启发式函数，是挑战，启发式函数越好越容易解决问题。A*通常需要大量内存。 完备性和最优性：在给定一个合适的启发函数（我们很快就能得到）时，A*搜索既是完备的又是最优的。它结合了目前我们发现的所有其他搜索策略的优点，兼备贪婪搜索的高搜索速度以及UCS的完备性和最优性。 可纳性和一致性可纳性： 使用A*树搜索时，最优性所需的条件称为可纳性（admissibility）。可纳性约束表明，用一个可纳的启发式估算的值既不是负的，也不会被高估。定义 为从一个给定节点n到达目标状态的真正的最佳前进代价，我们能将可纳性约束数学表示为： 定理. 对于一个给定的搜索问题，如果一个启发式函数h满足可纳性约束，使用含有h的A*树搜索能得到最优解。 一致性 一致性的核心思想在于，我们不仅仅强制让启发式算法低估从任意给定节点到目标的总距离，还低估了图中每一条边的代价/权重。由启发式函数度量的边的代价只是两个连接的节点的启发值的差异。一致性约束的数学表示如下： 定理. 对于一个给定的搜索问题，如果启发式函数h满足一致性约束，对这个搜索问题使用有h的A*图搜索能得到一个最优解。 局部搜索算法局部搜索算法是从单个节点出发，通常只移动到它的临近状态，一般情况下不保留搜索路径。虽然局部搜索算法不是系统化的，但是有两个关键的优点： 他们通常使用很少的内存–通常是常数 他们经常能在系统化算法不适用的很大或无限的（连续的）状态空间中找到合理的解 爬山法爬山法有时称为贪婪局部搜索，因为它只选择邻居中状态最好的一个，而不考虑下一步该怎么走。 爬山法经常会陷入困境，比如局部最大值和山脊（有一系列局部最大值）和高原（平的局部最大值） 最陡上升不断向值增加的方向移动，可以看成是一个登高的过程、在到达一个峰顶的时候结束（邻接状态下没有比它更高的）。算法不会考虑与当前状态不相邻的状态，算法不维护搜索树，当前节点的数据结构只是记录当前状态和目标函数值。 随机爬山法在上山移动中随机地选择下一步 随机爬山法在上山移动中随机选择下一步；被选中的概率可能随着上山移动的陡峭程度不同而不同。这种算法通常比最陡上升算法的收敛速度慢不少，但是在某些状态空间地形图上它能找到更好的解。 首选爬山实现了随机爬山法，随机地生成后继节点直到生成一个优于当前节点的后继。这个算法在后继节点很多的时候（比如上千个）是个好策略。 随机重启爬山法之前的三个爬山法都是不完备的，经常会在局部极大值卡住。 随机重启爬山法（random restart hill climbing）， 它通过随机生成初始状态来导引爬山法搜索，直到找到目标。 这种算法完备的概率接近1 原因：它最终会生成一个目标状态来作为初始状态。 模拟退火搜索模拟退火搜索时爬山法和随机行走以某种方式结合 Simulated Annealing 模拟退火算法 为什么名字这么奇怪，因为这是一个由金属退火启发的算法。 金属退火是将金属加热到一定温度，保持足够时间，然后以适宜速度冷却(通常是缓慢冷却，有时是控制冷却)的一种金属热处理工艺。模拟退火算法来源于固体退火原理，将固体加温至充分高，再让其徐徐冷却，加温时，固体内部粒子随温升变为无序状，内能增大，而徐徐冷却时粒子渐趋有序，在每个温度都达到平衡态，最后在常温时达到基态，内能减为最小。 局部束搜索a、随机产生k个状态，然后每一步从所有的后继状态中选择k个最佳的后继状态（也有健康度函数，详见下文）直到找到目标状态（内存中同时保留k个状态），增大了找到全局最优的概率。b、相当于多个人去找，或者多次爬山法。c、状态越多，找到最优的可能性越大d、空间复杂度高；时间复杂度大；来自同一个父节点的子节点可能非常相似，可能导致同样的一个局部最优，从而减小了找到全局最优的可能性。e、可以通过每个状态各产生一个最佳后继状态（待验证） 遗传算法遗传算法（Genetic Algorithm, GA）是模拟达尔文生物进化论的自然选择和遗传学机理的生物进化过程的计算模型，是一种通过模拟自然进化过程搜索最优解的方法。 遗传算法以一种群体中的所有个体为对象，并利用随机化技术指导对一个被编码的参数空间进行高效搜索。其中，选择、交叉和变异构成了遗传算法的遗传操作 对抗搜索Minimax 极大极小算法 通过编码使计算机明白min和max，也就是把输赢的结果转化为数字的大小，min尽可能的使数字更小，而max尽可能地使数字更大 α-β剪枝 Alpha-Beta Pruning 在寻找极大极小值时我们发现，有些节点可以不用搜索，因为在min选择极小值时需要考虑下一步的max是否会选择当前节点，如果当前的值比其他的节点值更小，那么我们可以认为该节点不会被下一次的max所选择，也就没有继续搜索下去的必要了。 约束满足问题搜索约束满足问题（constraint satisfaction problems）(CSPSs).与搜索问题不同，CSP是一种识别问题（identification problem），对这种问题，我们只需要识别一个状态是否是目标状态，不用管我们如何到达那个目标。CSPs由三个要素定义： 变量Variables：CSP拥有一个集合，其中有N个变量 ，每一个都可以从定义的一组值中取一个值。 域Domain：一个CSP变量所有可能取值的集合 约束Constrains：约束定义了变量取值的限制条件，这可能与其他变量有关。 约束满足问题求解 约束满足问题的传统解法是使用一种叫做回溯搜索（Backtracking search）的算法 Uncertainty概率的加法公式$$p(a+b)=p(a)+p(b)$$概率的乘法公式$$p(ab)=p(a|b)p(b)$$Bayes’ Rule 贝叶斯公式$$p(b|a)=\\frac{p(a|b)p(b)}{p(a)}$$例子，已知如下 早上有云，下午下雨的概率 上午有云，下午有0.8的概率下雨 有0.4日子是早上有云 有0.1日子是下午有雨 $$p(rain|cloud)=\\frac{p(cloud|rain)p(rain)}{p(cloud)}=\\frac{0.8*0.1}{0.4}=0.2$$ 贝叶斯网络 不确定搜索 Non-Deterministic SearchAgent所在的环境会迫使agent的行为变得**不确定(nondeterministic)，意味着在某一状态下采取的一个行动会有多个可能的后继状态。实际上，这就是许多像扑克牌或是黑杰克这样的卡牌游戏中会出现的情况，存在着由发牌的随机性导致的固有的不确定性。这种在世界中存在一定程度的不确定性的问题被称为不确定搜索问题(nondeterministic search problems)，可以用马尔科夫决策过程(Markov decision processes)**或者称为MDPs来解决。 马尔科夫过程什么是马尔科夫过程，简单来说，马尔科夫过程就是一个无记忆的随机过程，这个过程的未来只有当前有关而与过去无关。比如明天是否睡觉取决于今天的状态而与过去的状态无关，这就是马尔科夫过程。 马尔科夫过程包含一个状态转移矩阵，表示从状态s转移到后继状态s‘的概率 马尔科夫过程（或马尔科夫链）是一个二元组&lt;S,P&gt; S：有限状态集 P：状态转移概率矩阵 $$P_{ss’}=P[S_{t+1}=s’|S_{t}=s]$$ 马尔可夫奖励过程马尔可夫奖励过程是一个四元组&lt;S,P,R,γ&gt; S：有限状态集 P：状态转移概率矩阵 R：奖励函数$$R_{S}=E[R_{t+1}|S_{t}=s]$$γ：折扣因子$$\\gamma \\in [0,1]$$为什么要有折扣因子呢？$$G_{t}=R_{t+1}+\\gamma R_{t+2}+\\gamma ^{2}R_{t+3}+….$$Gt代表从时间t开始的总折扣奖励，因为未来还很长远，是不确定的，因此未来的收益应该占的比重小一些，越是往后所占权重越小，逐渐趋于零，而当前的奖励应该占权重最大 马尔可夫决策过程(Markov Decision Process)马尔可夫决策过程是一个五元组&lt;S,A,P,R,γ&gt;，求解一个马尔可夫决策过程，则意味着找到最优策略π* S：有限状态集 A：有限动作集 P：状态转移矩阵 (也有的地方是T) R：奖励函数 γ：折扣因子$$\\pi 是给定状态的动作分布 \\pi (a|s)=P[A_{t}=a|S_{t}=s]$$状态值函数：$$V_{\\pi}(s)=E_{\\pi}[G_{t}|S_{t}=s]$$动作值函数：$$q_{\\pi}(s,a)=E_{\\pi}[G_{t}|S_{t}=s,A_{t}=a]$$状态值函数的贝尔曼期望方程：某一个状态的价值可以用该状态下所有动作的价值表述$$V_{\\pi} (s)=E_{\\pi}[R_{t+1}+\\gamma v_{\\pi}(S_{t+1})|S_{t}=s]$$动作值函数的贝尔曼期望方程： 某一个动作的价值可以用该状态后继状态的价值表述，及 发生了动作a的价值$$q_\\pi (s,a) = E_\\pi[R_{t+1}+\\gamma q_\\pi (S_{t+1},A_{t+1})|S_t=s,A_t=a]$$ 贝尔曼(Bellman)方程 一个状态s的最优值——s的最优值是一个从s出发的agent在其余下寿命中采取最优行动能获得的效益的期望值。 一个q状态(s,a)的最优值， ——(s,a)的最优值是一个agent从状态s采取行动a之后获得的效益的期望值，并且该agent从此以后采取的都是最优行动。 通过这两个值，以及在此之前讲到的MDP中其他的值，Bellman方程定义如下： 在我们解释这个方程的含义之前，我们还要定义一下表示一个q状态的最优值的方程(也就是最优q值(q-value))： Bellman方程是**动态规划方程(dynamic programming equation)**的一个例子，这种方程能通过其内在的递归结构将一个问题分解成一些小问题。我们能在关于一个状态的q值的方程中看到这种内在递归，形如 这个式子表示一个agent从状态s采取行动a到达状态s’，并从此一直采取最优行动所获得的总效益。采取行动a之后立即获得的奖励， 加上从状态s’出发能获得的最优奖励 为了考虑采取a所花费的时间步，对其用 对取了折扣。虽然在大多数情况下，从s’出发到某一最终状态的状态和行动序列有非常多的可能性，全部的这些细节都被抽象并概括为一个迭代值 。 已知 表示在从q状态（s,a)到达状态s’之后一直采取最优行动获得的效益 现在很明显了，以下这个值 就是效益的加权和。每个效益的权重就是其出现的概率。这正是从q状态(s,a)出发并一直采取最优行动的期望效益！我们的分析到此完整了，并且我们能由此解释完整的Bellman方程——一个状态的最优值， ，就是从s出发的所有可能的行动所能得到的最大期望效益。 值迭代 (Value Iteration)求解马尔科夫决策过程现在我们有了一个能验证MDP中各状态的值的最优性的框架，接下来自然就想知道如何能精确计算出这些最优值。为此我们需要限时值（time-limited values）（强化有限界得到的结果）。限制时间步数为k的一个状态s的限时值表示为 ，代表着在已知当前MDP会在k时间步后终止的情况下，从s出发能得到的最大期望效益。这也正是一个在MDP的搜索树上执行的k层expectimax所返回的东西。 简单来说，值迭代就是给定k，也就是步数为k，在这k步之内，我们希望值迭代已经到达稳定状态，即下一次迭代与这一次的完全相同，这时我们就得到一个最优决策，也就是从哪里出发能够得到最大期望效益。 **值迭代(Value iteration)是一种动态规划算法(dynamic programming algorithm)**，通过一个迭代加长的时间限制来计算限时值，直到收敛（也就是说，直到每个状态的V值都与其之前的迭代一样： 。执行流程如下： 1. ，设初值 。这个很直观，因为把时间限制设为0代表着在终止之前无法执行任何操作，所以也无法获得任何奖励。 2.重复如下更新操作，直至收敛: 在值迭代的第k轮，我们给每个状态使用时限为k的限时值来生成时限为(k+1)的限时值。本质上来说，我们通过计算子问题的解(所有的 )来迭代的得到更高一级的子问题的解(所有的 ；这就让值迭代成为了一个动态规划算法。 也就是在初始时，所有的状态价值V0(s)都是0，在然后进行价值迭代，对每个节点，按照第二步的公式进行计算其状态价值，每进行一次迭代就会更新每个节点的状态价值 这里引用**bilibili博主 Re_miniscence_ **的例子 后续将按照第二步进行迭代，直到收敛，也就是下一次迭代与上一次一致，这时就可以做出决策 这时我们发现12是其中最大的，也就是最优决策对应的状态价值，所以得出结论，从此位置出发将得到最大收益 以下是**知乎博主亦知弦余**的例子 迭代过程1 迭代过程2 cool warm overheated V0 0 0 0 V1 2 1 0 V2 2.75 1.75 0 任何最终状态的 都一定是0，因为无法从最终状态进行任何行动来获得奖励。 策略迭代 Policy Iteration求解马尔科夫决策过程策略提取 Policy Extraction 还记得我们解决MDP的最终目标是要确定一个最优策略。只需要确定所有状态的最优值就能达成这一目标，这可以通过一种叫**策略提取(policy extraction)**的方法来实现。策略提取的背后的思想非常简单：如果你处于一种状态s，你应该采取会产生最大期望效益的行动a。不难想到，a正是会将我们带到具有最大q值的q状态的操作，于是最优策略可以表达为： 为了取得最好的效益，状态的最优q值对策略提取来说是最好的，因为在这种情况下，只需要一次argmax就能确定从一个状态出发的最优行动。仅保存每个 意味着我们必须在取argmax之前用Bellman方程重新计算所有必须的q值，相当于进行一次深度为1的expectimax。 策略迭代 Policy Iteration 值迭代可能会很慢。在每次迭代中，我们必须更新所有|S|个状态的值（|n|表示集合中元素的个数），其中每个都要求在我们计算每个行动的q值时对所有|A|个行动进行迭代。对这些每个q值的计算，需要轮流对|S|个状态再次进行迭代，导致时间成本过高 。此外，当我们只想确定MDP的最优策略时，值迭代会进行大量多余的计算，因为由策略提取得到的策略通常会比值本身更快地收敛。修正这些缺陷的方法就是选择策略迭代，这种算法可以在保持值迭代的最优性的同时还能对表现进行大幅提升。策略迭代的操作如下： 定义一个初始策略。这个可以随意定，但是如果初始策略越接近最优策略，策略迭代收敛得也就越快。 重复以下操作，直至收敛： 用策略评估对当前策略进行评估。对于一个策略π，策略评估意味着计算所有状态s的Vπ(s)，其中Vπ(s)表示按照策略π从状态s出发的期望效益： 把策略迭代的第i次迭代成为πi。由于我们正在对每个状态的一个行动进行修正，我们不再需要取最大的操作max operator，这样我们得到的系统就能有效由以上规则生成的|S|个方程构成的。然后每个 就可以通过解决这个系统来计算得到。另外，我们还可以选择通过执行以下更新规则直到收敛来计算 。跟值迭代中的操作异曲同工： 然而，这里第二种方法使其应用起来是明显会慢很多。 评估完当前策略后，用策略改进（policy improvement）来生成更好的策略。策略改进通过对由策略评估生成的状态的值进行策略提取，生成以下改进提升后的策略： 其中，当 时，算法成功收敛，我们就能得出 。 策略迭代就是给定初始策略，不断进行策略评估-&gt;策略提取-&gt;策略改进直至收敛 这里再次使用**知乎博主亦知弦余**的例子， 这个例子的迭代策略是第一种方式 我们把初始策略设为“一直慢速”： cool warm overheated π0 slow slow - 由于终点状态没有输出的行动，无法给一个终点状态赋值。因此，我们可以从之前的考虑中直接忽略overheated状态，直接对于所有终点状态s都赋值为 。下一步就是对于 进行一轮策略评估： 对这一些列关于 和 的方程求解可以得到： cool warm overheated Vπ0 2 2 0 现在我们就能用这些值进行策略提取了： （由于是引用，所以第二个公式结果有误，应该是slow=2） 进行第二轮策略迭代可以得到 以及 。由于这跟 是一样的策略，我们能得出 。证毕！ cool warm π0 slow slow π1 fast slow π2 fast slow 下面是**bilibili博主 Re_miniscence_ **的例子 ![](img/人工智能导论/2022-05-10 205306.png) ![](img/人工智能导论/2022-05-10 205843.png) ![](img/人工智能导论/2022-05-10 211433.png) ![](img/人工智能导论/2022-05-10 211811.png)","categories":[{"name":"AI","slug":"AI","permalink":"http://110.42.136.235/categories/AI/"}],"tags":[{"name":"AI","slug":"AI","permalink":"http://110.42.136.235/tags/AI/"}]},{"title":"jwt","slug":"jwt","date":"2022-04-28T01:44:59.000Z","updated":"2022-05-05T01:27:39.202Z","comments":true,"path":"2022/04/28/jwt/","link":"","permalink":"http://110.42.136.235/2022/04/28/jwt/","excerpt":"","text":"JWT介绍JWT与shiroshiro和JWT是典型的有状态登陆和无状态登陆的代表，所谓的有状态和无状态，就是看信息存在哪儿，存在服务器端，就叫做有状态，存在客户端，就叫无状态。 有状态就是说把信息存储在session中，因为session是存在服务端的，也就是有状态的，无状态就是把信息存在cookie中，cookie是存在客户端的，也就是无状态。 无状态的好处很明显，不存在服务端，可以减少服务端的压力 JWT的组成JWT由三部分拼接组成，中间用“.”分割 Header alg属性表示签名使用的算法，默认为HMAC SHA256（写为HS256）； typ属性表示令牌的类型，JWT令牌统一写为JWT。最后，使用Base64 URL算法将上述JSON对象转换为字符串保存 1234&#123; &quot;alg&quot;: &quot;HS256&quot;, &quot;typ&quot;: &quot;JWT&quot;&#125; Payload 1234567iss：发行人exp：到期时间sub：主题aud：用户nbf：在此之前不可用iat：发布时间jti：JWT ID用于标识该JWT 该部分不可以将密码等敏感信息存入 Signature 签名哈希部分是对上面两部分数据签名，需要使用base64编码后的header和payload数据，通过指定的算法生成哈希，以确保数据不会被篡改。首先，需要指定一个密钥（secret）。该密码仅仅为保存在服务器中，并且不能向用户公开。然后，使用header中指定的签名算法（默认情况下为HMAC SHA256）根据以下公式生成签名$$HMACSHA256(base64UrlEncode(header)+”.”+base64UrlEncode(payload),secret)$$ JWT验证逻辑 原文链接：https://blog.csdn.net/weixin_45070175/article/details/118559272 JWT使用快速开始第一步 引入依赖 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;!-- https://mvnrepository.com/artifact/io.jsonwebtoken/jjwt --&gt;&lt;dependency&gt; &lt;groupId&gt;io.jsonwebtoken&lt;/groupId&gt; &lt;artifactId&gt;jjwt&lt;/artifactId&gt; &lt;version&gt;0.9.1&lt;/version&gt;&lt;/dependency&gt;&lt;!-- 高版本jdk需要加入以下依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;javax.xml.bind&lt;/groupId&gt; &lt;artifactId&gt;jaxb-api&lt;/artifactId&gt; &lt;version&gt;2.3.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.sun.xml.bind&lt;/groupId&gt; &lt;artifactId&gt;jaxb-impl&lt;/artifactId&gt; &lt;version&gt;2.3.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.sun.xml.bind&lt;/groupId&gt; &lt;artifactId&gt;jaxb-core&lt;/artifactId&gt; &lt;version&gt;2.3.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.activation&lt;/groupId&gt; &lt;artifactId&gt;activation&lt;/artifactId&gt; &lt;version&gt;1.1.1&lt;/version&gt; &lt;/dependency&gt;&lt;!-- jjwt在0.10版本以后发生了较大变化，pom依赖要引入多个--&gt;&lt;dependency&gt; &lt;groupId&gt;io.jsonwebtoken&lt;/groupId&gt; &lt;artifactId&gt;jjwt-api&lt;/artifactId&gt; &lt;version&gt;0.11.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;io.jsonwebtoken&lt;/groupId&gt; &lt;artifactId&gt;jjwt-impl&lt;/artifactId&gt; &lt;version&gt;0.11.2&lt;/version&gt; &lt;scope&gt;runtime&lt;/scope&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;io.jsonwebtoken&lt;/groupId&gt; &lt;artifactId&gt;jjwt-jackson&lt;/artifactId&gt; &lt;!-- or jjwt-gson if Gson is preferred --&gt; &lt;version&gt;0.11.2&lt;/version&gt; &lt;scope&gt;runtime&lt;/scope&gt;&lt;/dependency&gt; 第二步 测试JWT 123456789101112131415161718192021222324252627282930313233343536373839404142@SpringBootTestclass JwtDemoApplicationTests &#123; private long time = 1000*60*60*24;//一小时 private String signature = &quot;admin&quot;; @Test void contextLoads() &#123; &#125; @Test void testJWT() &#123; JwtBuilder jwtBuilder= Jwts.builder(); String jwtToken = jwtBuilder //头信息 .setHeaderParam(&quot;typ&quot;,&quot;JWT&quot;) .setHeaderParam(&quot;alg&quot;,&quot;HS256&quot;) //载荷payload .claim(&quot;username&quot;,&quot;tom&quot;) .claim(&quot;role&quot;,&quot;admin&quot;) .setSubject(&quot;admin-test&quot;) .setExpiration(new Date(System.currentTimeMillis()+time)) .setId(UUID.randomUUID().toString()) //signature .signWith(SignatureAlgorithm.HS256,signature) //拼接 .compact(); System.out.println(jwtToken); &#125; @Test public void parse()&#123; String token = &quot;eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJ1c2VybmFtZSI6InRvbSIsInJvbGUiOiJhZG1pbiIsInN1YiI6ImFkbWluLXRlc3QiLCJleHAiOjE2NTExOTg4NDEsImp0aSI6ImI4NzY2Mzc3LTJjNjEtNDg1Mi04MTQzLTNhMzc3OTRlMGM3MyJ9.fqhPYypuPj0W7qdPqXxmcM9xHTiRJMEHteqz4cJPf_c&quot;; JwtParser jwtParser = Jwts.parser(); Jws&lt;Claims&gt; claimsJws = jwtParser.setSigningKey(signature).parseClaimsJws(token); Claims claims = claimsJws.getBody(); System.out.println(claims.get(&quot;username&quot;)); System.out.println(claims.get(&quot;role&quot;)); System.out.println(claims.getSubject()); System.out.println(claims.getExpiration()); &#125;&#125; 在工程中使用JWTUtils 1234567891011121314151617181920212223242526272829303132333435363738package com.wht.myblogapi.utils;import io.jsonwebtoken.Jwt;import io.jsonwebtoken.JwtBuilder;import io.jsonwebtoken.Jwts;import io.jsonwebtoken.SignatureAlgorithm;import java.util.Date;import java.util.HashMap;import java.util.Map;public class JWTUtils &#123; private static final String jwtToken = &quot;123456Mszlu!@#$$&quot;; private static long time = 1000*60*60*24;//一小时 public static String createToken(Long userId)&#123; Map&lt;String,Object&gt; claims = new HashMap&lt;&gt;(); claims.put(&quot;userId&quot;,userId); JwtBuilder jwtBuilder = Jwts.builder() .signWith(SignatureAlgorithm.HS256, jwtToken) // 签发算法，秘钥为jwtToken .setClaims(claims) // body数据，要唯一，自行设置 .setIssuedAt(new Date()) // 设置签发时间 .setExpiration(new Date(System.currentTimeMillis() + time));// 一小时的有效时间 String token = jwtBuilder.compact(); return token; &#125; public static Map&lt;String, Object&gt; checkToken(String token)&#123; try &#123; Jwt parse = Jwts.parser().setSigningKey(jwtToken).parse(token); return (Map&lt;String, Object&gt;) parse.getBody(); &#125;catch (Exception e)&#123; e.printStackTrace(); &#125; return null; &#125;","categories":[{"name":"安全框架","slug":"安全框架","permalink":"http://110.42.136.235/categories/%E5%AE%89%E5%85%A8%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"安全框架","slug":"安全框架","permalink":"http://110.42.136.235/tags/%E5%AE%89%E5%85%A8%E6%A1%86%E6%9E%B6/"}]},{"title":"java se进阶","slug":"Java高级编程","date":"2022-04-27T13:58:14.000Z","updated":"2022-05-07T01:17:49.995Z","comments":true,"path":"2022/04/27/Java高级编程/","link":"","permalink":"http://110.42.136.235/2022/04/27/Java%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B/","excerpt":"","text":"Java高级编程8_多线程程序、进程、线程的理解 程序(programm) 概念：是为完成特定任务、用某种语言编写的一组指令的集合。即指一段静态的代码。 进程(process) 概念：程序的一次执行过程，或是正在运行的一个程序。 说明：进程作为资源分配的单位，系统在运行时会为每个进程分配不同的内存区域 线程(thread) 概念：进程可进一步细化为线程，是一个程序内部的一条执行路径。 说明：线程作为调度和执行的单位，每个线程拥独立的运行**栈和程序计数器(pc)**，线程切换的开销小。 补充：内存结构 进程可以细化为多个线程。 每个线程，拥有自己独立的：栈、程序计数器 多个线程，共享同一个进程中的结构：方法区、堆。 并行与并发 单核CPU与多核CPU的理解 单核CPU，其实是一种假的多线程，因为在一个时间单元内，也只能执行一个线程的任务。例如：虽然有多车道，但是收费站只有一个工作人员在收费，只有收了费才能通过，那么CPU就好比收费人员。如果某个人不想交钱，那么收费人员可以把他“挂起”（晾着他，等他想通了，准备好了钱，再去收费。）但是因为CPU时间单元特别短，因此感觉不出来。 如果是多核的话，才能更好的发挥多线程的效率。（现在的服务器都是多核的） 一个Java应用程序java.exe，其实至少三个线程：main()主线程，gc()垃圾回收线程，异常处理线程。当然如果发生异常，会影响主线程。 并行与并发的理解 并行：多个CPU同时执行多个任务。比如：多个人同时做不同的事。 并发：一个CPU(采用时间片)同时执行多个任务。比如：秒杀、多个人做同一件事。 创建多线程的两种方式 方式一：继承Thread类的方式： 创建一个继承于Thread类的子类 重写Thread类的run() –&gt; 将此线程执行的操作声明在run()中 创建Thread类的子类的对象 通过此对象调用start()：①启动当前线程 ② 调用当前线程的run() 说明两个问题： 问题一：我们启动一个线程，必须调用start()，不能调用run()的方式启动线程。 问题二：如果再启动一个线程，必须重新创建一个Thread子类的对象，调用此对象的start(). 方式二：实现Runnable接口的方式： 创建一个实现了Runnable接口的类 实现类去实现Runnable中的抽象方法：run() 创建实现类的对象 将此对象作为参数传递到Thread类的构造器中，创建Thread类的对象 通过Thread类的对象调用start() 两种方式的对比： 开发中：优先选择：实现Runnable接口的方式。原因： 实现的方式没有类的单继承性的局限性 实现的方式更适合来处理多个线程有共享数据的情况。 联系：public class Thread implements Runnable 相同点：两种方式都需要重写run(),将线程要执行的逻辑声明在run()中。 目前两种方式，要想启动线程，都是调用的Thread类中的start()。 Thread类中的常用方法 常用方法 start():启动当前线程；调用当前线程的run() run(): 通常需要重写Thread类中的此方法，将创建的线程要执行的操作声明在此方法中 currentThread():静态方法，返回执行当前代码的线程 getName():获取当前线程的名字 setName():设置当前线程的名字 yield():释放当前cpu的执行权 join():在线程a中调用线程b的join(),此时线程a就进入阻塞状态，直到线程b完全执行完以后，线程a才结束阻塞状态。 stop():已过时。当执行此方法时，强制结束当前线程。 sleep(long millitime):让当前线程“睡眠”指定的millitime毫秒。在指定的millitime毫秒时间内，当前线程是阻塞状态。 isAlive():判断当前线程是否存活 线程的优先级： 优先级 MAX_PRIORITY：10 MIN _PRIORITY：1 NORM_PRIORITY：5 –&gt;默认优先级 如何获取和设置当前线程的优先级： getPriority():获取线程的优先级 setPriority(int p):设置线程的优先级 说明：高优先级的线程要抢占低优先级线程cpu的执行权。但是只是从概率上讲，高优先级的线程高概率的情况下被执行。并不意味着只当高优先级的线程执行完以后，低优先级的线程才执行。 线程通信：wait() / notify() / notifyAll() :此三个方法定义在Object类中的。 补充：线程的分类 守护线程 用户线程 Thread的生命周期 图示： 说明： 生命周期关注两个概念：状态、相应的方法 关注： 状态a–&gt;状态b:哪些方法执行了（回调方法） 某个方法主动调用：状态a–&gt;状态b 阻塞：临时状态，不可以作为最终状态 死亡：最终状态。 线程的同步机制 背景 例子：创建三个窗口卖票，总票数为100张.使用实现Runnable接口的方式 问题：卖票过程中，出现了重票、错票 –&gt;出现了线程的安全问题 问题出现的原因：当某个线程操作车票的过程中，尚未操作完成时，其他线程参与进来，也操作车票。 如何解决：当一个线程a在操作ticket的时候，其他线程不能参与进来。直到线程a操作完ticket时，其他线程才可以开始操作ticket。这种情况即使线程a出现了阻塞，也不能被改变。 Java解决方案：同步机制 在Java中，我们通过同步机制，来解决线程的安全问题。 方式一：同步代码块 123synchronized(同步监视器)&#123; //需要被同步的代码&#125; 说明： 操作共享数据的代码，即为需要被同步的代码。 –&gt;不能包含代码多了，也不能包含代码少了。 共享数据：多个线程共同操作的变量。比如：ticket就是共享数据。 同步监视器，俗称：锁。任何一个类的对象，都可以充当锁。 要求：多个线程必须要共用同一把锁。 补充：在实现Runnable接口创建多线程的方式中，我们可以考虑使用this充当同步监视器。 方式二：同步方法 如果操作共享数据的代码完整的声明在一个方法中，我们不妨将此方法声明同步的。 同步方法仍然涉及到同步监视器，只是不需要我们显式的声明。 非静态的同步方法，同步监视器是：this 静态的同步方法，同步监视器是：当前类本身 方式三：Lock锁 — JDK5.0新增 使用的优先顺序：Lock —&gt; 同步代码块（已经进入了方法体，分配了相应资源 ) —&gt; 同步方法（在方法体之外) 利弊 好处：同步的方式，解决了线程的安全问题。 弊端：操作同步代码时，只能一个线程参与，其他线程等待。相当于是一个单线程的过程，效率低。 面试题： Java是如何解决线程安全问题的，有几种方式？并对比几种方式的不同 synchronized和Lock方式解决线程安全问题的对比 相同：二者都可以解决线程安全问题 不同：synchronized机制在执行完相应的同步代码以后，自动的释放同步监视器；Lock需要手动的启动同步(lock())，同时结束同步也需要手动的实现(unlock()) 线程安全的单例模式(懒汉式)使用同步机制将单例模式中的懒汉式改写为线程安全的。 123456789101112131415161718192021222324252627282930class Bank&#123; private Bank()&#123;&#125; private static Bank instance = null; public static Bank getInstance()&#123; //方式一：效率稍差// synchronized (Bank.class) &#123;// if(instance == null)&#123;//// instance = new Bank();// &#125;// return instance;// &#125; //方式二：效率更高 if(instance == null)&#123; synchronized (Bank.class) &#123; if(instance == null)&#123; instance = new Bank(); &#125; &#125; &#125; return instance; &#125;&#125; 面试题：写一个线程安全的单例模式。 饿汉式。 懒汉式：上面提供的。 死锁问题 死锁的理解：不同的线程分别占用对方需要的同步资源不放弃，都在等待对方放弃自己需要的同步资源，就形成了线程的死锁 说明： 出现死锁后，不会出现异常，不会出现提示，只是所有的线程都处于阻塞状态，无法继续 我们使用同步时，要避免出现死锁。 举例： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970public static void main(String[] args) &#123; StringBuffer s1 = new StringBuffer(); StringBuffer s2 = new StringBuffer(); new Thread()&#123; @Override public void run() &#123; synchronized (s1)&#123; s1.append(&quot;a&quot;); s2.append(&quot;1&quot;); try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; synchronized (s2)&#123; s1.append(&quot;b&quot;); s2.append(&quot;2&quot;); System.out.println(s1); System.out.println(s2); &#125; &#125; &#125; &#125;.start(); new Thread(new Runnable() &#123; @Override public void run() &#123; synchronized (s2)&#123; s1.append(&quot;c&quot;); s2.append(&quot;3&quot;); try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; synchronized (s1)&#123; s1.append(&quot;d&quot;); s2.append(&quot;4&quot;); System.out.println(s1); System.out.println(s2); &#125; &#125; &#125; &#125;).start();&#125; 线程通信 线程通信涉及到的三个方法： wait():一旦执行此方法，当前线程就进入阻塞状态，并释放同步监视器。 notify():一旦执行此方法，就会唤醒被wait的一个线程。如果有多个线程被wait，就唤醒优先级高的那个。 notifyAll():一旦执行此方法，就会唤醒所有被wait的线程。 说明： wait()，notify()，notifyAll()三个方法必须使用在同步代码块或同步方法中。 wait()，notify()，notifyAll()三个方法的调用者必须是同步代码块或同步方法中的同步监视器。否则，会出现IllegalMonitorStateException异常 wait()，notify()，notifyAll()三个方法是定义在java.lang.Object类中。 面试题：面试题：sleep() 和 wait()的异同？ 相同点：一旦执行方法，都可以使得当前的线程进入阻塞状态。 不同点： 两个方法声明的位置不同：Thread类中声明sleep() , Object类中声明wait() 调用的要求不同：sleep()可以在任何需要的场景下调用。 wait()必须使用在同步代码块或同步方法中 关于是否释放同步监视器：如果两个方法都使用在同步代码块或同步方法中，sleep()不会释放锁，wait()会释放锁。 小结 小结释放锁的操作： 小结不会释放锁的操作： JDK5.0新增线程创建的方式 新增方式一：实现Callable接口。 — JDK 5.0新增 123456789101112131415161718192021222324252627282930313233343536373839//1.创建一个实现Callable的实现类class NumThread implements Callable&#123; //2.实现call方法，将此线程需要执行的操作声明在call()中 @Override public Object call() throws Exception &#123; int sum = 0; for (int i = 1; i &lt;= 100; i++) &#123; if(i % 2 == 0)&#123; System.out.println(i); sum += i; &#125; &#125; return sum; &#125;&#125;public class ThreadNew &#123; public static void main(String[] args) &#123; //3.创建Callable接口实现类的对象 NumThread numThread = new NumThread(); //4.将此Callable接口实现类的对象作为传递到FutureTask构造器中，创建FutureTask的对象 FutureTask futureTask = new FutureTask(numThread); //5.将FutureTask的对象作为参数传递到Thread类的构造器中，创建Thread对象，并调用start() new Thread(futureTask).start(); try &#123; //6.获取Callable中call方法的返回值 //get()返回值即为FutureTask构造器参数Callable实现类重写的call()的返回值。 Object sum = futureTask.get(); System.out.println(&quot;总和为：&quot; + sum); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; catch (ExecutionException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 说明：如何理解实现Callable接口的方式创建多线程比实现Runnable接口创建多线程方式强大？ call()可以返回值的。 call()可以抛出异常，被外面的操作捕获，获取异常的信息 Callable是支持泛型的 新增方式二：使用线程池 12345678910111213141516171819202122232425262728293031323334353637383940414243444546class NumberThread implements Runnable&#123; @Override public void run() &#123; for(int i = 0;i &lt;= 100;i++)&#123; if(i % 2 == 0)&#123; System.out.println(Thread.currentThread().getName() + &quot;: &quot; + i); &#125; &#125; &#125;&#125;class NumberThread1 implements Runnable&#123; @Override public void run() &#123; for(int i = 0;i &lt;= 100;i++)&#123; if(i % 2 != 0)&#123; System.out.println(Thread.currentThread().getName() + &quot;: &quot; + i); &#125; &#125; &#125;&#125;public class ThreadPool &#123; public static void main(String[] args) &#123; //1. 提供指定线程数量的线程池 ExecutorService service = Executors.newFixedThreadPool(10); ThreadPoolExecutor service1 = (ThreadPoolExecutor) service; //设置线程池的属性// System.out.println(service.getClass());// service1.setCorePoolSize(15);// service1.setKeepAliveTime(); //2.执行指定的线程的操作。需要提供实现Runnable接口或Callable接口实现类的对象 service.execute(new NumberThread());//适合适用于Runnable service.execute(new NumberThread1());//适合适用于Runnable// service.submit(Callable callable);//适合使用于Callable //3.关闭连接池 service.shutdown(); &#125;&#125; 说明：好处 提高响应速度（减少了创建新线程的时间） 降低资源消耗（重复利用线程池中线程，不需要每次都创建） 便于线程管理 corePoolSize：核心池的大小 maximumPoolSize：最大线程数 keepAliveTime：线程没任务时最多保持多长时间后会终止 面试题：Java中多线程的创建有几种方式？四种。 9_Java常用类String类java.lang.String类的使用 概述 String:字符串，使用一对””引起来表示。 String声明为final的，不可被继承 String实现了Serializable接口：表示字符串是支持序列化的。 实现了Comparable接口：表示String可以比较大小 String内部定义了final char[] value用于存储字符串数据 通过字面量的方式（区别于new给一个字符串赋值，此时的字符串值声明在字符串常量池中)。 字符串常量池中是不会存储相同内容(使用String类的equals()比较，返回true)的字符串的。 String的不可变性 说明 当对字符串重新赋值时，需要重写指定内存区域赋值，不能使用原有的value进行赋值。 当对现的字符串进行连接操作时，也需要重新指定内存区域赋值，不能使用原有的value进行赋值。 当调用String的replace()方法修改指定字符或字符串时，也需要重新指定内存区域赋值，不能使用原有的value进行赋值。 代码举例 12345678910111213141516171819202122String s1 = &quot;abc&quot;;//字面量的定义方式String s2 = &quot;abc&quot;;s1 = &quot;hello&quot;;System.out.println(s1 == s2);//比较s1和s2的地址值System.out.println(s1);//helloSystem.out.println(s2);//abcSystem.out.println(&quot;*****************&quot;);String s3 = &quot;abc&quot;;s3 += &quot;def&quot;;System.out.println(s3);//abcdefSystem.out.println(s2);System.out.println(&quot;*****************&quot;);String s4 = &quot;abc&quot;;String s5 = s4.replace(&#x27;a&#x27;, &#x27;m&#x27;);System.out.println(s4);//abcSystem.out.println(s5);//mbc 图示 String实例化的不同方式 方式说明 方式一：通过字面量定义的方式 方式二：通过new + 构造器的方式 代码举例 1234567891011//通过字面量定义的方式：此时的s1和s2的数据javaEE声明在方法区中的字符串常量池中。String s1 = &quot;javaEE&quot;;String s2 = &quot;javaEE&quot;;//通过new + 构造器的方式:此时的s3和s4保存的地址值，是数据在堆空间中开辟空间以后对应的地址值。String s3 = new String(&quot;javaEE&quot;);String s4 = new String(&quot;javaEE&quot;);System.out.println(s1 == s2);//trueSystem.out.println(s1 == s3);//falseSystem.out.println(s1 == s4);//falseSystem.out.println(s3 == s4);//false 面试题：String s = new String(“abc”);方式创建对象，在内存中创建了几个对象？ 答案：两个:一个是堆空间中new结构，另一个是char[]对应的常量池中的数据：”abc” 图示 字符串拼接方式赋值的对比 说明 常量与常量的拼接结果在常量池。且常量池中不会存在相同内容的常量。 只要其中一个是变量，结果就在堆中。 如果拼接的结果调用intern()方法，返回值就在常量池中 代码举例 1234567891011121314151617181920212223242526272829String s1 = &quot;javaEE&quot;;String s2 = &quot;hadoop&quot;;String s3 = &quot;javaEEhadoop&quot;;String s4 = &quot;javaEE&quot; + &quot;hadoop&quot;;String s5 = s1 + &quot;hadoop&quot;;String s6 = &quot;javaEE&quot; + s2;String s7 = s1 + s2;System.out.println(s3 == s4);//trueSystem.out.println(s3 == s5);//falseSystem.out.println(s3 == s6);//falseSystem.out.println(s3 == s7);//falseSystem.out.println(s5 == s6);//falseSystem.out.println(s5 == s7);//falseSystem.out.println(s6 == s7);//falseString s8 = s6.intern();//返回值得到的s8使用的常量值中已经存在的“javaEEhadoop”System.out.println(s3 == s8);//true****************************String s1 = &quot;javaEEhadoop&quot;;String s2 = &quot;javaEE&quot;;String s3 = s2 + &quot;hadoop&quot;;System.out.println(s1 == s3);//falsefinal String s4 = &quot;javaEE&quot;;//s4:常量String s5 = s4 + &quot;hadoop&quot;;System.out.println(s1 == s5);//true 常用方法： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546int length()：返回字符串的长度： return value.lengthchar charAt(int index)： 返回某索引处的字符return value[index]boolean isEmpty()：判断是否是空字符串：return value.length == 0String toLowerCase()：使用默认语言环境，将 String 中的所字符转换为小写String toUpperCase()：使用默认语言环境，将 String 中的所字符转换为大写String trim()：返回字符串的副本，忽略前导空白和尾部空白boolean equals(Object obj)：比较字符串的内容是否相同boolean equalsIgnoreCase(String anotherString)：与equals方法类似，忽略大小写String concat(String str)：将指定字符串连接到此字符串的结尾。 等价于用“+”int compareTo(String anotherString)：比较两个字符串的大小String substring(int beginIndex)： 返回一个新的字符串，它是此字符串的从beginIndex开始截取到最后的一个子字符串。String substring(int beginIndex, int endIndex) ： 返回一个新字符串，它是此字符串从beginIndex开始截取到endIndex(不包含)的一个子字符串。boolean endsWith(String suffix)：测试此字符串是否以指定的后缀结束boolean startsWith(String prefix)：测试此字符串是否以指定的前缀开始boolean startsWith(String prefix, int toffset)： 测试此字符串从指定索引开始的子字符串是否以指定前缀开始boolean contains(CharSequence s)：当且仅当此字符串包含指定的 char 值序列时，返回 trueint indexOf(String str)：返回指定子字符串在此字符串中第一次出现处的索引int indexOf(String str, int fromIndex)： 返回指定子字符串在此字符串中第一次出现处的索引，从指定的索引开始int lastIndexOf(String str)：返回指定子字符串在此字符串中最右边出现处的索引int lastIndexOf(String str, int fromIndex)： 返回指定子字符串在此字符串中最后一次出现处的索引，从指定的索引开始反向搜索注：indexOf和lastIndexOf方法如果未找到都是返回-1替换：String replace(char oldChar, char newChar)： 返回一个新的字符串，它是通过用 newChar 替换此字符串中出现的所 oldChar 得到的。String replace(CharSequence target, CharSequence replacement)： 使用指定的字面值替换序列替换此字符串所匹配字面值目标序列的子字符串。String replaceAll(String regex, String replacement)： 使用给定的 replacement 替换此字符串所匹配给定的正则表达式的子字符串。String replaceFirst(String regex, String replacement)： 使用给定的 replacement 替换此字符串匹配给定的正则表达式的第一个子字符串。匹配:boolean matches(String regex)：告知此字符串是否匹配给定的正则表达式。切片：String[] split(String regex)：根据给定正则表达式的匹配拆分此字符串。String[] split(String regex, int limit)：根据匹配给定的正则表达式来拆分此字符串， 最多不超过limit个，如果超过了，剩下的全部都放到最后一个元素中。 String与其它结构的转换 与基本数据类型、包装类之间的转换 String –&gt; 基本数据类型、包装类：调用包装类的静态方法：parseXxx(str) 基本数据类型、包装类 –&gt; String:调用String重载的valueOf(xxx) 123456789101112 @Test public void test1()&#123; String str1 = &quot;123&quot;;// int num = (int)str1;//错误的 int num = Integer.parseInt(str1); String str2 = String.valueOf(num);//&quot;123&quot; String str3 = num + &quot;&quot;; System.out.println(str1 == str3); &#125; 与字符数组之间的转换 String –&gt; char[]:调用String的toCharArray() char[] –&gt; String:调用String的构造器 1234567891011121314@Testpublic void test2()&#123; String str1 = &quot;abc123&quot;; //题目： a21cb3 char[] charArray = str1.toCharArray(); for (int i = 0; i &lt; charArray.length; i++) &#123; System.out.println(charArray[i]); &#125; char[] arr = new char[]&#123;&#x27;h&#x27;,&#x27;e&#x27;,&#x27;l&#x27;,&#x27;l&#x27;,&#x27;o&#x27;&#125;; String str2 = new String(arr); System.out.println(str2);&#125; 与字节数组之间的转换 编码：String –&gt; byte[]:调用String的getBytes() 解码：byte[] –&gt; String:调用String的构造器 编码：字符串 –&gt;字节 (看得懂 —&gt;看不懂的二进制数据) 解码：编码的逆过程，字节 –&gt; 字符串 （看不懂的二进制数据 —&gt; 看得懂 说明：解码时，要求解码使用的字符集必须与编码时使用的字符集一致，否则会出现乱码。 123456789101112131415161718192021@Testpublic void test3() throws UnsupportedEncodingException &#123; String str1 = &quot;abc123中国&quot;; byte[] bytes = str1.getBytes();//使用默认的字符集，进行编码。 System.out.println(Arrays.toString(bytes)); byte[] gbks = str1.getBytes(&quot;gbk&quot;);//使用gbk字符集进行编码。 System.out.println(Arrays.toString(gbks)); System.out.println(&quot;******************&quot;); String str2 = new String(bytes);//使用默认的字符集，进行解码。 System.out.println(str2); String str3 = new String(gbks); System.out.println(str3);//出现乱码。原因：编码集和解码集不一致！ String str4 = new String(gbks, &quot;gbk&quot;); System.out.println(str4);//没出现乱码。原因：编码集和解码集一致！&#125; 与StringBuffer、StringBuilder之间的转换 String –&gt;StringBuffer、StringBuilder:调用StringBuffer、StringBuilder构造器 StringBuffer、StringBuilder –&gt;String:①调用String构造器；②StringBuffer、StringBuilder的toString() JVM中字符串常量池存放位置说明： jdk 1.6 (jdk 6.0 ,java 6.0):字符串常量池存储在方法区（永久区） jdk 1.7:字符串常量池存储在堆空间 jdk 1.8:字符串常量池存储在方法区（元空间） 常见算法题目的考查： 模拟一个trim方法，去除字符串两端的空格。 将一个字符串进行反转。将字符串中指定部分进行反转。比如“abcdefg”反转为”abfedcg” 获取一个字符串在另一个字符串中出现的次数。 比如：获取“ ab”在 “abkkcadkabkebfkabkskab” 中出现的次数 获取两个字符串中最大相同子串。比如： str1 = “abcwerthelloyuiodef“;str2 = “cvhellobnm” 提示：将短的那个串进行长度依次递减的子串与较长的串比较。 对字符串中字符进行自然顺序排序。 提示： 字符串变成字符数组。 对数组排序，择，冒泡，Arrays.sort(); 将排序后的数组变成字符串。 StringBuffer、StringBuilder String、StringBuffer、StringBuilder三者的对比 String:不可变的字符序列；底层使用char[]存储 StringBuffer:可变的字符序列；线程安全的，效率低；底层使用char[]存储 StringBuilder:可变的字符序列；jdk5.0新增的，线程不安全的，效率高；底层使用char[]存储 StringBuffer与StringBuilder的内存解析 以StringBuffer为例： 123456789101112131415161718String str = new String();//char[] value = new char[0];String str1 = new String(&quot;abc&quot;);//char[] value = new char[]&#123;&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;&#125;;StringBuffer sb1 = new StringBuffer();//char[] value = new char[16];底层创建了一个长度是16的数组。System.out.println(sb1.length());//sb1.append(&#x27;a&#x27;);//value[0] = &#x27;a&#x27;;sb1.append(&#x27;b&#x27;);//value[1] = &#x27;b&#x27;;StringBuffer sb2 = new StringBuffer(&quot;abc&quot;);//char[] value = new char[&quot;abc&quot;.length() + 16];//问题1. System.out.println(sb2.length());//3//问题2. 扩容问题:如果要添加的数据底层数组盛不下了，那就需要扩容底层的数组。 默认情况下，扩容为原来容量的2倍 + 2，同时将原数组中的元素复制到新的数组中。指导意义：开发中建议大家使用：StringBuffer(int capacity) 或 StringBuilder(int capacity) 对比String、StringBuffer、StringBuilder三者的执行效率 从高到低排列：StringBuilder &gt; StringBuffer &gt; String StringBuffer、StringBuilder中的常用方法 增：append(xxx) 删：delete(int start,int end) 改：setCharAt(int n ,char ch) / replace(int start, int end, String str) 查：charAt(int n ) 插：insert(int offset, xxx) 长度：length(); 遍历：for() + charAt() / toString() JDK 8之前日期时间API 获取系统当前时间：System类中的currentTimeMillis() 1234long time = System.currentTimeMillis();//返回当前时间与1970年1月1日0时0分0秒之间以毫秒为单位的时间差。//称为时间戳System.out.println(time); java.util.Date类与java.sql.Date类 java.util.Date类 ​ |—java.sql.Date类 两个构造器的使用 构造器一：Date()：创建一个对应当前时间的Date对象 构造器二：创建指定毫秒数的Date对象 两个方法的使用 toString():显示当前的年、月、日、时、分、秒 getTime():获取当前Date对象对应的毫秒数。（时间戳） java.sql.Date对应着数据库中的日期类型的变量 如何实例化 如何将java.util.Date对象转换为java.sql.Date对象 1234567891011121314151617181920212223242526 @Test public void test2()&#123; //构造器一：Date()：创建一个对应当前时间的Date对象 Date date1 = new Date(); System.out.println(date1.toString());//Sat Feb 16 16:35:31 GMT+08:00 2019 System.out.println(date1.getTime());//1550306204104 //构造器二：创建指定毫秒数的Date对象 Date date2 = new Date(155030620410L); System.out.println(date2.toString()); //创建java.sql.Date对象 java.sql.Date date3 = new java.sql.Date(35235325345L); System.out.println(date3);//1971-02-13 //如何将java.util.Date对象转换为java.sql.Date对象 //情况一：// Date date4 = new java.sql.Date(2343243242323L);// java.sql.Date date5 = (java.sql.Date) date4; //情况二： Date date6 = new Date(); java.sql.Date date7 = new java.sql.Date(date6.getTime()); &#125; java.text.SimpleDataFormat类 SimpleDateFormat对日期Date类的格式化和解析 两个操作： 格式化：日期 —&gt;字符串 解析：格式化的逆过程，字符串 —&gt; 日期 SimpleDateFormat的实例化:new + 构造器 1234567891011/*************照指定的方式格式化和解析：调用带参的构造器*****************// SimpleDateFormat sdf1 = new SimpleDateFormat(&quot;yyyyy.MMMMM.dd GGG hh:mm aaa&quot;); SimpleDateFormat sdf1 = new SimpleDateFormat(&quot;yyyy-MM-dd hh:mm:ss&quot;); //格式化 String format1 = sdf1.format(date); System.out.println(format1);//2019-02-18 11:48:27 //解析:要求字符串必须是符合SimpleDateFormat识别的格式(通过构造器参数体现), //否则，抛异常 Date date2 = sdf1.parse(&quot;2020-02-18 11:48:27&quot;); System.out.println(date2); 小练习： 12345678910111213141516171819202122232425/* 练习一：字符串&quot;2020-09-08&quot;转换为java.sql.Date 练习二：&quot;天打渔两天晒网&quot; 1990-01-01 xxxx-xx-xx 打渔？晒网？ 举例：2020-09-08 ？ 总天数 总天数 % 5 == 1,2,3 : 打渔 总天数 % 5 == 4,0 : 晒网 总天数的计算？ 方式一：( date2.getTime() - date1.getTime()) / (1000 * 60 * 60 * 24) + 1 方式二：1990-01-01 --&gt; 2019-12-31 + 2020-01-01 --&gt;2020-09-08 */ @Test public void testExer() throws ParseException &#123; String birth = &quot;2020-09-08&quot;; SimpleDateFormat sdf1 = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;); Date date = sdf1.parse(birth);// System.out.println(date); java.sql.Date birthDate = new java.sql.Date(date.getTime()); System.out.println(birthDate); &#125; Calendar类：日历类、抽象类 12345678910111213141516171819202122232425262728293031323334 //1.实例化 //方式一：创建其子类（GregorianCalendar的对象 //方式二：调用其静态方法getInstance() Calendar calendar = Calendar.getInstance();// System.out.println(calendar.getClass()); //2.常用方法 //get() int days = calendar.get(Calendar.DAY_OF_MONTH); System.out.println(days); System.out.println(calendar.get(Calendar.DAY_OF_YEAR)); //set() //calendar可变性 calendar.set(Calendar.DAY_OF_MONTH,22); days = calendar.get(Calendar.DAY_OF_MONTH); System.out.println(days); //add() calendar.add(Calendar.DAY_OF_MONTH,-3); days = calendar.get(Calendar.DAY_OF_MONTH); System.out.println(days); //getTime():日历类---&gt; Date Date date = calendar.getTime(); System.out.println(date); //setTime():Date ---&gt; 日历类 Date date1 = new Date(); calendar.setTime(date1); days = calendar.get(Calendar.DAY_OF_MONTH); System.out.println(days); JDK8中新日期时间API 日期时间API的迭代： 第一代：jdk 1.0 Date类 第二代：jdk 1.1 Calendar类，一定程度上替换Date类 第三代：jdk 1.8 提出了新的一套API 前两代存在的问题举例： 可变性：像日期和时间这样的类应该是不可变的。 偏移性：Date中的年份是从1900开始的，而月份都从0开始。 格式化：格式化只对Date用，Calendar则不行。 此外，它们也不是线程安全的；不能处理闰秒等。 java 8 中新的日期时间API涉及到的包 本地日期、本地时间、本地日期时间的使用：LocalDate / LocalTime / LocalDateTime 说明： 分别表示使用 ISO-8601日历系统的日期、时间、日期和时间。它们提供了简单的本地日期或时间，并不包含当前的时间信息，也不包含与时区相关的信息。 LocalDateTime相较于LocalDate、LocalTime，使用频率要高 类似于Calendar 常用方法： 时间点：Instant 说明： 时间线上的一个瞬时点。 概念上讲，它只是简单的表示自1970年1月1日0时0分0秒（UTC开始的秒数。） 类似于 java.util.Date类 常用方法： 日期时间格式化类：DateTimeFormatter 说明： 格式化或解析日期、时间 类似于SimpleDateFormat 常用方法： 预定义的标准格式。如：ISO_LOCAL_DATE_TIME;ISO_LOCAL_DATE;ISO_LOCAL_TIME 本地化相关的格式。如：ofLocalizedDateTime(FormatStyle.LONG) 自定义的格式。如：ofPattern(“yyyy-MM-dd hh:mm:ss”) 123456789// 重点：自定义的格式。如：ofPattern(“yyyy-MM-dd hh:mm:ss”)DateTimeFormatter formatter3 = DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd hh:mm:ss&quot;);//格式化String str4 = formatter3.format(LocalDateTime.now());System.out.println(str4);//2019-02-18 03:52:09//解析TemporalAccessor accessor = formatter3.parse(&quot;2019-02-18 03:52:09&quot;);System.out.println(accessor); 其它API的使用 （不讲） 带时区的日期时间：ZonedDateTime / ZoneId举例： 1234567891011121314151617181920212223242526// ZoneId:类中包含了所的时区信息 @Test public void test1()&#123; //getAvailableZoneIds():获取所的ZoneId Set&lt;String&gt; zoneIds = ZoneId.getAvailableZoneIds(); for(String s : zoneIds)&#123; System.out.println(s); &#125; System.out.println(); //获取“Asia/Tokyo”时区对应的时间 LocalDateTime localDateTime = LocalDateTime.now(ZoneId.of(&quot;Asia/Tokyo&quot;)); System.out.println(localDateTime); &#125;//ZonedDateTime:带时区的日期时间 @Test public void test2()&#123; //now():获取本时区的ZonedDateTime对象 ZonedDateTime zonedDateTime = ZonedDateTime.now(); System.out.println(zonedDateTime); //now(ZoneId id):获取指定时区的ZonedDateTime对象 ZonedDateTime zonedDateTime1 = ZonedDateTime.now(ZoneId.of(&quot;Asia/Tokyo&quot;)); System.out.println(zonedDateTime1); &#125; 时间间隔：Duration–用于计算两个“时间”间隔，以秒和纳秒为基准 举例： 123456789101112131415161718@Testpublic void test3()&#123; LocalTime localTime = LocalTime.now(); LocalTime localTime1 = LocalTime.of(15, 23, 32); //between():静态方法，返回Duration对象，表示两个时间的间隔 Duration duration = Duration.between(localTime1, localTime); System.out.println(duration); System.out.println(duration.getSeconds()); System.out.println(duration.getNano()); LocalDateTime localDateTime = LocalDateTime.of(2016, 6, 12, 15, 23, 32); LocalDateTime localDateTime1 = LocalDateTime.of(2017, 6, 12, 15, 23, 32); Duration duration1 = Duration.between(localDateTime1, localDateTime); System.out.println(duration1.toDays()); &#125; 日期间隔：Period –用于计算两个“日期”间隔，以年、月、日衡量 举例： 12345678910111213141516@Testpublic void test4()&#123; LocalDate localDate = LocalDate.now(); LocalDate localDate1 = LocalDate.of(2028, 3, 18); Period period = Period.between(localDate, localDate1); System.out.println(period); System.out.println(period.getYears()); System.out.println(period.getMonths()); System.out.println(period.getDays()); Period period1 = period.withYears(2); System.out.println(period1); &#125; 日期时间校正器：TemporalAdjuster举例： 12345678910111213141516171819202122232425262728@Testpublic void test5()&#123; //获取当前日期的下一个周日是哪天？ TemporalAdjuster temporalAdjuster = TemporalAdjusters.next(DayOfWeek.SUNDAY); LocalDateTime localDateTime = LocalDateTime.now().with(temporalAdjuster); System.out.println(localDateTime); //获取下一个工作日是哪天？ LocalDate localDate = LocalDate.now().with(new TemporalAdjuster()&#123; @Override public Temporal adjustInto(Temporal temporal) &#123; LocalDate date = (LocalDate)temporal; if(date.getDayOfWeek().equals(DayOfWeek.FRIDAY))&#123; return date.plusDays(3); &#125;else if(date.getDayOfWeek().equals(DayOfWeek.SATURDAY))&#123; return date.plusDays(2); &#125;else&#123; return date.plusDays(1); &#125; &#125; &#125;); System.out.println(&quot;下一个工作日是：&quot; + localDate);&#125; Java比较器 Java比较器的使用背景： Java中的对象，正常情况下，只能进行比较：== 或 != 。不能使用 &gt; 或 &lt; 的但是在开发场景中，我们需要对多个对象进行排序，言外之意，就需要比较对象的大小。 如何实现？使用两个接口中的任何一个：Comparable 或 Comparator 自然排序：使用Comparable接口 说明 像String、包装类等实现了Comparable接口，重写了compareTo(obj)方法，给出了比较两个对象大小的方式。 像String、包装类重写compareTo()方法以后，进行了从小到大的排列 重写compareTo(obj)的规则： 如果当前对象this大于形参对象obj，则返回正整数， 如果当前对象this小于形参对象obj，则返回负整数， 如果当前对象this等于形参对象obj，则返回零。 对于自定义类来说，如果需要排序，我们可以让自定义类实现Comparable接口，重写compareTo(obj)方法。在compareTo(obj)方法中指明如何排序 自定义类代码举例： 1234567891011121314151617181920212223242526272829public class Goods implements Comparable&#123; private String name; private double price; //指明商品比较大小的方式:照价格从低到高排序,再照产品名称从高到低排序 @Override public int compareTo(Object o) &#123;// System.out.println(&quot;**************&quot;); if(o instanceof Goods)&#123; Goods goods = (Goods)o; //方式一： if(this.price &gt; goods.price)&#123; return 1; &#125;else if(this.price &lt; goods.price)&#123; return -1; &#125;else&#123;// return 0; return -this.name.compareTo(goods.name); &#125; //方式二：// return Double.compare(this.price,goods.price); &#125;// return 0; throw new RuntimeException(&quot;传入的数据类型不一致！&quot;); &#125;// getter、setter、toString()、构造器：省略&#125; 定制排序：使用Comparator接口 说明 背景：当元素的类型没实现java.lang.Comparable接口而又不方便修改代码，或者实现了java.lang.Comparable接口的排序规则不适合当前的操作，那么可以考虑使用 Comparator 的对象来排序 重写compare(Object o1,Object o2)方法，比较o1和o2的大小： 如果方法返回正整数，则表示o1大于o2； 如果返回0，表示相等； 返回负整数，表示o1小于o2。 代码举例： 123456789101112131415161718192021Comparator com = new Comparator() &#123; //指明商品比较大小的方式:照产品名称从低到高排序,再照价格从高到低排序 @Override public int compare(Object o1, Object o2) &#123; if(o1 instanceof Goods &amp;&amp; o2 instanceof Goods)&#123; Goods g1 = (Goods)o1; Goods g2 = (Goods)o2; if(g1.getName().equals(g2.getName()))&#123; return -Double.compare(g1.getPrice(),g2.getPrice()); &#125;else&#123; return g1.getName().compareTo(g2.getName()); &#125; &#125; throw new RuntimeException(&quot;输入的数据类型不一致&quot;); &#125;&#125;使用：Arrays.sort(goods,com);Collections.sort(coll,com);new TreeSet(com); 两种排序方式对比 Comparable接口的方式一旦一定，保证Comparable接口实现类的对象在任何位置都可以比较大小。 Comparator接口属于临时性的比较。 其他类 System类 System类代表系统，系统级的很多属性和控制方法都放置在该类的内部。该类位于java.lang包。 由于该类的构造器是private的，所以无法创建该类的对象，也就是无法实例化该类。其内部的成员变量和成员方法都是static的，所以也可以很方便的进行调用。 方法： native long currentTimeMillis() void exit(int status) void gc() String getProperty(String key) Math类：java.lang.Math提供了一系列静态方法用于科学计算。其方法的参数和返回值类型一般为double型。 BigInteger类、BigDecimal类 说明： java.math包的BigInteger可以表示不可变的任意精度的整数。 要求数字精度比较高，用到java.math.BigDecimal类 代码举例： 10_枚举类和注解枚举类的使用 枚举类的说明： 枚举类的理解：类的对象只有有限个，确定的。我们称此类为枚举类 当需要定义一组常量时，强烈建议使用枚举类 如果枚举类中只一个对象，则可以作为单例模式的实现方式。 如何自定义枚举类？步骤： 123456789101112131415161718192021222324252627282930313233343536//自定义枚举类class Season&#123; //1.声明Season对象的属性:private final修饰 private final String seasonName; private final String seasonDesc; //2.私化类的构造器,并给对象属性赋值 private Season(String seasonName,String seasonDesc)&#123; this.seasonName = seasonName; this.seasonDesc = seasonDesc; &#125; //3.提供当前枚举类的多个对象：public static final的 public static final Season SPRING = new Season(&quot;春天&quot;,&quot;春暖花开&quot;); public static final Season SUMMER = new Season(&quot;夏天&quot;,&quot;夏日炎炎&quot;); public static final Season AUTUMN = new Season(&quot;秋天&quot;,&quot;秋高气爽&quot;); public static final Season WINTER = new Season(&quot;冬天&quot;,&quot;冰天雪地&quot;); //4.其他诉求1：获取枚举类对象的属性 public String getSeasonName() &#123; return seasonName; &#125; public String getSeasonDesc() &#123; return seasonDesc; &#125; //4.其他诉求1：提供toString() @Override public String toString() &#123; return &quot;Season&#123;&quot; + &quot;seasonName=&#x27;&quot; + seasonName + &#x27;\\&#x27;&#x27; + &quot;, seasonDesc=&#x27;&quot; + seasonDesc + &#x27;\\&#x27;&#x27; + &#x27;&#125;&#x27;; &#125;&#125; jdk 5.0 新增使用enum定义枚举类。步骤： 1234567891011121314151617181920212223242526272829//使用enum关键字枚举类enum Season1 &#123; //1.提供当前枚举类的对象，多个对象之间用&quot;,&quot;隔开，末尾对象&quot;;&quot;结束 SPRING(&quot;春天&quot;,&quot;春暖花开&quot;), SUMMER(&quot;夏天&quot;,&quot;夏日炎炎&quot;), AUTUMN(&quot;秋天&quot;,&quot;秋高气爽&quot;), WINTER(&quot;冬天&quot;,&quot;冰天雪地&quot;); //2.声明Season对象的属性:private final修饰 private final String seasonName; private final String seasonDesc; //2.私化类的构造器,并给对象属性赋值 private Season1(String seasonName,String seasonDesc)&#123; this.seasonName = seasonName; this.seasonDesc = seasonDesc; &#125; //4.其他诉求1：获取枚举类对象的属性 public String getSeasonName() &#123; return seasonName; &#125; public String getSeasonDesc() &#123; return seasonDesc; &#125;&#125; 使用enum定义枚举类之后，枚举类常用方法：（继承于java.lang.Enum类） 12345678910111213141516171819202122Season1 summer = Season1.SUMMER; //toString():返回枚举类对象的名称 System.out.println(summer.toString());// System.out.println(Season1.class.getSuperclass()); System.out.println(&quot;****************&quot;); //values():返回所的枚举类对象构成的数组 Season1[] values = Season1.values(); for(int i = 0;i &lt; values.length;i++)&#123; System.out.println(values[i]); &#125; System.out.println(&quot;****************&quot;); Thread.State[] values1 = Thread.State.values(); for (int i = 0; i &lt; values1.length; i++) &#123; System.out.println(values1[i]); &#125; //valueOf(String objName):返回枚举类中对象名是objName的对象。 Season1 winter = Season1.valueOf(&quot;WINTER&quot;); //如果没objName的枚举类对象，则抛异常：IllegalArgumentException// Season1 winter = Season1.valueOf(&quot;WINTER1&quot;); System.out.println(winter); 使用enum定义枚举类之后，如何让枚举类对象分别实现接口： 123456789101112131415161718192021222324252627282930313233interface Info&#123; void show();&#125;//使用enum关键字枚举类enum Season1 implements Info&#123; //1.提供当前枚举类的对象，多个对象之间用&quot;,&quot;隔开，末尾对象&quot;;&quot;结束 SPRING(&quot;春天&quot;,&quot;春暖花开&quot;)&#123; @Override public void show() &#123; System.out.println(&quot;春天在哪里？&quot;); &#125; &#125;, SUMMER(&quot;夏天&quot;,&quot;夏日炎炎&quot;)&#123; @Override public void show() &#123; System.out.println(&quot;宁夏&quot;); &#125; &#125;, AUTUMN(&quot;秋天&quot;,&quot;秋高气爽&quot;)&#123; @Override public void show() &#123; System.out.println(&quot;秋天不回来&quot;); &#125; &#125;, WINTER(&quot;冬天&quot;,&quot;冰天雪地&quot;)&#123; @Override public void show() &#123; System.out.println(&quot;大约在冬季&quot;); &#125; &#125;;&#125; 注解的使用 注解的理解 jdk 5.0 新增的功能 Annotation 其实就是代码里的特殊标记, 这些标记可以在编译, 类加载, 运行时被读取, 并执行相应的处理。通过使用 Annotation,程序员可以在不改变原逻辑的情况下, 在源文件中嵌入一些补充信息。 在JavaSE中，注解的使用目的比较简单，例如标记过时的功能，忽略警告等。在JavaEE/Android中注解占据了更重要的角色，例如用来配置应用程序的任何切面，代替JavaEE旧版中所遗留的繁冗代码和XML配置等。 框架 = 注解 + 反射机制 + 设计模式 注解的使用示例 示例一：生成文档相关的注解 示例二：在编译时进行格式检查(JDK内置的个基本注解) @Override: 限定重写父类方法, 该注解只能用于方法 @Deprecated: 用于表示所修饰的元素(类, 方法等)已过时。通常是因为所修饰的结构危险或存在更好的择 @SuppressWarnings: 抑制编译器警告 示例三：跟踪代码依赖性，实现替代配置文件功能 如何自定义注解：参照@SuppressWarnings定义 注解声明为：@interface 内部定义成员，通常使用value表示 可以指定成员的默认值，使用default定义 如果自定义注解没成员，表明是一个标识作用。 说明： 如果注解有成员，在使用注解时，需要指明成员的值。 自定义注解必须配上注解的信息处理流程(使用反射)才意义。 自定义注解通过都会指明两个元注解：Retention、Target 代码举例： 12345678@Inherited@Repeatable(MyAnnotations.class)@Retention(RetentionPolicy.RUNTIME)@Target(&#123;TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE,TYPE_PARAMETER,TYPE_USE&#125;)public @interface MyAnnotation &#123; String value() default &quot;hello&quot;;&#125; 元注解 ：对现有的注解进行解释说明的注解。 jdk 提供的4种元注解： Retention：指定所修饰的 Annotation 的生命周期：SOURCE\\CLASS（默认行为\\RUNTIME 只声明为RUNTIME生命周期的注解，才能通过反射获取。 Target:用于指定被修饰的 Annotation 能用于修饰哪些程序元素 出现的频率较低 Documented:表示所修饰的注解在被javadoc解析时，保留下来。 Inherited:被它修饰的 Annotation 将具继承性。 —&gt;类比：元数据的概念：String name = “Tom”; 如何获取注解信息:通过发射来进行获取、调用。 前提：要求此注解的元注解Retention中声明的生命周期状态为：RUNTIME. JDK8中注解的新特性：可重复注解、类型注解 可重复注解： 在MyAnnotation上声明@Repeatable，成员值为MyAnnotations.class MyAnnotation的Target和Retention等元注解与MyAnnotations相同。 类型注解： ElementType.TYPE_PARAMETER 表示该注解能写在类型变量的声明语句中（如：泛型声明。 ElementType.TYPE_USE 表示该注解能写在使用类型的任何语句中。 11_Java集合数组与集合 集合与数组存储数据概述： 集合、数组都是对多个数据进行存储操作的结构，简称Java容器。 说明：此时的存储，主要指的是内存层面的存储，不涉及到持久化的存储（.txt,.jpg,.avi，数据库中) 数组存储的特点： 一旦初始化以后，其长度就确定了。 数组一旦定义好，其元素的类型也就确定了。我们也就只能操作指定类型的数据了。 比如：String[] arr;int[] arr1;Object[] arr2; 数组存储的弊端： 一旦初始化以后，其长度就不可修改。 数组中提供的方法非常限，对于添加、删除、插入数据等操作，非常不便，同时效率不高。 获取数组中实际元素的个数的需求，数组没有现成的属性或方法可用 数组存储数据的特点：有序、可重复。对于无序、不可重复的需求，不能满足。 集合存储的优点：解决数组存储数据方面的弊端。 Collection接口 单列集合框架结构 123456|----Collection接口：单列集合，用来存储一个一个的对象* |----List接口：存储序的、可重复的数据。 --&gt;“动态”数组* |----ArrayList、LinkedList、Vector** |----Set接口：存储无序的、不可重复的数据 --&gt;高中讲的“集合”* |----HashSet、LinkedHashSet、TreeSet 对应图示： Collection接口常用方法： 123add(Object obj),addAll(Collection coll),size(),isEmpty(),clear();contains(Object obj),containsAll(Collection coll),remove(Object obj),removeAll(Collection coll),retainsAll(Collection coll),equals(Object obj);hasCode(),toArray(),iterator(); Collection集合与数组间的转换 123456789101112131415//集合 ---&gt;数组：toArray()Object[] arr = coll.toArray();for(int i = 0;i &lt; arr.length;i++)&#123; System.out.println(arr[i]);&#125;//拓展：数组 ---&gt;集合:调用Arrays类的静态方法asList(T ... t)List&lt;String&gt; list = Arrays.asList(new String[]&#123;&quot;AA&quot;, &quot;BB&quot;, &quot;CC&quot;&#125;);System.out.println(list);List arr1 = Arrays.asList(new int[]&#123;123, 456&#125;);System.out.println(arr1.size());//1List arr2 = Arrays.asList(new Integer[]&#123;123, 456&#125;);System.out.println(arr2.size());//2 使用Collection集合存储对象，要求对象所属的类满足：向Collection接口的实现类的对象中添加数据obj时，要求obj所在类要重写equals(). 本章节对大家的要求： 层次一：选择合适的集合类去实现数据的保存，调用其内部的相关方法。 层次二：不同的集合类底层的数据结构为何？如何实现数据的操作的：增删改查等。 Iterator接口与foreach循环 遍历Collection的两种方式： 使用迭代器Iterator foreach循环（或增强for循环） java.utils包下定义的迭代器接口：Iterator 说明： Iterator对象称为迭代器(设计模式的一种)，主要用于遍历 Collection 集合中的元素。 GOF给迭代器模式的定义为：提供一种方法访问一个容器(container)对象中各个元素，而又不需暴露该对象的内部细节。迭代器模式，就是为容器而生。 作用：遍历集合Collectiton元素 如何获取实例：coll.iterator()返回一个迭代器实例 遍历的代码实现： 1234567Iterator iterator = coll.iterator();//hasNext():判断是否还下一个元素while(iterator.hasNext())&#123; //next():①指针下移 ②将下移以后集合位置上的元素返回 System.out.println(iterator.next());&#125; 图示说明： remove()的使用： 1234567891011121314151617181920212223242526272829//测试Iterator中的remove()//如果还未调用next()或在上一次调用 next 方法之后已经调用了 remove 方法，再调用remove都会报IllegalStateException。//内部定义了remove(),可以在遍历的时候，删除集合中的元素。此方法不同于集合直接调用remove() @Test public void test3()&#123; Collection coll = new ArrayList(); coll.add(123); coll.add(456); coll.add(new Person(&quot;Jerry&quot;,20)); coll.add(new String(&quot;Tom&quot;)); coll.add(false); //删除集合中&quot;Tom&quot; Iterator iterator = coll.iterator(); while (iterator.hasNext())&#123;// iterator.remove(); Object obj = iterator.next(); if(&quot;Tom&quot;.equals(obj))&#123; iterator.remove();// iterator.remove(); &#125; &#125; //遍历集合 iterator = coll.iterator(); while (iterator.hasNext())&#123; System.out.println(iterator.next()); &#125; &#125; jdk5.0新特性–增强for循环：(foreach循环) 遍历集合举例： 123456789101112131415@Testpublic void test1()&#123; Collection coll = new ArrayList(); coll.add(123); coll.add(456); coll.add(new Person(&quot;Jerry&quot;,20)); coll.add(new String(&quot;Tom&quot;)); coll.add(false); //for(集合元素的类型 局部变量 : 集合对象) for(Object obj : coll)&#123; System.out.println(obj); &#125;&#125; 说明：内部仍然调用了迭代器。 遍历数组举例： 12345678@Testpublic void test2()&#123; int[] arr = new int[]&#123;1,2,3,4,5,6&#125;; //for(数组元素的类型 局部变量 : 数组对象) for(int i : arr)&#123; System.out.println(i); &#125;&#125; Collection子接口：List接口 存储的数据特点：存储序的、可重复的数据。 常用方法：(记住) 123456789增：add(Object obj)删：remove(int index) / remove(Object obj)改：set(int index, Object ele)查：get(int index)插：add(int index, Object ele)长度：size()遍历：① Iterator迭代器方式 ② 增强for循环 ③ 普通的循环 常用实现类： 12345|----Collection接口：单列集合，用来存储一个一个的对象 |----List接口：存储序的、可重复的数据。 --&gt;“动态”数组,替换原的数组 |----ArrayList：作为List接口的主要实现类；线程不安全，效率高；底层使用Object[]elementData存储 |----LinkedList：对于频繁的插入、删除操作，使用此类效率比ArrayList高；底层使用双向链表存储 |----Vector：作为List接口的古老实现类；线程安全的，效率低；底层使用Object[] elementData存储 源码分析(难点) ArrayList的源码分析： jdk 7情况下 1234567ArrayList list = new ArrayList();//底层创建了长度是10的Object[]数组elementDatalist.add(123);//elementData[0] = new Integer(123); ...list.add(11);//如果此次的添加导致底层elementData数组容量不够，则扩容。默认情况下，扩容为原来的容量的1.5倍，同时需要将原有数组中的数据复制到新的数组中。*结论：建议开发中使用带参的构造器：ArrayList list = new ArrayList(int capacity) jdk 8中ArrayList的变化： 12345ArrayList list = new ArrayList();//底层Object[] elementData初始化为&#123;&#125;.并没创建长度为10的数组*list.add(123);//第一次调用add()时，底层才创建了长度10的数组，并将数据123添加到elementData[0]* ...后续的添加和扩容操作与jdk 7 无异。 小结： jdk7中的ArrayList的对象的创建类似于单例的饿汉式 jdk8中的ArrayList的对象的创建类似于单例的懒汉式，延迟了数组的创建，节省内存。 LinkedList的源码分析： 123456789101112131415LinkedList list = new LinkedList(); 内部声明了Node类型的first和last属性，默认值为nulllist.add(123);//将123封装到Node中，创建了Node对象。其中，Node定义为：体现了LinkedList的双向链表的说法private static class Node&lt;E&gt; &#123; E item; Node&lt;E&gt; next; Node&lt;E&gt; prev; Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123; this.item = element; this.next = next; his.prev = prev; &#125;&#125; Vector的源码分析： jdk7和jdk8中通过Vector()构造器创建对象时，底层都创建了长度为10的数组。在扩容方面，默认扩容为原来的数组长度的2倍。 存储的元素的要求：添加的对象，所在的类要重写equals()方法 [面试题]ArrayList、LinkedList、Vector者的异同？ 同：三个类都是实现了List接口，存储数据的特点相同：存储序的、可重复的数据 不同：见上 Collection子接口：Set接口 存储的数据特点：无序的、不可重复的元素 具体的：以HashSet为例说明： 无序性：不等于随机性。存储的数据在底层数组中并非照数组索引的顺序添加，而是根据数据的哈希值决定的。 不可重复性：保证添加的元素照equals()判断时，不能返回true.即：相同的元素只能添加一个。 元素添加过程：(以HashSet为例) 12345678910111213141516我们向HashSet中添加元素a,首先调用元素a所在类的hashCode()方法，计算元素a的哈希值，此哈希值接着通过某种算法计算出在HashSet底层数组中的存放位置（即为：索引位置，判断数组此位置上是否已经元素： 如果此位置上没其他元素，则元素a添加成功。 ---&gt;情况1 如果此位置上其他元素b(或以链表形式存在的多个元素，则比较元素a与元素b的hash值： 如果hash值不相同，则元素a添加成功。---&gt;情况2 如果hash值相同，进而需要调用元素a所在类的equals()方法： equals()返回true,元素a添加失败 equals()返回false,则元素a添加成功。---&gt;情况3对于添加成功的情况2和情况3而言：元素a 与已经存在指定索引位置上数据以链表的方式存储。jdk 7 :元素a放到数组中，指向原来的元素。jdk 8 :原来的元素在数组中，指向元素a总结：七上八下HashSet底层：数组+链表的结构。（前提：jdk7) 常用方法：Set接口中没额外定义新的方法，使用的都是Collection中声明过的方法。 常用实现类： 123456|----Collection接口：单列集合，用来存储一个一个的对象 |----Set接口：存储无序的、不可重复的数据 --&gt;高中讲的“集合” |----HashSet：作为Set接口的主要实现类；线程不安全的；可以存储null值 |----LinkedHashSet：作为HashSet的子类；遍历其内部数据时，可以按照添加的顺序遍历 在添加数据的同时，每个数据还维护了两个引用，记录此数据前一个数据和后一个数据。 对于频繁的遍历操作，LinkedHashSet效率高于HashSet. |----TreeSet：可以照添加对象的指定属性，进行排序。 存储对象所在类的要求： HashSet/LinkedHashSet: 1234要求：向Set(主要指：HashSet、LinkedHashSet)中添加的数据，其所在的类一定要重写hashCode()和equals()要求：重写的hashCode()和equals()尽可能保持一致性：相等的对象必须具有相等的散列码重写两个方法的小技巧：对象中用作 equals() 方法比较的 Field，都应该用来计算 hashCode 值。 TreeSet: 自然排序中，比较两个对象是否相同的标准为：compareTo()返回0.不再是equals(). 定制排序中，比较两个对象是否相同的标准为：compare()返回0.不再是equals(). TreeSet的使用 使用说明: 向TreeSet中添加的数据，要求是相同类的对象。 两种排序方式：自然排序（实现Comparable接口 和 定制排序（Comparator） 常用的排序方式: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869//方式一：自然排序@Test public void test1()&#123; TreeSet set = new TreeSet(); //失败：不能添加不同类的对象// set.add(123);// set.add(456);// set.add(&quot;AA&quot;);// set.add(new User(&quot;Tom&quot;,12)); //举例一：// set.add(34);// set.add(-34);// set.add(43);// set.add(11);// set.add(8); //举例二： set.add(new User(&quot;Tom&quot;,12)); set.add(new User(&quot;Jerry&quot;,32)); set.add(new User(&quot;Jim&quot;,2)); set.add(new User(&quot;Mike&quot;,65)); set.add(new User(&quot;Jack&quot;,33)); set.add(new User(&quot;Jack&quot;,56)); Iterator iterator = set.iterator(); while(iterator.hasNext())&#123; System.out.println(iterator.next()); &#125; &#125;//方式二：定制排序 @Test public void test2()&#123; Comparator com = new Comparator() &#123; //照年龄从小到大排列 @Override public int compare(Object o1, Object o2) &#123; if(o1 instanceof User &amp;&amp; o2 instanceof User)&#123; User u1 = (User)o1; User u2 = (User)o2; return Integer.compare(u1.getAge(),u2.getAge()); &#125;else&#123; throw new RuntimeException(&quot;输入的数据类型不匹配&quot;); &#125; &#125; &#125;; TreeSet set = new TreeSet(com); set.add(new User(&quot;Tom&quot;,12)); set.add(new User(&quot;Jerry&quot;,32)); set.add(new User(&quot;Jim&quot;,2)); set.add(new User(&quot;Mike&quot;,65)); set.add(new User(&quot;Mary&quot;,33)); set.add(new User(&quot;Jack&quot;,33)); set.add(new User(&quot;Jack&quot;,56)); Iterator iterator = set.iterator(); while(iterator.hasNext())&#123; System.out.println(iterator.next()); &#125; &#125; Map接口双列集合框架：Map 常用实现类结构 123456789|----Map:双列数据，存储key-value对的数据 ---类似于高中的函数：y = f(x) |----HashMap:作为Map的主要实现类；线程不安全的，效率高；存储null的key和value |----LinkedHashMap:保证在遍历map元素时，可以按照添加的顺序实现遍历。 原因：在原有的HashMap底层结构基础上，添加了一对指针，指向前一个和后一个元素。 对于频繁的遍历操作，此类执行效率高于HashMap。 |----TreeMap:保证按照添加的key-value对进行排序，实现排序遍历。此时考虑key的自然或定制排序 底层使用红黑树 |----Hashtable:作为古老的实现类；线程安全的，效率低；不能存储null的key和value |----Properties:常用来处理配置文件。key和value都是String类型 HashMap的底层：数组+链表 （jdk7及之前) ​ 数组+链表+红黑树 （jdk 8) [面试题] HashMap的底层实现原理？ HashMap 和 Hashtable的异同？ CurrentHashMap 与 Hashtable的异同？（暂时不讲) 存储结构的理解： Map中的key:无序的、不可重复的，使用Set存储所的key —&gt; key所在的类要重写equals()和hashCode() （以HashMap为例) Map中的value:无序的、可重复的，使用Collection存储所有的value value所在的类要重写equals() 一个键值对：key-value构成了一个Entry对象。 Map中的entry:无序的、不可重复的，使用Set存储所的entry 图示： 常用方法 123456* 添加：put(Object key,Object value)* 删除：remove(Object key)* 修改：put(Object key,Object value)* 查询：get(Object key)* 长度：size()* 遍历：keySet() / values() / entrySet() 内存结构说明：（难点） HashMap在jdk7中实现原理： 1234567891011121314HashMap map = new HashMap():在实例化以后，底层创建了长度是16的一维数组Entry[] table。...可能已经执行过多次put...map.put(key1,value1):首先，调用key1所在类的hashCode()计算key1哈希值，此哈希值经过某种算法计算以后，得到在Entry数组中的存放位置。 如果此位置上的数据为空，此时的key1-value1添加成功。 ----情况1 如果此位置上的数据不为空，(意味着此位置上存在一个或多个数据(以链表形式存在)),比较key1和已经存在的一个或多个数据的哈希值： 如果key1的哈希值与已经存在的数据的哈希值都不相同，此时key1-value1添加成功。----情况2 如果key1的哈希值和已经存在的某一个数据(key2-value2)的哈希值相同，继续比较：调用key1所在类的equals(key2)方法，比较： 如果equals()返回false:此时key1-value1添加成功。----情况3 如果equals()返回true:使用value1替换value2。补充：关于情况2和情况3：此时key1-value1和原来的数据以链表的方式存储。在不断的添加过程中，会涉及到扩容问题，当超出临界值(且要存放的位置非空)时，扩容。默认的扩容方式：扩容为原来容量的2倍，并将原的数据复制过来。 HashMap在jdk8中相较于jdk7在底层实现方面的不同： new HashMap():底层没创建一个长度为16的数组 jdk 8底层的数组是：Node[],而非Entry[] 首次调用put()方法时，底层创建长度为16的数组 jdk7底层结构只有：数组+链表。jdk8中底层结构：数组+链表+红黑树。 形成链表时，七上八下（jdk7:新的元素指向旧的元素。jdk8：旧的元素指向新的元素） 当数组的某一个索引位置上的元素以链表形式存在的数据个数 &gt; 8 且当前数组的长度 &gt; 64时，此时此索引位置上的所数据改为使用红黑树存储。 HashMap底层典型属性的属性的说明： DEFAULT_INITIAL_CAPACITY : HashMap的默认容量，16 DEFAULT_LOAD_FACTOR：HashMap的默认加载因子：0.75 threshold：扩容的临界值，=容量*填充因子：16 * 0.75 =&gt; 12 TREEIFY_THRESHOLD：Bucket中链表长度大于该默认值，转化为红黑树:8 MIN_TREEIFY_CAPACITY：桶中的Node被树化时最小的hash表容量:64 LinkedHashMap的底层实现原理(了解) LinkedHashMap底层使用的结构与HashMap相同，因为LinkedHashMap继承于HashMap. 区别就在于：LinkedHashMap内部提供了Entry，替换HashMap中的Node. TreeMap的使用 向TreeMap中添加key-value，要求key必须是由同一个类创建的对象 因为要照key进行排序：自然排序 、定制排序 使用Properties读取配置文件 1234567891011121314151617181920212223242526//Properties:常用来处理配置文件。key和value都是String类型public static void main(String[] args) &#123; FileInputStream fis = null; try &#123; Properties pros = new Properties(); fis = new FileInputStream(&quot;jdbc.properties&quot;); pros.load(fis);//加载流对应的文件 String name = pros.getProperty(&quot;name&quot;); String password = pros.getProperty(&quot;password&quot;); System.out.println(&quot;name = &quot; + name + &quot;, password = &quot; + password); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; if(fis != null)&#123; try &#123; fis.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; Collections工具类的使用 作用：操作Collection和Map的工具类 常用方法： 123456789101112reverse(List)：反转 List 中元素的顺序shuffle(List)：对 List 集合元素进行随机排序sort(List)：根据元素的自然顺序对指定 List 集合元素升序排序sort(List，Comparator)：根据指定的 Comparator 产生的顺序对 List 集合元素进行排序swap(List，int， int)：将指定 list 集合中的 i 处元素和 j 处元素进行交换Object max(Collection)：根据元素的自然顺序，返回给定集合中的最大元素Object max(Collection，Comparator)：根据 Comparator 指定的顺序，返回给定集合中的最大元素Object min(Collection)Object min(Collection，Comparator)int frequency(Collection，Object)：返回指定集合中指定元素的出现次数void copy(List dest,List src)：将src中的内容复制到dest中boolean replaceAll(List list，Object oldVal，Object newVal)：使用新值替换 List 对象的所旧值 说明：ArrayList和HashMap都是线程不安全的，如果程序要求线程安全，我们可以将ArrayList、HashMap转换为线程的。使用synchronizedList(List list） 和 synchronizedMap(Map map） 面试题：Collection 和 Collections的区别？ 数据结构简述 数据结构概述 数据结构（Data Structure是一门和计算机硬件与软件都密切相关的学科，它的研究重点是在计算机的程序设计领域中探讨如何在计算机中组织和存储数据并进行高效率的运用，涉及的内容包含：数据的逻辑关系、数据的存储结构、排序算法（Algorithm）、查找（或搜索）等。 数据结构与算法的理解 程序能否快速而高效地完成预定的任务，取决于是否选对了数据结构，而程序是否能清楚而正确地把问题解决，则取决于算法。 所以大家认为：“Algorithms + Data Structures = Programs”（出自：Pascal之父Nicklaus Wirth） 总结：算法是为了解决实际问题而设计的，数据结构是算法需要处理的问题载体。 数据结构的研究对象 数据间的逻辑结构 ​ 集合结构 一对一：线性结构 一对多：树形结构 多对多：图形结构 数据的存储结构： 线性表（顺序表、链表、栈、队列） 树 图 说明： 习惯上把顺序表和链表看做基本数据结构（或真实数据结构） 习惯上把栈、队列、树、图看做抽象数据类型，简称ADT 12_泛型泛型的理解 泛型的概念：所谓泛型，就是允许在定义类、接口时通过一个标识表示类中某个属性的类型或者是某个方法的返回值及参数类型。这个类型参数将在使用时（例如，继承或实现这个接口，用这个类型声明变量、创建对象时确定（即传入实际的类型参数，也称为类型实参）。 泛型的引入背景 集合容器类在设计阶段/声明阶段不能确定这个容器到底实际存的是什么类型的对象，所以在JDK1.5之前只能把元素类型设计为Object，JDK1.5之后使用泛型来解决。因为这个时候除了元素的类型不确定，其他的部分是确定的，例如关于这个元素如何保存，如何管理等是确定的，因此此时把元素的类型设计成一个参数，这个类型参数叫做泛型。Collection，List，ArrayList 这个就是类型参数，即泛型。 泛型在集合中的使用 在集合中使用泛型之前的例子 1234567891011121314151617181920@Test public void test1()&#123; ArrayList list = new ArrayList(); //需求：存放学生的成绩 list.add(78); list.add(76); list.add(89); list.add(88); //问题一：类型不安全// list.add(&quot;Tom&quot;); for(Object score : list)&#123; //问题二：强转时，可能出现ClassCastException int stuScore = (Integer) score; System.out.println(stuScore); &#125; &#125; 图示： 在集合中使用泛型例子1 123456789101112131415161718192021222324252627@Test public void test2()&#123; ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); list.add(78); list.add(87); list.add(99); list.add(65); //编译时，就会进行类型检查，保证数据的安全// list.add(&quot;Tom&quot;); //方式一：// for(Integer score : list)&#123;// //避免了强转操作// int stuScore = score;//// System.out.println(stuScore);//// &#125; //方式二： Iterator&lt;Integer&gt; iterator = list.iterator(); while(iterator.hasNext())&#123; int stuScore = iterator.next(); System.out.println(stuScore); &#125; &#125; 图示： 在集合中使用泛型例子2 12345678910111213141516171819202122232425//在集合中使用泛型的情况：以HashMap为例 @Test public void test3()&#123;// Map&lt;String,Integer&gt; map = new HashMap&lt;String,Integer&gt;(); //jdk7新特性：类型推断 Map&lt;String,Integer&gt; map = new HashMap&lt;&gt;(); map.put(&quot;Tom&quot;,87); map.put(&quot;Jerry&quot;,87); map.put(&quot;Jack&quot;,67);// map.put(123,&quot;ABC&quot;); //泛型的嵌套 Set&lt;Map.Entry&lt;String,Integer&gt;&gt; entry = map.entrySet(); Iterator&lt;Map.Entry&lt;String, Integer&gt;&gt; iterator = entry.iterator(); while(iterator.hasNext())&#123; Map.Entry&lt;String, Integer&gt; e = iterator.next(); String key = e.getKey(); Integer value = e.getValue(); System.out.println(key + &quot;----&quot; + value); &#125; &#125; 集合中使用泛型总结： 集合接口或集合类在jdk5.0时都修改为带泛型的结构。 在实例化集合类时，可以指明具体的泛型类型 指明完以后，在集合类或接口中凡是定义类或接口时，内部结构（比如：方法、构造器、属性等）使用到类的泛型的位置，都指定为实例化的泛型类型。 比如：add(E e) —&gt;实例化以后：add(Integer e) 注意点：泛型的类型必须是类，不能是基本数据类型。需要用到基本数据类型的位置，拿包装类替换 如果实例化时，没指明泛型的类型。默认类型为java.lang.Object类型。 自定义泛型类、泛型接口、泛型方法 举例: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116【Order.java】public class Order&lt;T&gt; &#123; String orderName; int orderId; //类的内部结构就可以使用类的泛型 T orderT; public Order()&#123; //编译不通过// T[] arr = new T[10]; //编译通过 T[] arr = (T[]) new Object[10]; &#125; public Order(String orderName,int orderId,T orderT)&#123; this.orderName = orderName; this.orderId = orderId; this.orderT = orderT; &#125; //如下的个方法都不是泛型方法 public T getOrderT()&#123; return orderT; &#125; public void setOrderT(T orderT)&#123; this.orderT = orderT; &#125; @Override public String toString() &#123; return &quot;Order&#123;&quot; + &quot;orderName=&#x27;&quot; + orderName + &#x27;\\&#x27;&#x27; + &quot;, orderId=&quot; + orderId + &quot;, orderT=&quot; + orderT + &#x27;&#125;&#x27;; &#125; //静态方法中不能使用类的泛型。// public static void show(T orderT)&#123;// System.out.println(orderT);// &#125; public void show()&#123; //编译不通过// try&#123;// &#125;catch(T t)&#123;// &#125; &#125; //泛型方法：在方法中出现了泛型的结构，泛型参数与类的泛型参数没任何关系。 //换句话说，泛型方法所属的类是不是泛型类都没关系。 //泛型方法，可以声明为静态的。原因：泛型参数是在调用方法时确定的。并非在实例化类时确定。 public static &lt;E&gt; List&lt;E&gt; copyFromArrayToList(E[] arr)&#123; ArrayList&lt;E&gt; list = new ArrayList&lt;&gt;(); for(E e : arr)&#123; list.add(e); &#125; return list; &#125;&#125;【SubOrder.java】public class SubOrder extends Order&lt;Integer&gt; &#123;//SubOrder:不是泛型类 public static &lt;E&gt; List&lt;E&gt; copyFromArrayToList(E[] arr)&#123; ArrayList&lt;E&gt; list = new ArrayList&lt;&gt;(); for(E e : arr)&#123; list.add(e); &#125; return list; &#125;&#125;//实例化时，如下的代码是错误的SubOrder&lt;Integer&gt; o = new SubOrder&lt;&gt;();【SubOrder1.java】public class SubOrder1&lt;T&gt; extends Order&lt;T&gt; &#123;//SubOrder1&lt;T&gt;:仍然是泛型类&#125;【测试】@Test public void test1()&#123; //如果定义了泛型类，实例化没指明类的泛型，则认为此泛型类型为Object类型 //要求：如果大家定义了类是带泛型的，建议在实例化时要指明类的泛型。 Order order = new Order(); order.setOrderT(123); order.setOrderT(&quot;ABC&quot;); //建议：实例化时指明类的泛型 Order&lt;String&gt; order1 = new Order&lt;String&gt;(&quot;orderAA&quot;,1001,&quot;order:AA&quot;); order1.setOrderT(&quot;AA:hello&quot;); &#125; @Test public void test2()&#123; SubOrder sub1 = new SubOrder(); //由于子类在继承带泛型的父类时，指明了泛型类型。则实例化子类对象时，不再需要指明泛型。 sub1.setOrderT(1122); SubOrder1&lt;String&gt; sub2 = new SubOrder1&lt;&gt;(); sub2.setOrderT(&quot;order2...&quot;); &#125; @Test public void test3()&#123; ArrayList&lt;String&gt; list1 = null; ArrayList&lt;Integer&gt; list2 = new ArrayList&lt;Integer&gt;(); //泛型不同的引用不能相互赋值。// list1 = list2; Person p1 = null; Person p2 = null; p1 = p2; &#125; //测试泛型方法 @Test public void test4()&#123; Order&lt;String&gt; order = new Order&lt;&gt;(); Integer[] arr = new Integer[]&#123;1,2,3,4&#125;; //泛型方法在调用时，指明泛型参数的类型。 List&lt;Integer&gt; list = order.copyFromArrayToList(arr); System.out.println(list); &#125; 注意点： 应用场景举例： 【DAO.java】:定义了操作数据库中的表的通用操作。 ORM思想(数据库中的表和Java中的类对应) 123456789101112131415161718192021222324252627282930313233343536373839public class DAO&lt;T&gt; &#123;//表的共性操作的DAO //添加一条记录 public void add(T t)&#123; &#125; //删除一条记录 public boolean remove(int index)&#123; return false; &#125; //修改一条记录 public void update(int index,T t)&#123; &#125; //查询一条记录 public T getIndex(int index)&#123; return null; &#125; //查询多条记录 public List&lt;T&gt; getForList(int index)&#123; return null; &#125; //泛型方法 //举例：获取表中一共有多少条记录？获取最大的员工入职时间？ public &lt;E&gt; E getValue()&#123; return null; &#125;&#125; 【CustomerDAO.java】: 12public class CustomerDAO extends DAO&lt;Customer&gt;&#123;//只能操作某一个表的DAO&#125; 【StudentDAO.java】: 12public class StudentDAO extends DAO&lt;Student&gt; &#123;//只能操作某一个表的DAO&#125; 泛型在继承上的体现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162/* 1. 泛型在继承方面的体现 虽然类A是类B的父类，但是G&lt;A&gt; 和G&lt;B&gt;二者不具备子父类关系，二者是并列关系。 补充：类A是类B的父类，A&lt;G&gt; 是 B&lt;G&gt; 的父类 */ @Test public void test1()&#123; Object obj = null; String str = null; obj = str; Object[] arr1 = null; String[] arr2 = null; arr1 = arr2; //编译不通过// Date date = new Date();// str = date; List&lt;Object&gt; list1 = null; List&lt;String&gt; list2 = new ArrayList&lt;String&gt;(); //此时的list1和list2的类型不具子父类关系 //编译不通过// list1 = list2; /* 反证法： 假设list1 = list2; list1.add(123);导致混入非String的数据。出错。 */ show(list1); show1(list2); &#125; public void show1(List&lt;String&gt; list)&#123; &#125; public void show(List&lt;Object&gt; list)&#123; &#125; @Test public void test2()&#123; AbstractList&lt;String&gt; list1 = null; List&lt;String&gt; list2 = null; ArrayList&lt;String&gt; list3 = null; list1 = list3; list2 = list3; List&lt;String&gt; list4 = new ArrayList&lt;&gt;(); &#125; 通配符 通配符的使用 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/* 通配符的使用 通配符：? 类A是类B的父类，G&lt;A&gt;和G&lt;B&gt;是没关系的，二者共同的父类是：G&lt;?&gt; */ @Test public void test3()&#123; List&lt;Object&gt; list1 = null; List&lt;String&gt; list2 = null; List&lt;?&gt; list = null; list = list1; list = list2; //编译通过// print(list1);// print(list2); // List&lt;String&gt; list3 = new ArrayList&lt;&gt;(); list3.add(&quot;AA&quot;); list3.add(&quot;BB&quot;); list3.add(&quot;CC&quot;); list = list3; //添加(写入)：对于List&lt;?&gt;就不能向其内部添加数据。 //除了添加null之外。// list.add(&quot;DD&quot;);// list.add(&#x27;?&#x27;); list.add(null); //获取(读取)：允许读取数据，读取的数据类型为Object。 Object o = list.get(0); System.out.println(o); &#125; public void print(List&lt;?&gt; list)&#123; Iterator&lt;?&gt; iterator = list.iterator(); while(iterator.hasNext())&#123; Object obj = iterator.next(); System.out.println(obj); &#125; &#125; 涉及通配符的集合的数据的写入和读取:见上 有限制条件的通配符的使用 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/* 限制条件的通配符的使用。 ? extends A: G&lt;? extends A&gt; 可以作为G&lt;A&gt;和G&lt;B&gt;的父类，其中B是A的子类 ? super A: G&lt;? super A&gt; 可以作为G&lt;A&gt;和G&lt;B&gt;的父类，其中B是A的父类 */ @Test public void test4()&#123; List&lt;? extends Person&gt; list1 = null; List&lt;? super Person&gt; list2 = null; List&lt;Student&gt; list3 = new ArrayList&lt;Student&gt;(); List&lt;Person&gt; list4 = new ArrayList&lt;Person&gt;(); List&lt;Object&gt; list5 = new ArrayList&lt;Object&gt;(); list1 = list3; list1 = list4;// list1 = list5;// list2 = list3; list2 = list4; list2 = list5; //读取数据： list1 = list3; Person p = list1.get(0); //编译不通过 //Student s = list1.get(0); list2 = list4; Object obj = list2.get(0); ////编译不通过// Person obj = list2.get(0); //写入数据： //编译不通过// list1.add(new Student()); //编译通过 list2.add(new Person()); list2.add(new Student()); &#125; 13_IO流File类的使用 File类的理解 File类的一个对象，代表一个文件或一个文件目录(俗称：文件夹) File类声明在java.io包下 File类中涉及到关于文件或文件目录的创建、删除、重命名、修改时间、文件大小等方法，并未涉及到写入或读取文件内容的操作。如果需要读取或写入文件内容，必须使用IO流来完成。 后续File类的对象常会作为参数传递到流的构造器中，指明读取或写入的”终点”. File的实例化 常用构造器 File(String filePath) File(String parentPath,String childPath) File(File parentFile,String childPath) 路径的分类 相对路径：相较于某个路径下，指明的路径。 绝对路径：包含盘符在内的文件或文件目录的路径 说明： IDEA中： 如果大家开发使用JUnit中的单元测试方法测试，相对路径即为当前Module下。 如果大家使用main()测试，相对路径即为当前的Project下。 Eclipse中： ​ 不管使用单元测试方法还是使用main()测试，相对路径都是当前的Project下。 路径分隔符 windows和DOS系统默认使用“\\”来表示 UNIX和URL使用“/”来表示 File类的常用方法 IO流概述 流的分类 操作数据单位：字节流、字符流 数据的流向：输入流、输出流 流的角色：节点流、处理流 图示： 流的体系结构 说明：红框对应的是IO流中的4个抽象基类。 蓝框的流需要大家重点关注。 重点说明的几个流结构 输入、输出的标准化过程 输入过程 创建File类的对象，指明读取的数据的来源。（要求此文件一定要存在） 创建相应的输入流，将File类的对象作为参数，传入流的构造器中 具体的读入过程：创建相应的byte[] 或 char[]。 关闭流资源说明：程序中出现的异常需要使用try-catch-finally处理。 输出过程 创建File类的对象，指明写出的数据的位置。（不要求此文件一定要存在） 创建相应的输出流，将File类的对象作为参数，传入流的构造器中 具体的写出过程：write(char[]/byte[] buffer,0,len) 关闭流资源说明：程序中出现的异常需要使用try-catch-finally处理。 节点流（或文件流） FileReader/FileWriter的使用： FileReader的使用 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556/*将day09下的hello.txt文件内容读入程序中，并输出到控制台说明点：1. read()的理解：返回读入的一个字符。如果达到文件末尾，返回-12. 异常的处理：为了保证流资源一定可以执行关闭操作。需要使用try-catch-finally处理3. 读入的文件一定要存在，否则就会报FileNotFoundException。 */@Test public void testFileReader1() &#123; FileReader fr = null; try &#123; //1.File类的实例化 File file = new File(&quot;hello.txt&quot;); //2.FileReader流的实例化 fr = new FileReader(file); //3.读入的操作 //read(char[] cbuf):返回每次读入cbuf数组中的字符的个数。如果达到文件末尾，返回-1 char[] cbuf = new char[5]; int len; while((len = fr.read(cbuf)) != -1)&#123; //方式一： //错误的写法// for(int i = 0;i &lt; cbuf.length;i++)&#123;// System.out.print(cbuf[i]);// &#125; //正确的写法// for(int i = 0;i &lt; len;i++)&#123;// System.out.print(cbuf[i]);// &#125; //方式二： //错误的写法,对应着方式一的错误的写法// String str = new String(cbuf);// System.out.print(str); //正确的写法 String str = new String(cbuf,0,len); System.out.print(str); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; if(fr != null)&#123; //4.资源的关闭 try &#123; fr.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; FileWriter的使用 123456789101112131415161718192021222324252627282930313233343536373839/*从内存中写出数据到硬盘的文件里。说明：1. 输出操作，对应的File可以不存在的。并不会报异常2. File对应的硬盘中的文件如果不存在，在输出的过程中，会自动创建此文件。 File对应的硬盘中的文件如果存在： 如果流使用的构造器是：FileWriter(file,false) / FileWriter(file):对原文件的覆盖 如果流使用的构造器是：FileWriter(file,true):不会对原文件覆盖，而是在原文件基础上追加内容 */@Testpublic void testFileWriter() &#123; FileWriter fw = null; try &#123; //1.提供File类的对象，指明写出到的文件 File file = new File(&quot;hello1.txt&quot;); //2.提供FileWriter的对象，用于数据的写出 fw = new FileWriter(file,false); //3.写出的操作 fw.write(&quot;I have a dream!\\n&quot;); fw.write(&quot;you need to have a dream!&quot;); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; //4.流资源的关闭 if(fw != null)&#123; try &#123; fw.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; 文本文件的复制： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364@Test public void testFileReaderFileWriter() &#123; FileReader fr = null; FileWriter fw = null; try &#123; //1.创建File类的对象，指明读入和写出的文件 File srcFile = new File(&quot;hello.txt&quot;); File destFile = new File(&quot;hello2.txt&quot;); //不能使用字符流来处理图片等字节数据// File srcFile = new File(&quot;爱情与友情.jpg&quot;);// File destFile = new File(&quot;爱情与友情1.jpg&quot;); //2.创建输入流和输出流的对象 fr = new FileReader(srcFile); fw = new FileWriter(destFile); //3.数据的读入和写出操作 char[] cbuf = new char[5]; int len;//记录每次读入到cbuf数组中的字符的个数 while((len = fr.read(cbuf)) != -1)&#123; //每次写出len个字符 fw.write(cbuf,0,len); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; //4.关闭流资源 //方式一：// try &#123;// if(fw != null)// fw.close();// &#125; catch (IOException e) &#123;// e.printStackTrace();// &#125;finally&#123;// try &#123;// if(fr != null)// fr.close();// &#125; catch (IOException e) &#123;// e.printStackTrace();// &#125;// &#125; //方式二： try &#123; if(fw != null) fw.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; try &#123; if(fr != null) fr.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; FileInputStream / FileOutputStream的使用： 对于文本文件(.txt,.java,.c,.cpp)，使用字符流处理 对于非文本文件(.jpg,.mp3,.mp4,.avi,.doc,.ppt,…)，使用字节流处理 12345678910111213141516171819202122232425262728293031323334353637383940414243444546/*实现对图片的复制操作 */@Testpublic void testFileInputOutputStream() &#123; FileInputStream fis = null; FileOutputStream fos = null; try &#123; //1.造文件 File srcFile = new File(&quot;爱情与友情.jpg&quot;); File destFile = new File(&quot;爱情与友情2.jpg&quot;); //2.造流 fis = new FileInputStream(srcFile); fos = new FileOutputStream(destFile); //3.复制的过程 byte[] buffer = new byte[5]; int len; while((len = fis.read(buffer)) != -1)&#123; fos.write(buffer,0,len); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; if(fos != null)&#123; //4.关闭流 try &#123; fos.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; if(fis != null)&#123; try &#123; fis.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 【注意】相对路径在IDEA和Eclipse中使用的区别？ IDEA: 如果使用单元测试方法，相对路径基于当前的Module的。 如果使用main()测试，相对路径基于当前Project的。 Eclipse:单元测试方法还是main(),相对路径都是基于当前Project的。 缓冲流的使用 缓冲流涉及到的类： BufferedInputStream BufferedOutputStream BufferedReader BufferedWriter 作用：提供流的读取、写入的速度 提高读写速度的原因：内部提供了一个缓冲区。默认情况下是8kb 典型代码 使用BufferedInputStream和BufferedOutputStream:处理非文本文件 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849//实现文件复制的方法 public void copyFileWithBuffered(String srcPath,String destPath)&#123; BufferedInputStream bis = null; BufferedOutputStream bos = null; try &#123; //1.造文件 File srcFile = new File(srcPath); File destFile = new File(destPath); //2.造流 //2.1 造节点流 FileInputStream fis = new FileInputStream((srcFile)); FileOutputStream fos = new FileOutputStream(destFile); //2.2 造缓冲流 bis = new BufferedInputStream(fis); bos = new BufferedOutputStream(fos); //3.复制的细节：读取、写入 byte[] buffer = new byte[1024]; int len; while((len = bis.read(buffer)) != -1)&#123; bos.write(buffer,0,len); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; //4.资源关闭 //要求：先关闭外层的流，再关闭内层的流 if(bos != null)&#123; try &#123; bos.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; if(bis != null)&#123; try &#123; bis.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; //说明：关闭外层流的同时，内层流也会自动的进行关闭。关于内层流的关闭，我们可以省略.// fos.close();// fis.close(); &#125; &#125; 使用BufferedReader和BufferedWriter：处理文本文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354@Test public void testBufferedReaderBufferedWriter()&#123; BufferedReader br = null; BufferedWriter bw = null; try &#123; //创建文件和相应的流 br = new BufferedReader(new FileReader(new File(&quot;dbcp.txt&quot;))); bw = new BufferedWriter(new FileWriter(new File(&quot;dbcp1.txt&quot;))); //读写操作 //方式一：使用char[]数组// char[] cbuf = new char[1024];// int len;// while((len = br.read(cbuf)) != -1)&#123;// bw.write(cbuf,0,len);// // bw.flush();// &#125; //方式二：使用String String data; while((data = br.readLine()) != null)&#123; //方法一：// bw.write(data + &quot;\\n&quot;);//data中不包含换行符 //方法二： bw.write(data);//data中不包含换行符 bw.newLine();//提供换行的操作 &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; //关闭资源 if(bw != null)&#123; try &#123; bw.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; if(br != null)&#123; try &#123; br.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; 转换流的使用 转换流涉及到的类：属于字符流 InputStreamReader：将一个字节的输入流转换为字符的输入流 解码：字节、字节数组 —&gt;字符数组、字符串 OutputStreamWriter：将一个字符的输出流转换为字节的输出流 编码：字符数组、字符串 —&gt; 字节、字节数组 说明：编码决定了解码的方式 //文件编码的方式（比如：GBK），决定了解析时使用的字符集（也只能是GBK）。 作用：提供字节流与字符流之间的转换 图示： 典型实现： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849@Test public void test1() throws IOException &#123; FileInputStream fis = new FileInputStream(&quot;dbcp.txt&quot;);// InputStreamReader isr = new InputStreamReader(fis);//使用系统默认的字符集 //参数2指明了字符集，具体使用哪个字符集，取决于文件dbcp.txt保存时使用的字符集 InputStreamReader isr = new InputStreamReader(fis,&quot;UTF-8&quot;);//使用系统默认的字符集 char[] cbuf = new char[20]; int len; while((len = isr.read(cbuf)) != -1)&#123; String str = new String(cbuf,0,len); System.out.print(str); &#125; isr.close(); &#125;/*此时处理异常的话，仍然应该使用try-catch-finally综合使用InputStreamReader和OutputStreamWriter */@Testpublic void test2() throws Exception &#123; //1.造文件、造流 File file1 = new File(&quot;dbcp.txt&quot;); File file2 = new File(&quot;dbcp_gbk.txt&quot;); FileInputStream fis = new FileInputStream(file1); FileOutputStream fos = new FileOutputStream(file2); InputStreamReader isr = new InputStreamReader(fis,&quot;utf-8&quot;); OutputStreamWriter osw = new OutputStreamWriter(fos,&quot;gbk&quot;); //2.读写过程 char[] cbuf = new char[20]; int len; while((len = isr.read(cbuf)) != -1)&#123; osw.write(cbuf,0,len); &#125; //3.关闭资源 isr.close(); osw.close();&#125; 编码集 常见的编码表 ASCII：美国标准信息交换码。用一个字节的7位可以表示。 ISO8859-1：拉丁码表。欧洲码表用一个字节的8位表示。 GB2312：中国的中文编码表。最多两个字节编码所有字符 GBK：中国的中文编码表升级，融合了更多的中文文字符号。最多两个字节编码 Unicode：国际标准码，融合了目前人类使用的所字符。为每个字符分配唯一的字符码。所有的文字都用两个字节来表示。 UTF-8：变长的编码方式，可用1-4个字节来表示一个字符。 对后面学习的启示 客户端/浏览器端 &lt;—-&gt; 后台(java,GO,Python,Node.js,php) &lt;—-&gt; 数据库 要求前前后后使用的字符集都要统一：UTF-8. 其它的流的使用 标准的输入输出流： System.in:标准的输入流，默认从键盘输入 System.out:标准的输出流，默认从控制台输出 修改默认的输入和输出行为：System类的setIn(InputStream is) / setOut(PrintStream ps)方式重新指定输入和输出的流。 打印流：PrintStream 和PrintWriter 提供了一系列重载的print()和println()方法，用于多种数据类型的输出 System.out返回的是PrintStream的实例 数据流：DataInputStream 和 DataOutputStream 作用：用于读取或写出基本数据类型的变量或字符串 示例代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344/*练习：将内存中的字符串、基本数据类型的变量写出到文件中。注意：处理异常的话，仍然应该使用try-catch-finally. */@Testpublic void test3() throws IOException &#123; //1. DataOutputStream dos = new DataOutputStream(new FileOutputStream(&quot;data.txt&quot;)); //2. dos.writeUTF(&quot;刘建辰&quot;); dos.flush();//刷新操作，将内存中的数据写入文件 dos.writeInt(23); dos.flush(); dos.writeBoolean(true); dos.flush(); //3. dos.close();&#125;/*将文件中存储的基本数据类型变量和字符串读取到内存中，保存在变量中。注意点：读取不同类型的数据的顺序要与当初写入文件时，保存的数据的顺序一致！ */@Testpublic void test4() throws IOException &#123; //1. DataInputStream dis = new DataInputStream(new FileInputStream(&quot;data.txt&quot;)); //2. String name = dis.readUTF(); int age = dis.readInt(); boolean isMale = dis.readBoolean(); System.out.println(&quot;name = &quot; + name); System.out.println(&quot;age = &quot; + age); System.out.println(&quot;isMale = &quot; + isMale); //3. dis.close();&#125; 对象流的使用 对象流： ObjectInputStream 和 ObjectOutputStream 作用： ObjectOutputStream:内存中的对象—&gt;存储中的文件、通过网络传输出去：序列化过程 ObjectInputStream:存储中的文件、通过网络接收过来 —&gt;内存中的对象：反序列化过程 对象的序列化机制：对象序列化机制允许把内存中的Java对象转换成平台无关的二进制流，从而允许把这种二进制流持久地保存在磁盘上，或通过网络将这种二进制流传输到另一个网络节点。//当其它程序获取了这种二进制流，就可以恢复成原来的Java对象 序列化代码实现： 1234567891011121314151617181920212223242526272829303132@Testpublic void testObjectOutputStream()&#123; ObjectOutputStream oos = null; try &#123; //1. oos = new ObjectOutputStream(new FileOutputStream(&quot;object.dat&quot;)); //2. oos.writeObject(new String(&quot;我爱北京天安门&quot;)); oos.flush();//刷新操作 oos.writeObject(new Person(&quot;王铭&quot;,23)); oos.flush(); oos.writeObject(new Person(&quot;张学良&quot;,23,1001,new Account(5000))); oos.flush(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; if(oos != null)&#123; //3. try &#123; oos.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 反序列化代码实现： 12345678910111213141516171819202122232425262728293031323334@Testpublic void testObjectInputStream()&#123; ObjectInputStream ois = null; try &#123; ois = new ObjectInputStream(new FileInputStream(&quot;object.dat&quot;)); Object obj = ois.readObject(); String str = (String) obj; Person p = (Person) ois.readObject(); Person p1 = (Person) ois.readObject(); System.out.println(str); System.out.println(p); System.out.println(p1); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; finally &#123; if(ois != null)&#123; try &#123; ois.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 实现序列化的对象所属的类需要满足： 需要实现接口：Serializable 当前类提供一个全局常量：serialVersionUID 除了当前Person类需要实现Serializable接口之外，还必须保证其内部所属性也必须是可序列化的。（默认情况下，基本数据类型可序列化） 补充：ObjectOutputStream和ObjectInputStream不能序列化static和transient修饰的成员变量 RandomAccessFile的使用 随机存取文件流：RandomAccessFile 使用说明： RandomAccessFile直接继承于java.lang.Object类，实现了DataInput和DataOutput接口 RandomAccessFile既可以作为一个输入流，又可以作为一个输出流 如果RandomAccessFile作为输出流时，写出到的文件如果不存在，则在执行过程中自动创建。如果写出到的文件存在，则会对原文件内容进行覆盖。（默认情况下，从头覆盖） 可以通过相关的操作，实现RandomAccessFile“插入”数据的效果。seek(int pos) 典型代码1： 12345678910111213141516171819202122232425262728293031323334353637@Testpublic void test1() &#123; RandomAccessFile raf1 = null; RandomAccessFile raf2 = null; try &#123; //1. raf1 = new RandomAccessFile(new File(&quot;爱情与友情.jpg&quot;),&quot;r&quot;); raf2 = new RandomAccessFile(new File(&quot;爱情与友情1.jpg&quot;),&quot;rw&quot;); //2. byte[] buffer = new byte[1024]; int len; while((len = raf1.read(buffer)) != -1)&#123; raf2.write(buffer,0,len); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; //3. if(raf1 != null)&#123; try &#123; raf1.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; if(raf2 != null)&#123; try &#123; raf2.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 典型代码2： 123456789101112131415161718192021222324252627/*使用RandomAccessFile实现数据的插入效果 */@Testpublic void test3() throws IOException &#123; RandomAccessFile raf1 = new RandomAccessFile(&quot;hello.txt&quot;,&quot;rw&quot;); raf1.seek(3);//将指针调到角标为3的位置 //保存指针3后面的所数据到StringBuilder中 StringBuilder builder = new StringBuilder((int) new File(&quot;hello.txt&quot;).length()); byte[] buffer = new byte[20]; int len; while((len = raf1.read(buffer)) != -1)&#123; builder.append(new String(buffer,0,len)) ; &#125; //调回指针，写入“xyz” raf1.seek(3); raf1.write(&quot;xyz&quot;.getBytes()); //将StringBuilder中的数据写入到文件中 raf1.write(builder.toString().getBytes()); raf1.close(); //思考：将StringBuilder替换为ByteArrayOutputStream&#125; Path、Paths、Files的使用 NIO的使用说明： Java NIO (New IO，Non-Blocking IO)是从Java 1.4版本开始引入的一套新的IO API，可以替代标准的JavaIO API。 NIO与原来的IO同样的作用和目的，但是使用的方式完全不同，NIO支持面向缓冲区的(IO是面向流的)、基于通道的IO操作。 NIO将以更加高效的方式进行文件的读写操作。 随着 JDK 7 的发布，Java对NIO进行了极大的扩展，增强了对文件处理和文件系统特性的支持，以至于我们称他们为 NIO.2。 Path的使用 —jdk7提供 Path的说明：Path替换原有的File类。 如何实例化： 常用方法： Files工具类 —jdk7提供 作用：操作文件或文件目录的工具类 常用方法 14_网络编程InetAddress类的使用 实现网络通信需要解决的两个问题 如何准确地定位网络上一台或多台主机；定位主机上的特定的应用 找到主机后如何可靠高效地进行数据传输 网络通信的两个要素： 对应问题一：IP和端口号 对应问题二：提供网络通信协议：TCP/IP参考模型（应用层、传输层、网络层、物理+数据链路层） 通信要素一：IP和端口号 IP的理解 IP:唯一的标识 Internet 上的计算机（通信实体） 在Java中使用InetAddress类代表IP IP分类：IPv4 和 IPv6 ; 万维网 和 局域网 域名: www.baidu.com www.mi.com www.sina.com www.jd.com 域名解析：域名容易记忆，当在连接网络时输入一个主机的域名后，域名服务器(DNS)负责将域名转化成IP地址，这样才能和主机建立连接。 ——-域名解析 本地回路地址：127.0.0.1 对应着：localhost InetAddress类:此类的一个对象就代表着一个具体的IP地址 实例化:getByName(String host) 、 getLocalHost() 常用方法:getHostName() / getHostAddress() 端口号：正在计算机上运行的进程。 要求：不同的进程不同的端口号 范围：被规定为一个 16 位的整数 0~65535。 端口号与IP地址的组合得出一个网络套接字：Socket 通信要素二：网络通信协议 分型模型 TCP和UDP的区别 TCP三次握手和四次挥手 TCP网络编程代码示例1：客户端发送信息给服务端，服务端将数据显示在控制台上 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109//客户端 @Test public void client() &#123; Socket socket = null; OutputStream os = null; try &#123; //1.创建Socket对象，指明服务器端的ip和端口号 InetAddress inet = InetAddress.getByName(&quot;192.168.14.100&quot;); socket = new Socket(inet,8899); //2.获取一个输出流，用于输出数据 os = socket.getOutputStream(); //3.写出数据的操作 os.write(&quot;你好，我是客户端mm&quot;.getBytes()); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; //4.资源的关闭 if(os != null)&#123; try &#123; os.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; if(socket != null)&#123; try &#123; socket.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; //服务端 @Test public void server() &#123; ServerSocket ss = null; Socket socket = null; InputStream is = null; ByteArrayOutputStream baos = null; try &#123; //1.创建服务器端的ServerSocket，指明自己的端口号 ss = new ServerSocket(8899); //2.调用accept()表示接收来自于客户端的socket socket = ss.accept(); //3.获取输入流 is = socket.getInputStream(); //不建议这样写，可能会乱码// byte[] buffer = new byte[1024];// int len;// while((len = is.read(buffer)) != -1)&#123;// String str = new String(buffer,0,len);// System.out.print(str);// &#125; //4.读取输入流中的数据 baos = new ByteArrayOutputStream(); byte[] buffer = new byte[5]; int len; while((len = is.read(buffer)) != -1)&#123; baos.write(buffer,0,len); &#125; System.out.println(baos.toString()); System.out.println(&quot;收到了来自于：&quot; + socket.getInetAddress().getHostAddress() + &quot;的数据&quot;); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; if(baos != null)&#123; //5.关闭资源 try &#123; baos.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; if(is != null)&#123; try &#123; is.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; if(socket != null)&#123; try &#123; socket.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; if(ss != null)&#123; try &#123; ss.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; 代码示例2：客户端发送文件给服务端，服务端将文件保存在本地。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/*这里涉及到的异常，应该使用try-catch-finally处理 */@Testpublic void client() throws IOException &#123; //1. Socket socket = new Socket(InetAddress.getByName(&quot;127.0.0.1&quot;),9090); //2. OutputStream os = socket.getOutputStream(); //3. FileInputStream fis = new FileInputStream(new File(&quot;beauty.jpg&quot;)); //4. byte[] buffer = new byte[1024]; int len; while((len = fis.read(buffer)) != -1)&#123; os.write(buffer,0,len); &#125; //5. fis.close(); os.close(); socket.close();&#125;/*这里涉及到的异常，应该使用try-catch-finally处理 */@Testpublic void server() throws IOException &#123; //1. ServerSocket ss = new ServerSocket(9090); //2. Socket socket = ss.accept(); //3. InputStream is = socket.getInputStream(); //4. FileOutputStream fos = new FileOutputStream(new File(&quot;beauty1.jpg&quot;)); //5. byte[] buffer = new byte[1024]; int len; while((len = is.read(buffer)) != -1)&#123; fos.write(buffer,0,len); &#125; //6. fos.close(); is.close(); socket.close(); ss.close();&#125; 代码示例3：从客户端发送文件给服务端，服务端保存到本地。并返回“发送成功”给客户端。并关闭相应的连接。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172/* 这里涉及到的异常，应该使用try-catch-finally处理 */@Testpublic void client() throws IOException &#123; //1. Socket socket = new Socket(InetAddress.getByName(&quot;127.0.0.1&quot;),9090); //2. OutputStream os = socket.getOutputStream(); //3. FileInputStream fis = new FileInputStream(new File(&quot;beauty.jpg&quot;)); //4. byte[] buffer = new byte[1024]; int len; while((len = fis.read(buffer)) != -1)&#123; os.write(buffer,0,len); &#125; //关闭数据的输出 socket.shutdownOutput(); //5.接收来自于服务器端的数据，并显示到控制台上 InputStream is = socket.getInputStream(); ByteArrayOutputStream baos = new ByteArrayOutputStream(); byte[] bufferr = new byte[20]; int len1; while((len1 = is.read(buffer)) != -1)&#123; baos.write(buffer,0,len1); &#125; System.out.println(baos.toString()); //6. fis.close(); os.close(); socket.close(); baos.close();&#125;/*这里涉及到的异常，应该使用try-catch-finally处理 */@Testpublic void server() throws IOException &#123; //1. ServerSocket ss = new ServerSocket(9090); //2. Socket socket = ss.accept(); //3. InputStream is = socket.getInputStream(); //4. FileOutputStream fos = new FileOutputStream(new File(&quot;beauty2.jpg&quot;)); //5. byte[] buffer = new byte[1024]; int len; while((len = is.read(buffer)) != -1)&#123; fos.write(buffer,0,len); &#125; System.out.println(&quot;图片传输完成&quot;); //6.服务器端给予客户端反馈 OutputStream os = socket.getOutputStream(); os.write(&quot;你好，美女，照片我已收到，非常漂亮！&quot;.getBytes()); //7. fos.close(); is.close(); socket.close(); ss.close(); os.close();&#125; UDP网络编程代码示例： 12345678910111213141516171819202122232425262728293031323334//发送端@Testpublic void sender() throws IOException &#123; DatagramSocket socket = new DatagramSocket(); String str = &quot;我是UDP方式发送的导弹&quot;; byte[] data = str.getBytes(); InetAddress inet = InetAddress.getLocalHost(); DatagramPacket packet = new DatagramPacket(data,0,data.length,inet,9090); socket.send(packet); socket.close();&#125;//接收端@Testpublic void receiver() throws IOException &#123; DatagramSocket socket = new DatagramSocket(9090); byte[] buffer = new byte[100]; DatagramPacket packet = new DatagramPacket(buffer,0,buffer.length); socket.receive(packet); System.out.println(new String(packet.getData(),0,packet.getLength())); socket.close();&#125; URL编程 URL(Uniform Resource Locator)的理解:统一资源定位符，对应着互联网的某一资源地址 URL的5个基本结构： http://localhost:8080/examples/beauty.jpg?username=Tom 协议 主机名 端口号 资源地址 参数列表 如何实例化: URL url = new URL(&quot;http://localhost:8080/examples/beauty.jpg?username=Tom&quot;); 常用方法： 可以读取、下载对应的url资源： 123456789101112131415161718192021222324252627282930313233343536373839404142434445public static void main(String[] args) &#123; HttpURLConnection urlConnection = null; InputStream is = null; FileOutputStream fos = null; try &#123; URL url = new URL(&quot;http://localhost:8080/examples/beauty.jpg&quot;); urlConnection = (HttpURLConnection) url.openConnection(); urlConnection.connect(); is = urlConnection.getInputStream(); fos = new FileOutputStream(&quot;day10\\\\beauty3.jpg&quot;); byte[] buffer = new byte[1024]; int len; while((len = is.read(buffer)) != -1)&#123; fos.write(buffer,0,len); &#125; System.out.println(&quot;下载完成&quot;); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; //关闭资源 if(is != null)&#123; try &#123; is.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; if(fos != null)&#123; try &#123; fos.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; if(urlConnection != null)&#123; urlConnection.disconnect(); &#125; &#125;&#125; 15_Java反射机制反射的概述 本章的主要内容 关于反射的理解:Reflection（反射)是被视为动态语言的关键，反射机制允许程序在执行期借助于Reflection API取得任何类的内部信息，并能直接操作任意对象的内部属性及方法。 框架 = 反射 + 注解 + 设计模式。 体会反射机制的“动态性” 12345678910111213141516171819202122232425262728293031323334353637//体会反射的动态性@Testpublic void test2()&#123; for(int i = 0;i &lt; 100;i++)&#123; int num = new Random().nextInt(3);//0,1,2 String classPath = &quot;&quot;; switch(num)&#123; case 0: classPath = &quot;java.util.Date&quot;; break; case 1: classPath = &quot;java.lang.Object&quot;; break; case 2: classPath = &quot;com.atguigu.java.Person&quot;; break; &#125; try &#123; Object obj = getInstance(classPath); System.out.println(obj); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125;/*创建一个指定类的对象。classPath:指定类的全类名 */public Object getInstance(String classPath) throws Exception &#123; Class clazz = Class.forName(classPath); return clazz.newInstance();&#125; 反射机制能提供的功能 相关API 12345java.lang.Class:反射的源头java.lang.reflect.Methodjava.lang.reflect.Fieldjava.lang.reflect.Constructor.... Class类的理解与获取Class的实例 Class类的理解 类的加载过程：程序经过javac.exe命令以后，会生成一个或多个字节码文件(.class结尾)。接着我们使用java.exe命令对某个字节码文件进行解释运行。相当于将某个字节码文件加载到内存中。此过程就称为类的加载。加载到内存中的类，我们就称为运行时类，此运行时类，就作为Class的一个实例。 换句话说，Class的实例就对应着一个运行时类。 加载到内存中的运行时类，会缓存一定的时间。在此时间之内，我们可以通过不同的方式来获取此运行时类。 获取Class实例的几种方式：（前三种方式需要掌握） 123456789101112131415161718192021222324 //方式一：调用运行时类的属性：.class Class clazz1 = Person.class; System.out.println(clazz1); //方式二：通过运行时类的对象,调用getClass() Person p1 = new Person(); Class clazz2 = p1.getClass(); System.out.println(clazz2); //方式三：调用Class的静态方法：forName(String classPath) Class clazz3 = Class.forName(&quot;com.atguigu.java.Person&quot;);// clazz3 = Class.forName(&quot;java.lang.String&quot;); System.out.println(clazz3); System.out.println(clazz1 == clazz2); System.out.println(clazz1 == clazz3); //方式四：使用类的加载器：ClassLoader (了解) ClassLoader classLoader = ReflectionTest.class.getClassLoader(); Class clazz4 = classLoader.loadClass(&quot;com.atguigu.java.Person&quot;); System.out.println(clazz4); System.out.println(clazz1 == clazz4); 总结：创建类的对象的方式? 方式一：new + 构造器 方式二：要创建Xxx类的对象，可以考虑：Xxx、Xxxs、XxxFactory、XxxBuilder类中查看是否有静态方法的存在。可以调用其静态方法，创建Xxx对象。 方式三：通过反射 Class实例可以是哪些结构的说明 了解ClassLoader 类的加载过程—-了解 类的加载器的作用 类的加载器的分类 Java类编译、运行的执行的流程 使用Classloader加载src目录下的配置文件 123456789101112131415161718192021222324@Test public void test2() throws Exception &#123; Properties pros = new Properties(); //此时的文件默认在当前的module下。 //读取配置文件的方式一：// FileInputStream fis = new FileInputStream(&quot;jdbc.properties&quot;);// FileInputStream fis = new FileInputStream(&quot;src\\\\jdbc1.properties&quot;);// pros.load(fis); //读取配置文件的方式二：使用ClassLoader //配置文件默认识别为：当前module的src下 ClassLoader classLoader = ClassLoaderTest.class.getClassLoader(); InputStream is = classLoader.getResourceAsStream(&quot;jdbc1.properties&quot;); pros.load(is); String user = pros.getProperty(&quot;user&quot;); String password = pros.getProperty(&quot;password&quot;); System.out.println(&quot;user = &quot; + user + &quot;,password = &quot; + password); &#125; 反射应用一：创建运行时类的对象 代码举例 1234Class&lt;Person&gt; clazz = Person.class;Person obj = clazz.newInstance();System.out.println(obj); 说明:newInstance():调用此方法，创建对应的运行时类的对象。内部调用了运行时类的空参的构造器。 要想此方法正常的创建运行时类的对象，要求： 运行时类必须提供空参的构造器 空参的构造器的访问权限得够。通常，设置为public。 在javabean中要求提供一个public的空参构造器。原因： 便于通过反射，创建运行时类的对象 便于子类继承此运行时类时，默认调用super()时，保证父类此构造器 反射应用二：获取运行时类的完整结构我们可以通过反射，获取对应的运行时类中所有的属性、方法、构造器、父类、接口、父类的泛型、包、注解、异常等。。。。 典型代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147@Testpublic void test1()&#123; Class clazz = Person.class; //获取属性结构 //getFields():获取当前运行时类及其父类中声明为public访问权限的属性 Field[] fields = clazz.getFields(); for(Field f : fields)&#123; System.out.println(f); &#125; System.out.println(); //getDeclaredFields():获取当前运行时类中声明的所属性。（不包含父类中声明的属性 Field[] declaredFields = clazz.getDeclaredFields(); for(Field f : declaredFields)&#123; System.out.println(f); &#125;&#125;@Testpublic void test1()&#123; Class clazz = Person.class; //getMethods():获取当前运行时类及其所父类中声明为public权限的方法 Method[] methods = clazz.getMethods(); for(Method m : methods)&#123; System.out.println(m); &#125; System.out.println(); //getDeclaredMethods():获取当前运行时类中声明的所方法。（不包含父类中声明的方法 Method[] declaredMethods = clazz.getDeclaredMethods(); for(Method m : declaredMethods)&#123; System.out.println(m); &#125;&#125;/* 获取构造器结构 */ @Test public void test1()&#123; Class clazz = Person.class; //getConstructors():获取当前运行时类中声明为public的构造器 Constructor[] constructors = clazz.getConstructors(); for(Constructor c : constructors)&#123; System.out.println(c); &#125; System.out.println(); //getDeclaredConstructors():获取当前运行时类中声明的所的构造器 Constructor[] declaredConstructors = clazz.getDeclaredConstructors(); for(Constructor c : declaredConstructors)&#123; System.out.println(c); &#125; &#125; /* 获取运行时类的父类 */ @Test public void test2()&#123; Class clazz = Person.class; Class superclass = clazz.getSuperclass(); System.out.println(superclass); &#125; /* 获取运行时类的带泛型的父类 */ @Test public void test3()&#123; Class clazz = Person.class; Type genericSuperclass = clazz.getGenericSuperclass(); System.out.println(genericSuperclass); &#125; /* 获取运行时类的带泛型的父类的泛型 代码：逻辑性代码 vs 功能性代码 */ @Test public void test4()&#123; Class clazz = Person.class; Type genericSuperclass = clazz.getGenericSuperclass(); ParameterizedType paramType = (ParameterizedType) genericSuperclass; //获取泛型类型 Type[] actualTypeArguments = paramType.getActualTypeArguments();// System.out.println(actualTypeArguments[0].getTypeName()); System.out.println(((Class)actualTypeArguments[0]).getName()); &#125; /* 获取运行时类实现的接口 */ @Test public void test5()&#123; Class clazz = Person.class; Class[] interfaces = clazz.getInterfaces(); for(Class c : interfaces)&#123; System.out.println(c); &#125; System.out.println(); //获取运行时类的父类实现的接口 Class[] interfaces1 = clazz.getSuperclass().getInterfaces(); for(Class c : interfaces1)&#123; System.out.println(c); &#125; &#125; /* 获取运行时类所在的包 */ @Test public void test6()&#123; Class clazz = Person.class; Package pack = clazz.getPackage(); System.out.println(pack); &#125; /* 获取运行时类声明的注解 */ @Test public void test7()&#123; Class clazz = Person.class; Annotation[] annotations = clazz.getAnnotations(); for(Annotation annos : annotations)&#123; System.out.println(annos); &#125; &#125; 反射应用三：调用运行时类的指定结构 调用指定的属性： 1234567891011121314151617@Testpublic void testField1() throws Exception &#123; Class clazz = Person.class; //创建运行时类的对象 Person p = (Person) clazz.newInstance(); //1. getDeclaredField(String fieldName):获取运行时类中指定变量名的属性 Field name = clazz.getDeclaredField(&quot;name&quot;); //2.保证当前属性是可访问的 name.setAccessible(true); //3.获取、设置指定对象的此属性值 name.set(p,&quot;Tom&quot;); System.out.println(name.get(p));&#125; 调用指定的方法： 1234567891011121314151617181920212223242526272829303132333435 @Test public void testMethod() throws Exception &#123; Class clazz = Person.class; //创建运行时类的对象 Person p = (Person) clazz.newInstance(); /* 1.获取指定的某个方法 getDeclaredMethod():参数1 ：指明获取的方法的名称 参数2：指明获取的方法的形参列表 */ Method show = clazz.getDeclaredMethod(&quot;show&quot;, String.class); //2.保证当前方法是可访问的 show.setAccessible(true); /* 3. 调用方法的invoke():参数1：方法的调用者 参数2：给方法形参赋值的实参 invoke()的返回值即为对应类中调用的方法的返回值。 */ Object returnValue = show.invoke(p,&quot;CHN&quot;); //String nation = p.show(&quot;CHN&quot;); System.out.println(returnValue); System.out.println(&quot;*************如何调用静态方法*****************&quot;); // private static void showDesc() Method showDesc = clazz.getDeclaredMethod(&quot;showDesc&quot;); showDesc.setAccessible(true); //如果调用的运行时类中的方法没返回值，则此invoke()返回null// Object returnVal = showDesc.invoke(null); Object returnVal = showDesc.invoke(Person.class); System.out.println(returnVal);//null &#125; 调用指定的构造器： 12345678910111213141516171819202122@Testpublic void testConstructor() throws Exception &#123; Class clazz = Person.class; //private Person(String name) /* 1.获取指定的构造器 getDeclaredConstructor():参数：指明构造器的参数列表 */ Constructor constructor = clazz.getDeclaredConstructor(String.class); //2.保证此构造器是可访问的 constructor.setAccessible(true); //3.调用此构造器创建运行时类的对象 Person per = (Person) constructor.newInstance(&quot;Tom&quot;); System.out.println(per);&#125; 反射应用四：动态代理 代理模式的原理：使用一个代理将对象包装起来, 然后用该代理对象取代原始对象。任何对原始对象的调用都要通过代理。代理对象决定是否以及何时将方法调用转到原始对象上。 静态代理 举例： 12345678//实现Runnable接口的方法创建多线程。Class MyThread implements Runnable&#123;&#125; //相当于被代理类Class Thread implements Runnable&#123;&#125; //相当于代理类main()&#123;MyThread t = new MyThread();Thread thread = new Thread(t);thread.start();//启动线程；调用线程的run()&#125; 静态代理的缺点： 代理类和目标对象的类都是在编译期间确定下来，不利于程序的扩展。 每一个代理类只能为一个接口服务，这样一来程序开发中必然产生过多的代理。 动态代理的特点：动态代理是指客户通过代理类来调用其它对象的方法，并且是在程序运行时根据需要动态创建目标类的代理对象。 动态代理的实现 需要解决的两个主要问题： 问题一：如何根据加载到内存中的被代理类，动态的创建一个代理类及其对象。（通过Proxy.newProxyInstance()实现） 问题二：当通过代理类的对象调用方法a时，如何动态的去调用被代理类中的同名方法a。(通过InvocationHandler接口的实现类及其方法invoke()) 代码实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106/** * * 动态代理的举例 * * @author shkstart * @create 2019 上午 10:18 */interface Human&#123; String getBelief(); void eat(String food);&#125;//被代理类class SuperMan implements Human&#123; @Override public String getBelief() &#123; return &quot;I believe I can fly!&quot;; &#125; @Override public void eat(String food) &#123; System.out.println(&quot;我喜欢吃&quot; + food); &#125;&#125;class HumanUtil&#123; public void method1()&#123; System.out.println(&quot;====================通用方法一====================&quot;); &#125; public void method2()&#123; System.out.println(&quot;====================通用方法二====================&quot;); &#125;&#125;class ProxyFactory&#123; //调用此方法，返回一个代理类的对象。解决问题一 public static Object getProxyInstance(Object obj)&#123;//obj:被代理类的对象 MyInvocationHandler handler = new MyInvocationHandler(); handler.bind(obj); return Proxy.newProxyInstance(obj.getClass().getClassLoader(),obj.getClass().getInterfaces(),handler); &#125;&#125;class MyInvocationHandler implements InvocationHandler&#123; private Object obj;//需要使用被代理类的对象进行赋值 public void bind(Object obj)&#123; this.obj = obj; &#125; //当我们通过代理类的对象，调用方法a时，就会自动的调用如下的方法：invoke() //将被代理类要执行的方法a的功能就声明在invoke()中 @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; HumanUtil util = new HumanUtil(); util.method1(); //method:即为代理类对象调用的方法，此方法也就作为了被代理类对象要调用的方法 //obj:被代理类的对象 Object returnValue = method.invoke(obj,args); util.method2(); //上述方法的返回值就作为当前类中的invoke()的返回值。 return returnValue; &#125;&#125;public class ProxyTest &#123; public static void main(String[] args) &#123; SuperMan superMan = new SuperMan(); //proxyInstance:代理类的对象 Human proxyInstance = (Human) ProxyFactory.getProxyInstance(superMan); //当通过代理类对象调用方法时，会自动的调用被代理类中同名的方法 String belief = proxyInstance.getBelief(); System.out.println(belief); proxyInstance.eat(&quot;四川麻辣烫&quot;); System.out.println(&quot;*****************************&quot;); NikeClothFactory nikeClothFactory = new NikeClothFactory(); ClothFactory proxyClothFactory = (ClothFactory) ProxyFactory.getProxyInstance(nikeClothFactory); proxyClothFactory.produceCloth(); &#125;&#125; 体会：反射的动态性。 16_Java8的其它新特性Java8新特性概述 Lambda表达式 Lambda表达式使用前后的对比： 举例一： 12345678910111213141516171819@Testpublic void test1()&#123; Runnable r1 = new Runnable() &#123; @Override public void run() &#123; System.out.println(&quot;我爱北京天安门&quot;); &#125; &#125;; r1.run(); System.out.println(&quot;***********************&quot;); Runnable r2 = () -&gt; System.out.println(&quot;我爱北京故宫&quot;); r2.run();&#125; 举例二： 12345678910111213141516171819202122232425262728@Testpublic void test2()&#123; Comparator&lt;Integer&gt; com1 = new Comparator&lt;Integer&gt;() &#123; @Override public int compare(Integer o1, Integer o2) &#123; return Integer.compare(o1,o2); &#125; &#125;; int compare1 = com1.compare(12,21); System.out.println(compare1); System.out.println(&quot;***********************&quot;); //Lambda表达式的写法 Comparator&lt;Integer&gt; com2 = (o1,o2) -&gt; Integer.compare(o1,o2); int compare2 = com2.compare(32,21); System.out.println(compare2); System.out.println(&quot;***********************&quot;); //方法引用 Comparator&lt;Integer&gt; com3 = Integer :: compare; int compare3 = com3.compare(32,21); System.out.println(compare3);&#125; Lambda表达式的基本语法： 举例： (o1,o2) -&gt; Integer.compare(o1,o2); 格式： -&gt; :lambda操作符 或 箭头操作符 -&gt;左边：lambda形参列表 （其实就是接口中的抽象方法的形参列表 -&gt;右边：lambda体 （其实就是重写的抽象方法的方法体 如何使用：分为六种情况 总结六种情况： -&gt; 左边：lambda形参列表的参数类型可以省略(类型推断)；如果lambda形参列表只一个参数，其一对()也可以省略 -&gt; 右边：lambda体应该使用一对{}包裹；如果lambda体只一条执行语句（可能是return语句，省略这一对{}和return关键字 函数式接口 函数式接口的使用说明 如果一个接口中，只声明了一个抽象方法，则此接口就称为函数式接口。 我们可以在一个接口上使用 @FunctionalInterface 注解，这样做可以检查它是否是一个函数式接口。 Lambda表达式的本质：作为函数式接口的实例 Java8中关于Lambda表达式提供的4个基本的函数式接口：具体使用： 总结 何时使用lambda表达式？ 当需要对一个函数式接口实例化的时候，可以使用lambda表达式。 何时使用给定的函数式接口？ 如果我们开发中需要定义一个函数式接口，首先看看在已有的jdk提供的函数式接口是否提供了能满足需求的函数式接口。如果有，则直接调用即可，不需要自己再自定义了。 方法引用 理解：方法引用可以看做是Lambda表达式深层次的表达。换句话说，方法引用就是Lambda表达式，也就是函数式接口的一个实例，通过方法的名字来指向一个方法。 使用情境：当要传递给Lambda体的操作，已经实现的方法了，可以使用方法引用！ 格式：类(或对象) :: 方法名 分为如下的三种情况： 情况1 对象 :: 非静态方法 情况2 类 :: 静态方法 情况3 类 :: 非静态方法 要求： 要求接口中的抽象方法的形参列表和返回值类型与方法引用的方法的形参列表和返回值类型相同！（针对于情况1和情况2） 当函数式接口方法的第一个参数是需要引用方法的调用者，并且第二个参数是需要引用方法的参数(或无参数)时：ClassName::methodName（针对于情况3） 使用建议：如果给函数式接口提供实例，恰好满足方法引用的使用情境，大家就可以考虑使用方法引用给函数式接口提供实例。如果大家不熟悉方法引用，那么还可以使用lambda表达式。 使用举例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110// 情况一：对象 :: 实例方法//Consumer中的void accept(T t)//PrintStream中的void println(T t)@Testpublic void test1() &#123; Consumer&lt;String&gt; con1 = str -&gt; System.out.println(str); con1.accept(&quot;北京&quot;); System.out.println(&quot;*******************&quot;); PrintStream ps = System.out; Consumer&lt;String&gt; con2 = ps::println; con2.accept(&quot;beijing&quot;);&#125;//Supplier中的T get()//Employee中的String getName()@Testpublic void test2() &#123; Employee emp = new Employee(1001,&quot;Tom&quot;,23,5600); Supplier&lt;String&gt; sup1 = () -&gt; emp.getName(); System.out.println(sup1.get()); System.out.println(&quot;*******************&quot;); Supplier&lt;String&gt; sup2 = emp::getName; System.out.println(sup2.get());&#125;// 情况二：类 :: 静态方法//Comparator中的int compare(T t1,T t2)//Integer中的int compare(T t1,T t2)@Testpublic void test3() &#123; Comparator&lt;Integer&gt; com1 = (t1,t2) -&gt; Integer.compare(t1,t2); System.out.println(com1.compare(12,21)); System.out.println(&quot;*******************&quot;); Comparator&lt;Integer&gt; com2 = Integer::compare; System.out.println(com2.compare(12,3));&#125;//Function中的R apply(T t)//Math中的Long round(Double d)@Testpublic void test4() &#123; Function&lt;Double,Long&gt; func = new Function&lt;Double, Long&gt;() &#123; @Override public Long apply(Double d) &#123; return Math.round(d); &#125; &#125;; System.out.println(&quot;*******************&quot;); Function&lt;Double,Long&gt; func1 = d -&gt; Math.round(d); System.out.println(func1.apply(12.3)); System.out.println(&quot;*******************&quot;); Function&lt;Double,Long&gt; func2 = Math::round; System.out.println(func2.apply(12.6));&#125;// 情况：类 :: 实例方法 (难度)// Comparator中的int comapre(T t1,T t2)// String中的int t1.compareTo(t2)@Testpublic void test5() &#123; Comparator&lt;String&gt; com1 = (s1,s2) -&gt; s1.compareTo(s2); System.out.println(com1.compare(&quot;abc&quot;,&quot;abd&quot;)); System.out.println(&quot;*******************&quot;); Comparator&lt;String&gt; com2 = String :: compareTo; System.out.println(com2.compare(&quot;abd&quot;,&quot;abm&quot;));&#125;//BiPredicate中的boolean test(T t1, T t2);//String中的boolean t1.equals(t2)@Testpublic void test6() &#123; BiPredicate&lt;String,String&gt; pre1 = (s1,s2) -&gt; s1.equals(s2); System.out.println(pre1.test(&quot;abc&quot;,&quot;abc&quot;)); System.out.println(&quot;*******************&quot;); BiPredicate&lt;String,String&gt; pre2 = String :: equals; System.out.println(pre2.test(&quot;abc&quot;,&quot;abd&quot;));&#125;// Function中的R apply(T t)// Employee中的String getName();@Testpublic void test7() &#123; Employee employee = new Employee(1001, &quot;Jerry&quot;, 23, 6000); Function&lt;Employee,String&gt; func1 = e -&gt; e.getName(); System.out.println(func1.apply(employee)); System.out.println(&quot;*******************&quot;); Function&lt;Employee,String&gt; func2 = Employee::getName; System.out.println(func2.apply(employee));&#125; 构造器引用与数组引用 构造器引用格式：类名::new 构造器引用使用要求：和方法引用类似，函数式接口的抽象方法的形参列表和构造器的形参列表一致。抽象方法的返回值类型即为构造器所属的类的类型 构造器引用举例： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950//Supplier中的T get() //Employee的空参构造器：Employee() @Test public void test1()&#123; Supplier&lt;Employee&gt; sup = new Supplier&lt;Employee&gt;() &#123; @Override public Employee get() &#123; return new Employee(); &#125; &#125;; System.out.println(&quot;*******************&quot;); Supplier&lt;Employee&gt; sup1 = () -&gt; new Employee(); System.out.println(sup1.get()); System.out.println(&quot;*******************&quot;); Supplier&lt;Employee&gt; sup2 = Employee :: new; System.out.println(sup2.get()); &#125;//Function中的R apply(T t) @Test public void test2()&#123; Function&lt;Integer,Employee&gt; func1 = id -&gt; new Employee(id); Employee employee = func1.apply(1001); System.out.println(employee); System.out.println(&quot;*******************&quot;); Function&lt;Integer,Employee&gt; func2 = Employee :: new; Employee employee1 = func2.apply(1002); System.out.println(employee1); &#125;//BiFunction中的R apply(T t,U u) @Test public void test3()&#123; BiFunction&lt;Integer,String,Employee&gt; func1 = (id,name) -&gt; new Employee(id,name); System.out.println(func1.apply(1001,&quot;Tom&quot;)); System.out.println(&quot;*******************&quot;); BiFunction&lt;Integer,String,Employee&gt; func2 = Employee :: new; System.out.println(func2.apply(1002,&quot;Tom&quot;)); &#125; 数组引用格式：数组类型[] :: new 数组引用举例： 1234567891011121314//Function中的R apply(T t)@Testpublic void test4()&#123; Function&lt;Integer,String[]&gt; func1 = length -&gt; new String[length]; String[] arr1 = func1.apply(5); System.out.println(Arrays.toString(arr1)); System.out.println(&quot;*******************&quot;); Function&lt;Integer,String[]&gt; func2 = String[] :: new; String[] arr2 = func2.apply(10); System.out.println(Arrays.toString(arr2));&#125; Stream API Stream API的理解： Stream关注的是对数据的运算，与CPU打交道集合关注的是数据的存储，与内存打交道 java8提供了一套api,使用这套api可以对内存中的数据进行过滤、排序、映射、归约等操作。类似于sql对数据库中表的相关操作。 注意点： Stream 自己不会存储元素。 Stream 不会改变源对象。相反，他们会返回一个持有结果的新Stream。 Stream 操作是延迟执行的。这意味着他们会等到需要结果的时候才执行。 Stream的使用流程： Stream的实例化 一系列的中间操作（过滤、映射、…) 终止操作 使用流程的注意点： 一个中间操作链，对数据源的数据进行处理 一旦执行终止操作，就执行中间操作链，并产生结果。之后，不会再被使用 步骤一：Stream实例化 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849//创建 Stream方式一：通过集合 @Test public void test1()&#123; List&lt;Employee&gt; employees = EmployeeData.getEmployees();// default Stream&lt;E&gt; stream() : 返回一个顺序流 Stream&lt;Employee&gt; stream = employees.stream();// default Stream&lt;E&gt; parallelStream() : 返回一个并行流 Stream&lt;Employee&gt; parallelStream = employees.parallelStream(); &#125; //创建 Stream方式二：通过数组 @Test public void test2()&#123; int[] arr = new int[]&#123;1,2,3,4,5,6&#125;; //调用Arrays类的static &lt;T&gt; Stream&lt;T&gt; stream(T[] array): 返回一个流 IntStream stream = Arrays.stream(arr); Employee e1 = new Employee(1001,&quot;Tom&quot;); Employee e2 = new Employee(1002,&quot;Jerry&quot;); Employee[] arr1 = new Employee[]&#123;e1,e2&#125;; Stream&lt;Employee&gt; stream1 = Arrays.stream(arr1); &#125; //创建 Stream方式三：通过Stream的of() @Test public void test3()&#123; Stream&lt;Integer&gt; stream = Stream.of(1, 2, 3, 4, 5, 6); &#125; //创建 Stream方式四：创建无限流 @Test public void test4()&#123;// 迭代// public static&lt;T&gt; Stream&lt;T&gt; iterate(final T seed, final UnaryOperator&lt;T&gt; f) //遍历前10个偶数 Stream.iterate(0, t -&gt; t + 2).limit(10).forEach(System.out::println);// 生成// public static&lt;T&gt; Stream&lt;T&gt; generate(Supplier&lt;T&gt; s) Stream.generate(Math::random).limit(10).forEach(System.out::println); &#125; 步骤二：中间操作 步骤三：终止操作 Collector需要使用Collectors提供实例。 Optional类的使用java.util.Optional类 理解：为了解决java中的空指针问题而生！ Optional 类(java.util.Optional) 是一个容器类，它可以保存类型T的值，代表这个值存在。或者仅仅保存null，表示这个值不存在。原来用 null 表示一个值不存在，现在 Optional 可以更好的表达这个概念。并且可以避免空指针异常。 常用方法： 1234567891011121314151617181920212223242526272829303132333435363738394041@Test public void test1()&#123; //empty():创建的Optional对象内部的value = null Optional&lt;Object&gt; op1 = Optional.empty(); if(!op1.isPresent())&#123;//Optional封装的数据是否包含数据 System.out.println(&quot;数据为空&quot;); &#125; System.out.println(op1); System.out.println(op1.isPresent()); //如果Optional封装的数据value为空，则get()报错。否则，value不为空时，返回value.// System.out.println(op1.get()); &#125; @Test public void test2()&#123; String str = &quot;hello&quot;;// str = null; //of(T t):封装数据t生成Optional对象。要求t非空，否则报错。 Optional&lt;String&gt; op1 = Optional.of(str); //get()通常与of()方法搭配使用。用于获取内部的封装的数据value String str1 = op1.get(); System.out.println(str1); &#125; @Test public void test3()&#123; String str = &quot;beijing&quot;; str = null; //ofNullable(T t) ：封装数据t赋给Optional内部的value。不要求t非空 Optional&lt;String&gt; op1 = Optional.ofNullable(str); //orElse(T t1):如果Optional内部的value非空，则返回此value值。如果 //value为空，则返回t1. String str2 = op1.orElse(&quot;shanghai&quot;); System.out.println(str2);// &#125; 典型练习：能保证如下的方法执行中不会出现空指针的异常。 12345678910111213141516171819202122232425//使用Optional类的getGirlName():public String getGirlName2(Boy boy)&#123; Optional&lt;Boy&gt; boyOptional = Optional.ofNullable(boy); //此时的boy1一定非空 Boy boy1 = boyOptional.orElse(new Boy(new Girl(&quot;迪丽热巴&quot;))); Girl girl = boy1.getGirl(); Optional&lt;Girl&gt; girlOptional = Optional.ofNullable(girl); //girl1一定非空 Girl girl1 = girlOptional.orElse(new Girl(&quot;古力娜扎&quot;)); return girl1.getName();&#125;@Testpublic void test5()&#123; Boy boy = null; boy = new Boy(); boy = new Boy(new Girl(&quot;苍老师&quot;)); String girlName = getGirlName2(boy); System.out.println(girlName);&#125;","categories":[{"name":"java","slug":"java","permalink":"http://110.42.136.235/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"http://110.42.136.235/tags/java/"}]},{"title":"shiro","slug":"shiro","date":"2022-04-27T13:25:52.000Z","updated":"2022-05-06T14:29:20.410Z","comments":true,"path":"2022/04/27/shiro/","link":"","permalink":"http://110.42.136.235/2022/04/27/shiro/","excerpt":"","text":"Shiro包含 Subject 用户 SecurityManager 管理所有用户 Realm 连接数据 第一步 引入依赖123456&lt;!-- shiro整合spring的包--&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt; &lt;artifactId&gt;shiro-spring&lt;/artifactId&gt; &lt;version&gt;1.4.1&lt;/version&gt; &lt;/dependency&gt; 第二步 写配置shiro的类认证和授权 123456789101112131415161718192021222324252627282930313233343536373839404142public class UserRealm extends AuthorizingRealm &#123; @Autowired UserService userService; @Autowired UserMapper userMapper; //授权 @Override protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principalCollection) &#123; System.out.println(&quot;执行授权方法=&gt;&quot;+&quot;doGetAuthorizationInfo&quot;); //simpleAuthorizationInfo SimpleAuthorizationInfo simpleAuthorizationInfo = new SimpleAuthorizationInfo(); //simpleAuthorizationInfo.addStringPermission(&quot;user:update&quot;); //获取当前登录对象 Subject subject = SecurityUtils.getSubject(); User currentUser = (User) subject.getPrincipal(); //查询当前用户是否有权限 simpleAuthorizationInfo.addStringPermission(currentUser.getPerm()); return simpleAuthorizationInfo; &#125; //认证 @Override protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken authenticationToken) throws AuthenticationException &#123; System.out.println(&quot;执行认证方法=&gt;&quot;+&quot;doGetAuthenticationInfo&quot;); //用户名和密码 String username = &quot;root&quot;; String password = &quot;123456&quot;; QueryWrapper&lt;User&gt; queryWrapper = new QueryWrapper&lt;&gt;(); queryWrapper.eq(&quot;username&quot;,&quot;zhangsan&quot;); List&lt;User&gt; users = userMapper.selectList(queryWrapper); User user = users.get(0); username=user.getUsername(); password=user.getPassword(); UsernamePasswordToken userToken = (UsernamePasswordToken) authenticationToken; if(!userToken.getUsername().equals(username))&#123; return null;//会自动抛出异常 &#125; //密码认证shiro会自动做 //可以加密：MD5 MD5盐值加密 return new SimpleAuthenticationInfo(user,password,&quot;&quot;); &#125;&#125; 配置 123456789101112131415161718192021222324252627282930313233343536373839404142434445@Configurationpublic class ShiroConfig &#123; //ShiroFilterFactoryBean第三步 @Bean public ShiroFilterFactoryBean getShiroFilterFactoryBean(@Qualifier(&quot;securityManager&quot;) DefaultWebSecurityManager defaultWebSecurityManager)&#123; ShiroFilterFactoryBean shiroFilterFactoryBean = new ShiroFilterFactoryBean(); //关联defaultWebSecurityManager，设置安全管理器 shiroFilterFactoryBean.setSecurityManager(defaultWebSecurityManager); /* anno:无需认证就可以访问 authc:必须认证了才能访问 user：必须拥有记住我才能访问 perms：拥有对某个资源的权限才能访问 role：拥有某个角色属性才能访问 */ Map&lt;String,String&gt; filterChainDefinitionMap = new LinkedHashMap&lt;&gt;(); filterChainDefinitionMap.put(&quot;/user/add&quot;,&quot;perms[user:add]&quot;); filterChainDefinitionMap.put(&quot;/user/update&quot;,&quot;perms[user:update]&quot;); //filterChainDefinitionMap.put(&quot;/user/*&quot;,&quot;authc&quot;); shiroFilterFactoryBean.setFilterChainDefinitionMap(filterChainDefinitionMap); //设置登录的请求 shiroFilterFactoryBean.setLoginUrl(&quot;/toLogin&quot;); shiroFilterFactoryBean.setUnauthorizedUrl(&quot;/unAuthor&quot;); return shiroFilterFactoryBean; &#125; //DefaultWebSecurityManager 第二步 @Bean(name=&quot;securityManager&quot;) public DefaultWebSecurityManager getDefaultWebSecurityManager(@Qualifier(&quot;userRealm&quot;) UserRealm userRealm)&#123; DefaultWebSecurityManager defaultWebSecurityManager = new DefaultWebSecurityManager(); //关联UserRealm defaultWebSecurityManager.setRealm(userRealm); return defaultWebSecurityManager; &#125; //创建Realm对象 需要自定义 第一步 @Bean public UserRealm userRealm()&#123; return new UserRealm(); &#125;&#125;","categories":[{"name":"安全框架","slug":"安全框架","permalink":"http://110.42.136.235/categories/%E5%AE%89%E5%85%A8%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"安全框架","slug":"安全框架","permalink":"http://110.42.136.235/tags/%E5%AE%89%E5%85%A8%E6%A1%86%E6%9E%B6/"}]},{"title":"依赖管理","slug":"依赖管理","date":"2022-04-27T12:58:14.000Z","updated":"2022-05-04T07:47:33.631Z","comments":true,"path":"2022/04/27/依赖管理/","link":"","permalink":"http://110.42.136.235/2022/04/27/%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86/","excerpt":"","text":"解决跨域问题1234567891011121314151617181920212223/** * 解决跨域问题 */@Configurationpublic class CorsConfig implements WebMvcConfigurer &#123; /** * 跨域配置 */ @Override public void addCorsMappings(CorsRegistry registry) &#123; //对那些请求路径进行跨域处理 registry.addMapping(&quot;/**&quot;) // 允许的请求头，默认允许所有的请求头 .allowedHeaders(&quot;*&quot;) // 允许的方法，默认允许GET、POST、HEAD .allowedMethods(&quot;*&quot;) // 探测请求有效时间，单位秒 .maxAge(1800) // 支持的域 .allowedOrigins(&quot;*&quot;); &#125;&#125; thymeleaf123456789&lt;!-- thymeleaf模板 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.thymeleaf&lt;/groupId&gt; &lt;artifactId&gt;thymeleaf-spring5&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.thymeleaf.extras&lt;/groupId&gt; &lt;artifactId&gt;thymeleaf-extras-java8time&lt;/artifactId&gt; &lt;/dependency&gt; MybatisPlus1234567891011121314151617181920&lt;!-- --&gt;&lt;!--MybatisPlus--&gt; &lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt; &lt;version&gt;3.5.1&lt;/version&gt; &lt;/dependency&gt;&lt;!-- lombok用于简化开发--&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;!-- mysql驱动--&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; shiro和Jwt123456789101112&lt;!-- Shiro包含Subject 用户SecurityManager 管理所有用户Realm 连接数据--&gt;&lt;!-- shiro整合spring的包--&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt; &lt;artifactId&gt;shiro-spring&lt;/artifactId&gt; &lt;version&gt;1.4.1&lt;/version&gt; &lt;/dependency&gt; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546JWT依赖&lt;!-- https://mvnrepository.com/artifact/io.jsonwebtoken/jjwt --&gt;&lt;dependency&gt; &lt;groupId&gt;io.jsonwebtoken&lt;/groupId&gt; &lt;artifactId&gt;jjwt&lt;/artifactId&gt; &lt;version&gt;0.9.1&lt;/version&gt;&lt;/dependency&gt;&lt;!-- 高版本jdk需要加入以下依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;javax.xml.bind&lt;/groupId&gt; &lt;artifactId&gt;jaxb-api&lt;/artifactId&gt; &lt;version&gt;2.3.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.sun.xml.bind&lt;/groupId&gt; &lt;artifactId&gt;jaxb-impl&lt;/artifactId&gt; &lt;version&gt;2.3.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.sun.xml.bind&lt;/groupId&gt; &lt;artifactId&gt;jaxb-core&lt;/artifactId&gt; &lt;version&gt;2.3.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.activation&lt;/groupId&gt; &lt;artifactId&gt;activation&lt;/artifactId&gt; &lt;version&gt;1.1.1&lt;/version&gt; &lt;/dependency&gt;&lt;!-- jjwt在0.10版本以后发生了较大变化，pom依赖要引入多个--&gt;&lt;dependency&gt; &lt;groupId&gt;io.jsonwebtoken&lt;/groupId&gt; &lt;artifactId&gt;jjwt-api&lt;/artifactId&gt; &lt;version&gt;0.11.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;io.jsonwebtoken&lt;/groupId&gt; &lt;artifactId&gt;jjwt-impl&lt;/artifactId&gt; &lt;version&gt;0.11.2&lt;/version&gt; &lt;scope&gt;runtime&lt;/scope&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;io.jsonwebtoken&lt;/groupId&gt; &lt;artifactId&gt;jjwt-jackson&lt;/artifactId&gt; &lt;!-- or jjwt-gson if Gson is preferred --&gt; &lt;version&gt;0.11.2&lt;/version&gt; &lt;scope&gt;runtime&lt;/scope&gt;&lt;/dependency&gt;","categories":[{"name":"依赖管理","slug":"依赖管理","permalink":"http://110.42.136.235/categories/%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86/"}],"tags":[{"name":"依赖管理","slug":"依赖管理","permalink":"http://110.42.136.235/tags/%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86/"}]},{"title":"java se基础","slug":"JAVA基础","date":"2022-04-27T12:58:14.000Z","updated":"2022-05-07T01:12:40.594Z","comments":true,"path":"2022/04/27/JAVA基础/","link":"","permalink":"http://110.42.136.235/2022/04/27/JAVA%E5%9F%BA%E7%A1%80/","excerpt":"","text":"Java基础编程1.Java语言概述课程整体内容概述 项目一：讲完流程控制时，可以做。第二章结束 项目二：讲完第四章面向对象（上），可以做 项目三：讲完第七章异常处理以后，可以做 附加项目一：讲完第七章异常处理以后，可以做 附加项目二：讲完第11章IO流以后，可以做 Java语言概述 基础常识 软件：即一系列按照特定顺序组织的计算机数据和指令的集合。分为：系统软件 和 应用软件 系统软件：windows , mac os , linux ,unix,android,ios,…. 应用软件：word ,ppt,画图板,… 人机交互方式： 图形化界面 vs 命令行方式 应用程序 = 算法 + 数据结构 常用DOS命令： 计算机语言的发展迭代史 第一代：机器语言 第二代：汇编语言 第三代：高级语言 面向过程：C,Pascal、Fortran 面向对象：Java,JS,Python,Scala,… Java语言版本迭代概述 1234567891011121314151991年 Green项目，开发语言最初命名为Oak (橡树)1994年，开发组意识到Oak 非常适合于互联网1996年，发布JDK 1.0，约8.3万个网页应用Java技术来制作1997年，发布JDK 1.1，JavaOne会议召开，创当时全球同类会议规模之最1998年，发布JDK 1.2，同年发布企业平台J2EE1999年，Java分成J2SE、J2EE和J2ME，JSP/Servlet技术诞生2004年，发布里程碑式版本：JDK 1.5，为突出此版本的重要性，更名为JDK 5.02005年，J2SE -&gt; JavaSE，J2EE -&gt; JavaEE，J2ME -&gt; JavaME2009年，Oracle公司收购SUN，交易价格74亿美元2011年，发布JDK 7.02014年，发布JDK 8.0，是继JDK 5.0以来变化最大的版本2017年，发布JDK 9.0，最大限度实现模块化2018年3月，发布JDK 10.0，版本号也称为18.32018年9月，发布JDK 11.0，版本号也称为18.9 Java语言应用的领域： Java Web开发：后台开发 大数据开发 Android应用程序开发：客户端开发 Java语言的特点 面向对象性： 两个要素：类、对象 三个特征：封装、继承、多态 健壮性： 去除了C语言中的指针 自动的垃圾回收机制 –&gt;仍然会出现内存溢出、内存泄漏 跨平台型： write once,run anywhere:一次编译，到处运行 功劳归功于：JVM 开发环境搭建 JDK、JRE、JVM的关系 JDK的下载、安装 下载：官网，github 安装：傻瓜式安装：JDK 、JRE 注意问题：安装软件的路径中不能包含中文、空格。 path环境变量的配置 为什么配置path环境变量？ path环境变量：windows操作系统执行命令时所要搜寻的路径 为什么要配置path:希望java的开发工具（javac.exe,java.exe)在任何的文件路径下都可以执行成功。 如何配置？ 第一个Java程序 开发体验——HelloWorld 编写：创建一个java源文件：HelloWorld.java 12345class HelloChina&#123; public static void main(String[] args)&#123; System.out.println(&quot;Hello,World!&quot;); &#125;&#125; 编译：javac HelloWorld.java 运行：java HelloChina 常见问题的解决 总结第一个程序 java程序编写-编译-运行的过程 编写：我们将编写的java代码保存在以”.java”结尾的源文件中 编译：使用javac.exe命令编译我们的java源文件。格式：javac 源文件名.java 运行：使用java.exe命令解释运行我们的字节码文件。 格式：java 类名 在一个java源文件中可以声明多个class。但是，只能最多有一个类声明为public的。而且要求声明为public的类的类名必须与源文件名相同。 程序的入口是main()方法。格式是固定的。 输出语句： System.out.println():先输出数据，然后换行 System.out.print():只输出数据 每一行执行语句都以”;”结束。 编译的过程：编译以后，会生成一个或多个字节码文件。字节码文件的文件名与java源文件中的类名相同。 注释与API文档 注释:Comment 分类： 单行注释：// 多行注释：/* */ 文档注释：/** */ 作用： 对所写的程序进行解释说明，增强可读性。方便自己，方便别人 调试所写的代码 特点： 单行注释和多行注释，注释了的内容不参与编译。 换句话说，编译以后生成的.class结尾的字节码文件中不包含注释掉的信息 文档注释内容可以被JDK提供的工具 javadoc 所解析，生成一套以网页文件形式体现的该程序的说明文档。 多行注释不可以嵌套使用 Java API 文档： API:application programming interface。习惯上：将语言提供的类库，都称为api. API文档：针对于提供的类库如何使用，给的一个说明书。类似于《新华字典》 良好的编程风格 EditPlus的使用 开发工具说明: EditPlus的使用： 2.基本语法关键字与标识符 java关键字的使用 定义：被Java语言赋予了特殊含义，用做专门用途的字符串（单词） 特点：关键字中所字母都为小写 具体哪些关键字： 保留字 现Java版本尚未使用，但以后版本可能会作为关键字使用。 具体哪些保留字：goto 、const 注意：自己命名标识符时要避免使用这些保留字 标识符的使用 定义：凡是自己可以起名字的地方都叫标识符。 涉及到的结构：包名、类名、接口名、变量名、方法名、常量名 规则：(必须要遵守。否则，编译不通过) 规范：（可以不遵守，不影响编译和运行。但是要求大家遵守） 注意点： 在起名字时，为了提高阅读性，要尽量意义，“见名知意”。 代码简洁之道整理人：尚硅谷 - 宋红康 有意义的命名 介绍 软件中随处可见命名。我们给变量、函数、参数、类和包命名。我们给源代码及源代码所在目录命名。 这么多命名要做，不妨做好它。下文列出了取个好名字的几条简单规则。 名副其实,见名知意 变量名太随意，haha、list1、ok、theList 这些都没啥意义 避免误导 包含List、import、java等类名、关键字或特殊字； 字母o与数字0，字母l与数字1等 提防使用不同之处较小的名称。比如：XYZControllerForEfficientHandlingOfStrings与XYZControllerForEfficientStorageOfStrings 做有意义的区分 反面教材，变量名：a1、a2、a3 避免冗余，不要出现Variable、表字段中避免出现table、字符串避免出现nameString，直接name就行，知道是字符串类型 再比如：定义了两个类：Customer类和CustomerObject类，如何区分？ 定义了三个方法：getActiveAccount()、getActiveAccounts()、getActiveAccountInfo()，如何区分？ 使用读得出来的名称 不要使用自己拼凑出来的单词，比如：xsxm(学生姓名)；genymdhms(生成日期，年、月、日、时、分、秒) 所谓的驼峰命名法，尽量使用完整的单词 使用可搜索的名称 一些常量，最好不直接使用数字，而指定一个变量名，这个变量名可以便于搜索到. 比如：找MAX_CLASSES_PER_STUDENT很容易，但想找数字7就麻烦了。 避免使用编码 匈牙利语标记法 即变量名表明该变量数据类型的小写字母开始。例如，szCmdLine的前缀sz表示“以零结束的字符串”。 成员前缀 避免使用前缀，但是Android中一个比较好的喜欢用m表示私有等，个人感觉比较好 接口和实现 作者不喜欢把接口使用I来开头，实现也希望只是在后面添加Imp 避免思维映射 比如传统上惯用单字母名称做循环计数器。所以就不要给一些非计数器的变量命名为：i、j、k等 类名 类名与对象名应该是名词与名词短语。如Customer、WikiPage、Account和AddressParser。避免使用Data或Info这样的类名。 不能使动词。比如：Manage、Process 方法名 方法名应当是动词或者动词短语。如postPayment、deletePage或save 别扮可爱 有的变量名叫haha、banana 别用eatMyShorts()表示abort() 每个概念对应一个词 项目中同时出现controllers与managers，为什么不统一使用其中一种？ 对于那些会用到你代码的程序员，一以贯之的命名法简直就是天降福音。 别用双关语 有时可能使用add并不合适，比例insert、append。add表示完整的新添加的含义。 使用解决方案领域名称 看代码的都是程序员，所以尽量用那些计算机科学术语、算法名、模式名、数学术语， 依据问题所涉领域来命名不算是聪明的做法。 使用源自所涉问题领域的名称 如果不能用程序员熟悉的术语来给手头的工作命名，就采用从所涉问题领域而来的名称吧。 至少，负责维护代码的程序员就能去请教领域专家了。 添加有意义的语境 可以把相关的变量放到一个类中，使用这个类来表明语境。 不要添加没用的语境 名字中带有项目的缩写，这样完全没有必要。比如有一个名为“加油站豪华版”（Gas Station Deluxe）的项目， 在其中给每个类添加GSD前缀就不是什么好策略。 最后的话 取好名字最难的地方在于需要良好的描述技巧和共有文化背景。 变量的使用(重点) 变量的分类 按数据类型分类 整型：byte(1字节=8bit) \\ short(2字节) \\ int(4字节) \\ long(8字节) byte范围：-128 ~ 127 声明long型变量，必须以”l”或”L”结尾 通常，定义整型变量时，使用int型。 整型的常量，默认类型是：int型 浮点型：float(4字节) \\ double(8字节) 浮点型，表示带小数点的数值 float表示数值的范围比long还大 定义float类型变量时，变量要以”f”或”F”结尾 通常，定义浮点型变量时，使用double型。 浮点型的常量，默认类型为：double 字符型：char (1字符=2字节) 定义char型变量，通常使用一对’’,内部只能写一个字符 表示方式：1.声明一个字符 2.转义字符 3.直接使用Unicode 值来表示字符型常量 布尔型：boolean 只能取两个值之一：true 、 false 常常在条件判断、循环结构中使用 按声明的位置分类(了解) 定义变量的格式： 数据类型 变量名 = 变量值; 数据类型 变量名;变量名 = 变量值; 变量使用的注意点： 变量必须先声明，后使用 变量都定义在其作用域内。在作用域内，它是有效的。换句话说，出了作用域，就失效了 同一个作用域内，不可以声明两个同名的变量 基本数据类型变量间运算规则 涉及到的基本数据类型：除了boolean之外的其他7种 自动类型转换(只涉及7种基本数据类型） 结论：当容量小的数据类型的变量与容量大的数据类型的变量做运算时，结果自动提升为容量大的数据类型。 byte 、char 、short –&gt; int –&gt; long –&gt; float –&gt; double 特别的：当byte、char、short三种类型的变量做运算时，结果为int型 说明：此时的容量大小指的是，表示数的范围的大和小。比如：float容量要大于long的容量 强制类型转换(只涉及7种基本数据类型）：自动类型提升运算的逆运算。 需要使用强转符：() 注意点：强制类型转换，可能导致精度损失。 String与8种基本数据类型间的运算 String属于引用数据类型,翻译为：字符串 声明String类型变量时，使用一对”” String可以和8种基本数据类型变量做运算，且运算只能是连接运算：+ 运算的结果仍然是String类型 避免： 123String s = 123;//编译错误String s1 = &quot;123&quot;;int i = (int)s1;//编译错误 进制（了解） 编程中涉及的进制及表示方式： 二进制的使用说明： 计算机底层的存储方式：所有数字在计算机底层都以二进制形式存在。 二进制数据的存储方式：所有的数值，不管正负，底层都以补码的方式存储。 原码、反码、补码的说明： 正数：三码合一 负数： 进制间的转换： 图示： 图示二进制转换为十进制： 图示十进制转换为二进制： 二进制与八进制、十六进制间的转换： 运算符1-算术运算符 算术运算符： + - + - * / % (前)++ (后)++ (前)– (后)– + 典型代码 123456789101112131415161718192021222324252627282930313233343536373839404142//除号：/int num1 = 12;int num2 = 5;int result1 = num1 / num2;System.out.println(result1);//2// %:取余运算//结果的符号与被模数的符号相同//开发中，经常使用%来判断能否被除尽的情况。int m1 = 12;int n1 = 5;System.out.println(&quot;m1 % n1 = &quot; + m1 % n1); int m2 = -12;int n2 = 5;System.out.println(&quot;m2 % n2 = &quot; + m2 % n2); int m3 = 12;int n3 = -5;System.out.println(&quot;m3 % n3 = &quot; + m3 % n3); int m4 = -12;int n4 = -5;System.out.println(&quot;m4 % n4 = &quot; + m4 % n4);//(前)++ :先自增1，后运算//(后)++ :先运算，后自增1int a1 = 10;int b1 = ++a1;System.out.println(&quot;a1 = &quot; + a1 + &quot;,b1 = &quot; + b1);int a2 = 10;int b2 = a2++;System.out.println(&quot;a2 = &quot; + a2 + &quot;,b2 = &quot; + b2);int a3 = 10;++a3;//a3++;int b3 = a3;//(前)-- :先自减1，后运算//(后)-- :先运算，后自减1int a4 = 10;int b4 = a4--;//int b4 = --a4;System.out.println(&quot;a4 = &quot; + a4 + &quot;,b4 = &quot; + b4); 特别说明 (前)++ :先自增1，后运算；(后)++ :先运算，后自增1 (前)– :先自减1，后运算；(后)– :先运算，后自减1 连接符：+：只能使用在String与其他数据类型变量之间使用。 2-赋值运算符 赋值运算符：= += -= *= /= %= 典型代码 1234567891011121314151617int i2,j2;//连续赋值i2 = j2 = 10;//***************int i3 = 10,j3 = 20;int num1 = 10;num1 += 2;//num1 = num1 + 2;System.out.println(num1);//12 int num2 = 12;num2 %= 5;//num2 = num2 % 5;System.out.println(num2); short s1 = 10;//s1 = s1 + 2;//编译失败s1 += 2;//结论：不会改变变量本身的数据类型System.out.println(s1); 特别说明 运算的结果不会改变变量本身的数据类型 开发中，如果希望变量实现+1的操作，有几种方法？(前提：int num = 10;) 123//方式一：num = num + 1;//方式二：num += 1; //方式三：num++; (推荐) 3-比较运算符 比较运算符（关系运算符）: == != &gt; &lt; &gt;= &lt;= instanceof 典型代码 12345678910int i = 10;int j = 20; System.out.println(i == j);//falseSystem.out.println(i = j);//20 boolean b1 = true;boolean b2 = false;System.out.println(b2 == b1);//falseSystem.out.println(b2 = b1);//true 特别说明 比较运算符的结果是boolean类型 &lt; &gt; &gt;= &lt;= :只能使用在数值类型的数据之间。 == 和 !=: 不仅可以使用在数值类型数据之间，还可以使用在其他引用类型变量之间。 1234Account acct1 = new Account(1000);Account acct2 = new Account(1000);boolean b1 = (acct1 == acct2);//比较两个Account是否是同一个账户。boolean b2 = (acct1 != acct2);// 4-逻辑运算符 逻辑运算符：&amp; &amp;&amp; | || ! ^ 典型代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253//区分&amp; 与 &amp;&amp;//相同点1：&amp; 与 &amp;&amp; 的运算结果相同//相同点2：当符号左边是true时，二者都会执行符号右边的运算//不同点：当符号左边是false时，&amp;继续执行符号右边的运算。&amp;&amp;不再执行符号右边的运算。//开发中，推荐使用&amp;&amp;boolean b1 = true;b1 = false;int num1 = 10;if(b1 &amp; (num1++ &gt; 0))&#123; System.out.println(&quot;我现在在北京&quot;);&#125;else&#123; System.out.println(&quot;我现在在南京&quot;);&#125; System.out.println(&quot;num1 = &quot; + num1); boolean b2 = true;b2 = false;int num2 = 10;if(b2 &amp;&amp; (num2++ &gt; 0))&#123; System.out.println(&quot;我现在在北京&quot;);&#125;else&#123; System.out.println(&quot;我现在在南京&quot;);&#125; System.out.println(&quot;num2 = &quot; + num2); // 区分：| 与 || //相同点1：| 与 || 的运算结果相同//相同点2：当符号左边是false时，二者都会执行符号右边的运算//不同点3：当符号左边是true时，|继续执行符号右边的运算，而||不再执行符号右边的运算//开发中，推荐使用||boolean b3 = false;b3 = true;int num3 = 10;if(b3 | (num3++ &gt; 0))&#123; System.out.println(&quot;我现在在北京&quot;);&#125;else&#123; System.out.println(&quot;我现在在南京&quot;);&#125;System.out.println(&quot;num3 = &quot; + num3); boolean b4 = false;b4 = true;int num4 = 10;if(b4 || (num4++ &gt; 0))&#123; System.out.println(&quot;我现在在北京&quot;);&#125;else&#123; System.out.println(&quot;我现在在南京&quot;);&#125;System.out.println(&quot;num4 = &quot; + num4); 特别说明 逻辑运算符操作的都是boolean类型的变量。而且结果也是boolean类型 5-位运算符 位运算符：&lt;&lt; &gt;&gt; &gt;&gt;&gt; &amp; | ^ ~ 典型代码 1234567891011int i = 21;i = -21;System.out.println(&quot;i &lt;&lt; 2 :&quot; + (i &lt;&lt; 2));System.out.println(&quot;i &lt;&lt; 3 :&quot; + (i &lt;&lt; 3));System.out.println(&quot;i &lt;&lt; 27 :&quot; + (i &lt;&lt; 27)); int m = 12;int n = 5;System.out.println(&quot;m &amp; n :&quot; + (m &amp; n));System.out.println(&quot;m | n :&quot; + (m | n));System.out.println(&quot;m ^ n :&quot; + (m ^ n)); 面试题 你能否写出最高效的2 * 8的实现方式？ 答案：2 &lt;&lt; 3 或 8 &lt;&lt; 1 特别说明 位运算符操作的都是整型的数据 &lt;&lt; ：在一定范围内，每向左移1位，相当于 * 2;&gt;&gt; :在一定范围内，每向右移1位，相当于 / 2 典型题目： 交换两个变量的值。 实现60的二进制到十六进制的转换 6-三元运算符 三元运算符：(条件表达式)? 表达式1 : 表达式2 典型代码 获取两个整数的较大值2.获取三个数的最大值 特别说明 条件表达式的结果为boolean类型 根据条件表达式真或假，决定执行表达式1，还是表达式2. 如果表达式为true，则执行表达式1。 如果表达式为false，则执行表达式2。 表达式1 和表达式2要求是一致的。 三元运算符可以嵌套使用 凡是可以使用三元运算符的地方，都可以改写为if-else反之，不成立。 如果程序既可以使用三元运算符，又可以使用if-else结构，那么优先选择三元运算符。原因：简洁、执行效率高。 流程控制 顺序结构：程序从上到下执行。 分支结构： if-else if- else if - else if -else switch-case 循环结构： for while do-while 分支结构 if-else条件判断 结构 结构一：if(条件表达式){执行表达式 } 结构二：二选一if(条件表达式){执行表达式1 }else{执行表达式2 } 结构三：n选一if(条件表达式){执行表达式1 }else if(条件表达式){执行表达式2 }else if(条件表达式){执行表达式3 }…else{执行表达式n } 说明： else 结构是可选的。 针对于条件表达式： 如果多个条件表达式之间是“互斥”关系(或没有交集的关系),哪个判断和执行语句声明在上面还是下面，无所谓。 如果多个条件表达式之间有交集的关系，需要根据实际情况，考虑清楚应该将哪个结构声明在上面。 如果多个条件表达式之间有包含的关系，通常情况下，需要将范围小的声明在范围大的上面。否则，范围小的就没机会执行了。 if-else结构是可以相互嵌套的。 如果if-else结构中的执行语句只有一行时，对应的一对{}可以省略的。但是，不建议大家省略。 switch-case选择结构 结构 123456789101112switch(表达式)&#123;case 常量1: 执行语句1; //break;case 常量2: 执行语句2; //break;...default: 执行语句n; //break;&#125; 说明： 根据switch表达式中的值，依次匹配各个case中的常量。一旦匹配成功，则进入相应case结构中，调用其执行语句。当调用完执行语句以后，则仍然继续向下执行其他case结构中的执行语句，直到遇到break关键字或此switch-case结构 末尾结束为止。 break,可以使用在switch-case结构中，表示一旦执行到此关键字，就跳出switch-case结构 switch结构中的表达式，只能是如下的6种数据类型之一：byte 、short、char、int、枚举类型(JDK5.0新增)、String类型(JDK7.0新增) case 之后只能声明常量。不能声明范围。 break关键字是可选的。 default:相当于if-else结构中的else. default结构是可选的，而且位置是灵活的。 如果switch-case结构中的多个case的执行语句相同，则可以考虑进行合并。 循环结构 循环结构的四要素 ① 初始化条件 ② 循环条件 —&gt;是boolean类型 ③ 循环体 ④ 迭代条件 说明：通常情况下，循环结束都是因为②中循环条件返回false了。 三种循环结构： for循环结构 1234for(①;②;④)&#123; ③&#125;执行过程：① - ② - ③ - ④ - ② - ③ - ④ - ... - ② while循环结构 12345678①while(②)&#123; ③; ④;&#125;执行过程：① - ② - ③ - ④ - ② - ③ - ④ - ... - ②说明：写while循环千万小心不要丢了迭代条件。一旦丢了，就可能导致死循环！ for和while循环总结： 开发中，基本上我们都会从for、while中进行选择，实现循环结构。 for循环和while循环是可以相互转换的！ 区别：for循环和while循环的初始化条件部分的作用范围不同。 我们写程序，要避免出现死循环。 do-while循环结构 123456①do&#123; ③; ④;&#125;while(②);执行过程：① - ③ - ④ - ② - ③ - ④ - ... - ② 说明： 1.do-while循环至少会执行一次循环体！ 2.开发中，使用for和while更多一些。较少使用do-while “无限循环”结构: while(true) 或 for(;;) 总结：如何结束一个循环结构？ 方式一：当循环条件是false时 方式二：在循环体中，执行break 嵌套循环 嵌套循环:将一个循环结构A声明在另一个循环结构B的循环体中,就构成了嵌套循环 内层循环：循环结构A 外层循环：循环结构B 说明： 内层循环结构遍历一遍，只相当于外层循环循环体执行了一次 假设外层循环需要执行m次，内层循环需要执行n次。此时内层循环的循环体一共执行了m * n次 外层循环控制行数，内层循环控制列数 典型练习 12345678910111213141516171819202122232425262728293031//练习一：/**************************/for(int j = 1;j &lt;= 4;j++ )&#123; for(int i = 1;i &lt;= 6;i++)&#123; System.out.print(&#x27;*&#x27;); &#125; System.out.println();&#125;//练习二：/* i(行号) j(*的个数)* 1 1** 2 2*** 3 3**** 4 4***** 5 5*/ for(int i = 1;i &lt;= 5;i++)&#123;//控制行数 for(int j = 1;j &lt;= i;j++)&#123;//控制列数 System.out.print(&quot;*&quot;); &#125; System.out.println();&#125;//练习三：九九乘法表//练习四：100以内的质数 补充:衡量一个功能代码的优劣： 正确性 可读性 健壮性 高效率与低存储：时间复杂度 、空间复杂度 （衡量算法的好坏） 如何理解流程控制的练习：流程控制结构的使用 + 算法逻辑 关键字：break和continue 使用范围 循环中使用的作用(不同点) 相同点 break: switch-case break: 循环结构中 结束当前循环 关键字后面不能声明执行语句 continue: 循环结构中 结束当次循环 关键字后面不能声明执行语句 补充：带标签的break和continue的使用 return在方法中讲。 补充：Scanner类的使用123456789101112131415161718192021222324252627282930313233343536373839404142434445/*如何从键盘获取不同类型的变量：需要使用Scanner类具体实现步骤：1.导包：import java.util.Scanner;2.Scanner的实例化:Scanner scan = new Scanner(System.in);3.调用Scanner类的相关方法（next() / nextXxx()），来获取指定类型的变量注意：需要根据相应的方法，来输入指定类型的值。如果输入的数据类型与要求的类型不匹配时，会报异常：InputMisMatchException导致程序终止。*///1.导包：import java.util.Scanner;import java.util.Scanner;class ScannerTest&#123; public static void main(String[] args)&#123; //2.Scanner的实例化 Scanner scan = new Scanner(System.in); //3.调用Scanner类的相关方法 System.out.println(&quot;请输入你的姓名：&quot;); String name = scan.next(); System.out.println(name); System.out.println(&quot;请输入你的芳龄：&quot;); int age = scan.nextInt(); System.out.println(age); System.out.println(&quot;请输入你的体重：&quot;); double weight = scan.nextDouble(); System.out.println(weight); System.out.println(&quot;你是否相中我了呢？(true/false)&quot;); boolean isLove = scan.nextBoolean(); System.out.println(isLove); //对于char型的获取，Scanner没有提供相关的方法。只能获取一个字符串 System.out.println(&quot;请输入你的性别：(男/女)&quot;); String gender = scan.next();//&quot;男&quot; char genderChar = gender.charAt(0);//获取索引为0位置上的字符 System.out.println(genderChar); &#125;&#125; 3.数组数组的概述 数组的理解：数组(Array)，是多个相同类型数据按一定顺序排列的集合，并使用一个名字命名，并通过编号的方式对这些数据进行统一管理。 数组相关的概念： 数组名 元素 角标、下标、索引 数组的长度：元素的个数 数组的特点： 数组是有序排列的 数组属于引用数据类型的变量。数组的元素，既可以是基本数据类型，也可以是引用数据类型 创建数组对象会在内存中开辟一整块连续的空间 数组的长度一旦确定，就不能修改。 数组的分类： 按照维数：一维数组、二维数组、。。。 按照数组元素的类型：基本数据类型元素的数组、引用数据类型元素的数组 数据结构： 数据与数据之间的逻辑关系：集合、一对一、一对多、多对多 数据的存储结构： 线性表：顺序表（比如：数组）、链表、栈、队列 树形结构：二叉树 图形结构： 算法： 排序算法： 搜索算法： 一维数组 一维数组的声明与初始化 1234567891011121314151617181920 //1. 一维数组的声明和初始化 int num;//声明 num = 10;//初始化 int id = 1001;//声明 + 初始化 int[] ids;//声明 //1.1 静态初始化:数组的初始化和数组元素的赋值操作同时进行 ids = new int[]&#123;1001,1002,1003,1004&#125;; //1.2动态初始化:数组的初始化和数组元素的赋值操作分开进行 String[] names = new String[5]; //错误的写法：// int[] arr1 = new int[];// int[5] arr2 = new int[5];// int[] arr3 = new int[3]&#123;1,2,3&#125;; //也是正确的写法： int[] arr4 = &#123;1,2,3,4,5&#125;;//类型推断 //总结：数组一旦初始化完成，其长度就确定了。 一维数组元素的引用： 12345678 //2.如何调用数组的指定位置的元素:通过角标的方式调用。 //数组的角标（或索引）从0开始的，到数组的长度-1结束。 names[0] = &quot;王铭&quot;; names[1] = &quot;王赫&quot;; names[2] = &quot;张学良&quot;; names[3] = &quot;孙居龙&quot;; names[4] = &quot;王宏志&quot;;//charAt(0)// names[5] = &quot;周扬&quot;; 数组的属性：length 1234//3.如何获取数组的长度。//属性:lengthSystem.out.println(names.length);//5System.out.println(ids.length); 一维数组的遍历 12345678910//4.如何遍历数组/*System.out.println(names[0]);System.out.println(names[1]);System.out.println(names[2]);System.out.println(names[3]);System.out.println(names[4]);*/for(int i = 0;i &lt; names.length;i++)&#123; System.out.println(names[i]);&#125; 一维数组元素的默认初始化值 数组元素是整型：0 数组元素是浮点型：0.0 数组元素是char型：0或’\\u0000’，而非’0’ 数组元素是boolean型：false 数组元素是引用数据类型：null 一维数组的内存解析 二维数组 如何理解二维数组？ 对于二维数组的理解，我们可以看成是一维数组array1又作为另一个一维数组array2的元素而存在。 其实，从数组底层的运行机制来看，其实没有多维数组。 二维数组的声明与初始化 1234567891011121314151617 //1.二维数组的声明和初始化 int[] arr = new int[]&#123;1,2,3&#125;;//一维数组 //静态初始化 int[][] arr1 = new int[][]&#123;&#123;1,2,3&#125;,&#123;4,5&#125;,&#123;6,7,8&#125;&#125;; //动态初始化1 String[][] arr2 = new String[3][2]; //动态初始化2 String[][] arr3 = new String[3][]; //错误的情况 // String[][] arr4 = new String[][4];// String[4][3] arr5 = new String[][];// int[][] arr6 = new int[4][3]&#123;&#123;1,2,3&#125;,&#123;4,5&#125;,&#123;6,7,8&#125;&#125;; //也是正确的写法： int[] arr4[] = new int[][]&#123;&#123;1,2,3&#125;,&#123;4,5,9,10&#125;,&#123;6,7,8&#125;&#125;; int[] arr5[] = &#123;&#123;1,2,3&#125;,&#123;4,5&#125;,&#123;6,7,8&#125;&#125;; 如何调用二维数组元素: 12345System.out.println(arr1[0][1]);//2System.out.println(arr2[1][1]);//nullarr3[1] = new String[4];System.out.println(arr3[1][0]); 二维数组的属性： 1234//3.获取数组的长度System.out.println(arr4.length);//3System.out.println(arr4[0].length);//3System.out.println(arr4[1].length);//4 遍历二维数组元素 12345678//4.如何遍历二维数组for(int i = 0;i &lt; arr4.length;i++)&#123; for(int j = 0;j &lt; arr4[i].length;j++)&#123; System.out.print(arr4[i][j] + &quot; &quot;); &#125; System.out.println();&#125; 二维数组元素的默认初始化值 规定：二维数组分为外层数组的元素，内层数组的元素 int[][] arr = new int[4][3]; 外层元素：arr[0],arr[1]等 内层元素：arr[0][0]``,arr[1][2]等 针对于初始化方式一：比如：int[][] arr = new int[4][3]; 外层元素的初始化值为：地址值 内层元素的初始化值为：与一维数组初始化情况相同 针对于初始化方式二：比如：int[][] arr = new int[4][]; 外层元素的初始化值为：null 内层元素的初始化值为：不能调用，否则报错。 二维数组的内存结构 数组的常见算法 数组的创建与元素赋值：杨辉三角（二维数组）、回形数（二维数组）、6个数，1-30之间随机生成且不重复。 针对于数值型的数组：最大值、最小值、总和、平均数等 数组的赋值与复制 12int[] array1,array2;array1 = new int[]&#123;1,2,3,4&#125;; 赋值： array2 = array1; 如何理解：将array1保存的数组的地址值赋给了array2，使得array1和array2共同指向堆空间中的同一个数组实体。 复制： ```javaarray2 = new int[array1.length];for(int i = 0;i &lt; array2.length;i++){array2[i] = array1[i];}123456789101112131415161718192021 2. 如何理解：我们通过new的方式，给array2在堆空间中新开辟了数组的空间。将array1数组中的元素值一个一个的赋值到array2数组中。 ![image-20211127190254250](JAVA基础.assets/image-20211127190254250.png)4. 数组元素的反转 ```java //方法一： // for(int i = 0;i &lt; arr.length / 2;i++)&#123; // String temp = arr[i]; // arr[i] = arr[arr.length - i -1]; // arr[arr.length - i -1] = temp; // &#125; //方法二： // for(int i = 0,j = arr.length - 1;i &lt; j;i++,j--)&#123; // String temp = arr[i]; // arr[i] = arr[j]; // arr[j] = temp; // &#125; 数组中指定元素的查找：搜索、检索 线性查找： 实现思路：通过遍历的方式，一个一个的数据进行比较、查找。 适用性：具有普遍适用性。 二分法查找： 实现思路：每次比较中间值，折半的方式检索。 适用性：（前提：数组必须有序） 数组的排序算法 理解： 衡量排序算法的优劣：时间复杂度、空间复杂度、稳定性 排序的分类：内部排序 与 外部排序（需要借助于磁盘） 不同排序算法的时间复杂度 手写冒泡排序 1234567891011121314int[] arr = new int[]&#123;43,32,76,-98,0,64,33,-21,32,99&#125;;//冒泡排序for(int i = 0;i &lt; arr.length - 1;i++)&#123; for(int j = 0;j &lt; arr.length - 1 - i;j++)&#123; if(arr[j] &gt; arr[j + 1])&#123; int temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; &#125; &#125; &#125; Arrays工具类的使用 理解： 定义在java.util包下。 Arrays:提供了很多操作数组的方法。 使用： 12345678910111213141516171819202122232425262728//1.boolean equals(int[] a,int[] b):判断两个数组是否相等。int[] arr1 = new int[]&#123;1,2,3,4&#125;;int[] arr2 = new int[]&#123;1,3,2,4&#125;;boolean isEquals = Arrays.equals(arr1, arr2);System.out.println(isEquals);//2.String toString(int[] a):输出数组信息。System.out.println(Arrays.toString(arr1)); //3.void fill(int[] a,int val):将指定值填充到数组之中。Arrays.fill(arr1,10);System.out.println(Arrays.toString(arr1)); //4.void sort(int[] a):对数组进行排序。Arrays.sort(arr2);System.out.println(Arrays.toString(arr2));//5.int binarySearch(int[] a,int key)int[] arr3 = new int[]&#123;-98,-34,2,34,54,66,79,105,210,333&#125;;int index = Arrays.binarySearch(arr3, 210);if(index &gt;= 0)&#123; System.out.println(index);&#125;else&#123; System.out.println(&quot;未找到&quot;);&#125; 数组的常见异常 数组角标越界异常：ArrayIndexOutOfBoundsException 123456789 int[] arr = new int[]&#123;1,2,3,4,5&#125;; // for(int i = 0;i &lt;= arr.length;i++)&#123;// System.out.println(arr[i]);// &#125; // System.out.println(arr[-2]); // System.out.println(&quot;hello&quot;); 空指针异常：NullPointerException 12345678910111213 //情况一：// int[] arr1 = new int[]&#123;1,2,3&#125;;// arr1 = null;// System.out.println(arr1[0]); //情况二：// int[][] arr2 = new int[4][];// System.out.println(arr2[0][0]); //情况： String[] arr3 = new String[]&#123;&quot;AA&quot;,&quot;BB&quot;,&quot;CC&quot;&#125;; arr3[0] = null; System.out.println(arr3[0].toString()); 小知识：一旦程序出现异常，未处理时，就终止执行。 4.面向对象-上类与对象 面向对象学习的三条主线： Java类及类的成员：属性、方法、构造器；代码块、内部类 面向对象的大特征：封装性、继承性、多态性、(抽象性) 其它关键字：this、super、static、final、abstract、interface、package、import等 “大处着眼，小处着手” 面向对象与面向过程（理解） 面向过程：强调的是功能行为，以函数为最小单位，考虑怎么做。 面向对象：强调具备了功能的对象，以类/对象为最小单位，考虑谁来做。 举例对比：人把大象装进冰箱。 完成一个项目（或功能）的思路： 面向对象中两个重要的概念： 类：对一类事物的描述，是抽象的、概念上的定义 对象：是实际存在的该类事物的每个个体，因而也称为实例(instance) 面向对象程序设计的重点是类的设计 设计类，就是设计类的成员。 二者的关系：对象，是由类new出来的，派生出来的。 面向对象思想落地实现的规则 创建类，设计类的成员 创建类的对象 通过“对象.属性”或“对象.方法”调用对象的结构 补充：几个概念的使用说明 属性 = 成员变量 = field = 域、字段 方法 = 成员方法 = 函数 = method 创建类的对象 = 类的实例化 = 实例化类 对象的创建与对象的内存解析 典型代码： 123Person p1 = new Person();Person p2 = new Person();Person p3 = p1;//没有新创建一个对象，共用一个堆空间中的对象实体。 说明： 如果创建了一个类的多个对象，则每个对象都独立的拥有一套类的属性。（非static的） 意味着：如果我们修改一个对象的属性a，则不影响另外一个对象属性a的值。 内存解析： 匿名对象 我们创建的对象，没显式的赋给一个变量名。即为匿名对象 特点：匿名对象只能调用一次。 举例： 12345new Phone().sendEmail();new Phone().playGame();new Phone().price = 1999;new Phone().showPrice();//0.0 应用场景： 123456789101112PhoneMall mall = new PhoneMall();//匿名对象的使用mall.show(new Phone());其中，class PhoneMall&#123; public void show(Phone phone)&#123; phone.sendEmail(); phone.playGame(); &#125; &#125; 理解”万事万物皆对象” 在Java语言范畴中，我们都将功能、结构等封装到类中，通过类的实例化，来调用具体的功能结构 Scanner,String等 文件：File 网络资源：URL 涉及到Java语言与前端Html、后端的数据库交互时，前后端的结构在Java层面交互时，都体现为类、对象。 JVM内存结构 编译完源程序以后，生成一个或多个字节码文件。 我们使用JVM中的类的加载器和解释器对生成的字节码文件进行解释运行。意味着，需要将字节码文件对应的类加载到内存中，涉及到内存解析。 《JVM规范》 虚拟机栈，即为平时提到的栈结构。我们将局部变量存储在栈结构中 堆，我们将new出来的结构（比如：数组、对象）加载在对空间中。补充：对象的属性（非static的）加载在堆空间中。 方法区：类的加载信息、常量池、静态域 类的结构之一：属性属性（成员变量） vs 局部变量 相同点： 定义变量的格式：数据类型 变量名 = 变量值 先声明，后使用 变量都有其对应的作用域 不同点： 在类中声明的位置的不同 属性：直接定义在类的一对{}内 局部变量：声明在方法内、方法形参、代码块内、构造器形参、构造器内部的变量 关于权限修饰符的不同 属性：可以在声明属性时，指明其权限，使用权限修饰符。 常用的权限修饰符：private、public、缺省、protected ---&gt;封装性 目前，大家声明属性时，都使用缺省就可以了。 局部变量：不可以使用权限修饰符。 默认初始化值的情况： 属性：类的属性，根据其类型，都有默认初始化值。 整型（byte、short、int、long）：0 浮点型（float、double）：0.0 字符型（char）：0 （或’\\u0000’） 布尔型（boolean）：false 引用数据类型（类、数组、接口）：null 局部变量：没有默认初始化值。 意味着，我们在调用局部变量之前，一定要显式赋值。 特别地：形参在调用时，我们赋值即可。 在内存中加载的位置： 属性：加载到堆空间中 （非static） 局部变量：加载到栈空间 类的结构之二：方法方法：描述类应该具有的功能。 比如：Math类：sqrt()\\random() ... Scanner类：nextXxx() … Arrays类：sort() \\ binarySearch() \\ toString() \\ equals() \\ … 举例： public void eat(){} public void sleep(int hour){} public String getName(){} public String getNation(String nation){} 方法的声明： 123权限修饰符 返回值类型 方法名(形参列表)&#123; 方法体&#125; 注意：static、final、abstract 来修饰的方法，后面再讲。 说明： 关于权限修饰符：默认方法的权限修饰符先都使用public Java规定的4种权限修饰符：private、public、缺省、protected –&gt;封装性再细说 返回值类型： 有返回值 vs 没有返回值 如果方法有返回值，则必须在方法声明时，指定返回值的类型。同时，方法中，需要使用return关键字来返回指定类型的变量或常量：“return 数据”。 如果方法没有返回值，则方法声明时，使用void来表示。通常，没有返回值的方法中，就不需要使用return.但是，如果使用的话，只能“return;”表示结束此方法的意思。 我们定义方法该不该有返回值？ 题目要求 凭经验：具体问题具体分析 方法名：属于标识符，遵循标识符的规则和规范，“见名知意” 形参列表： 方法可以声明0个，1个，或多个形参。 格式：数据类型1 形参1,数据类型2 形参2,… 我们定义方法时，该不该定义形参？ 题目要求 凭经验：具体问题具体分析 方法体：方法功能的体现。 方法的使用中，可以调用当前类的属性或方法 特殊的：方法A中又调用了方法A:递归方法。 方法中，不可以定义方法。 关键字:return 使用范围：使用在方法体中 作用 结束方法 针对于有返回值类型的方法，使用”return 数据”方法返回所要的数据。 注意点：return关键字后面不可以声明执行语句。 方法的重载 方法的重载的概念 定义：在同一个类中，允许存在一个以上的同名方法，只要它们的参数个数或者参数类型不同即可。 “两同一不同”:同一个类、相同方法名；参数列表不同：参数个数不同，参数类型不同 构成重载的举例： 举例一：Arrays类中重载的sort() / binarySearch()；PrintStream中的println() 举例二： 123456789101112131415161718192021222324252627282930//如下的4个方法构成了重载 public void getSum(int i,int j)&#123; System.out.println(&quot;1&quot;); &#125; public void getSum(double d1,double d2)&#123; System.out.println(&quot;2&quot;); &#125; public void getSum(String s ,int i)&#123; System.out.println(&quot;3&quot;); &#125; public void getSum(int i,String s)&#123; System.out.println(&quot;4&quot;); &#125; //不构成重载的举例： //如下的3个方法不能与上述4个方法构成重载// public int getSum(int i,int j)&#123;// return 0;// &#125; // public void getSum(int m,int n)&#123;// // &#125; // private void getSum(int i,int j)&#123;// // &#125; 如何判断是否构成方法的重载？ 严格按照定义判断：两同一不同。 跟方法的权限修饰符、返回值类型、形参变量名、方法体都没有关系！ 如何确定类中某一个方法的调用：方法名 —&gt; 参数列表 面试题：方法的重载与重写的区别？ throws\\throw String\\StringBuffer\\StringBuilder Collection\\Collections final\\finally\\finalize …. 抽象类、接口 sleep() / wait() 可变个数形参的方法 使用说明： jdk 5.0新增的内容 具体使用： 可变个数形参的格式：数据类型 … 变量名 当调用可变个数形参的方法时，传入的参数个数可以是：0个，1个,2个，。。。 可变个数形参的方法与本类中方法名相同，形参类型不同的方法之间构成重载 可变个数形参的方法与本类中方法名相同，形参类型也相同的数组之间不构成重载。换句话说，二者不能共存。 可变个数形参在方法的形参中，必须声明在末尾 可变个数形参在方法的形参中,最多只能声明一个可变形参。 举例说明： 12345678910111213141516171819202122232425 public void show(int i)&#123; &#125; public void show(String s)&#123; System.out.println(&quot;show(String)&quot;); &#125; public void show(String ... strs)&#123; System.out.println(&quot;show(String ... strs)&quot;); for(int i = 0;i &lt; strs.length;i++)&#123; System.out.println(strs[i]); &#125; &#125; //不能与上一个方法同时存在// public void show(String[] strs)&#123;// // &#125; //调用时： test.show(&quot;hello&quot;); test.show(&quot;hello&quot;,&quot;world&quot;); test.show(); test.show(new String[]&#123;&quot;AA&quot;,&quot;BB&quot;,&quot;CC&quot;&#125;); java的值传递机制 针对于方法内变量的赋值举例： 1234567891011121314151617181920212223System.out.println(&quot;***********基本数据类型：****************&quot;);int m = 10;int n = m;System.out.println(&quot;m = &quot; + m + &quot;, n = &quot; + n);n = 20;System.out.println(&quot;m = &quot; + m + &quot;, n = &quot; + n);System.out.println(&quot;***********引用数据类型：****************&quot;);Order o1 = new Order();o1.orderId = 1001;Order o2 = o1;//赋值以后，o1和o2的地址值相同，都指向了堆空间中同一个对象实体。System.out.println(&quot;o1.orderId = &quot; + o1.orderId + &quot;,o2.orderId = &quot; +o2.orderId);o2.orderId = 1002;System.out.println(&quot;o1.orderId = &quot; + o1.orderId + &quot;,o2.orderId = &quot; +o2.orderId); 规则： 如果变量是基本数据类型，此时赋值的是变量所保存的数据值。 如果变量是引用数据类型，此时赋值的是变量所保存的数据的地址值。 针对于方法的参数概念 形参：方法定义时，声明的小括号内的参数 实参：方法调用时，实际传递给形参的数据 值传递机制： 规则： 如果参数是基本数据类型，此时实参赋给形参的是实参真实存储的数据值。 如果参数是引用数据类型，此时实参赋给形参的是实参存储数据的地址值。 推广： 如果变量是基本数据类型，此时赋值的是变量所保存的数据值。 如果变量是引用数据类型，此时赋值的是变量所保存的数据的地址值。 典型例题与内存解析： 【例题1】 【例题2】 递归方法 定义：递归方法：一个方法体内调用它自身。 如何理解递归方法？ 方法递归包含了一种隐式的循环，它会重复执行某段代码，但这种重复执行无须循环控制。 递归一定要向已知方向递归，否则这种递归就变成了无穷递归，类似于死循环。 举例： 12345678910111213141516171819202122232425262728293031323334353637383940 // 例1：计算1-n之间所自然数的和 public int getSum(int n) &#123;// 3 if (n == 1) &#123; return 1; &#125; else &#123; return n + getSum(n - 1); &#125; &#125; // 例2：计算1-n之间所自然数的乘积:n! public int getSum1(int n) &#123; if (n == 1) &#123; return 1; &#125; else &#123; return n * getSum1(n - 1); &#125; &#125; //例3：已知一个数列：f(0) = 1,f(1) = 4,f(n+2)=2*f(n+1) + f(n), //其中n是大于0的整数，求f(10)的值。 public int f(int n)&#123; if(n == 0)&#123; return 1; &#125;else if(n == 1)&#123; return 4; &#125;else&#123;// return f(n + 2) - 2 * f(n + 1); return 2*f(n - 1) + f(n - 2); &#125; &#125; //例4：斐波那契数列 //例5：汉诺塔问题 //例6：快排 面向对象的特征一：封装性 为什么要引入封装性？ 我们程序设计追求“高内聚，低耦合”。 高内聚 ：类的内部数据操作细节自己完成，不允许外部干涉； 低耦合 ：仅对外暴露少量的方法用于使用。 隐藏对象内部的复杂性，只对外公开简单的接口。便于外界调用，从而提高系统的可扩展性、可维护性。通俗的说，把该隐藏的隐藏起来，该暴露的暴露出来。这就是封装性的设计思想。 问题引入： 当我们创建一个类的对象以后，我们可以通过”对象.属性”的方式，对对象的属性进行赋值。这里，赋值操作要受到属性的数据类型和存储范围的制约。除此之外，没有其他制约条件。但是，在实际问题中，我们往往需要给属性赋值加入额外的限制条件。这个条件就不能在属性声明时体现，我们只能通过方法进行限制条件的添加。（比如：setLegs()）同时，我们需要避免用户再使用”对象.属性”的方式对属性进行赋值。则需要将属性声明为私有的(private)。–&gt;此时，针对于属性就体现了封装性。 封装性思想具体的代码体现： 体现一：将类的属性xxx私化(private),同时，提供公共的(public)方法来获取(getXxx)和设置(setXxx)此属性的值 1234567private double radius;public void setRadius(double radius)&#123; this.radius = radius;&#125;public double getRadius()&#123; return radius;&#125; 体现二：不对外暴露的私有的方法 体现三：单例模式（将构造器私有化） 体现四：如果不希望类在包外被调用，可以将类设置为缺省的。 Java规定的四种权限修饰符 权限从小到大顺序为：private &lt; 缺省 &lt; protected &lt; public 具体的修饰范围： 权限修饰符可用来修饰的结构说明： 4种权限都可以用来修饰类的内部结构：属性、方法、构造器、内部类 修饰类的话，只能使用：缺省、public 类的结构之三：构造器 构造器（或构造方法）：Constructor作用 创建对象 初始化对象的信息 使用说明： 如果没显式的定义类的构造器的话，则系统默认提供一个空参的构造器 定义构造器的格式：权限修饰符 类名(形参列表){} 一个类中定义的多个构造器，彼此构成重载 一旦我们显式的定义了类的构造器之后，系统就不再提供默认的空参构造器 一个类中，至少会有一个构造器。 举例： 123456789101112131415//构造器public Person()&#123; System.out.println(&quot;Person().....&quot;);&#125;public Person(String n)&#123; name = n; &#125;public Person(String n,int a)&#123; name = n; age = a;&#125; 属性赋值顺序① 默认初始化 ② 显式初始化 ③ 构造器中初始化 ④ 通过”对象.方法” 或 “对象.属性”的方式，赋值 以上操作的先后顺序：① - ② - ③ - ④ JavaBean的概念所谓JavaBean，是指符合如下标准的Java类： 类是公共的 一个无参的公共的构造器 属性，且对应的get、set方法 关键字：this 可以调用的结构：属性、方法；构造器 this调用属性、方法：this理解为：当前对象 或 当前正在创建的对象 在类的方法中，我们可以使用”this.属性”或”this.方法”的方式，调用当前对象属性或方法。但是，通常情况下，我们都选择省略”this.”。特殊情况下，如果方法的形参和类的属性同名时，我们必须显式的使用”this.变量”的方式，表明此变量是属性，而非形参。 在类的构造器中，我们可以使用”this.属性”或”this.方法”的方式，调用当前正在创建的对象属性或方法。但是，通常情况下，我们都选择省略”this.”。特殊情况下，如果构造器的形参和类的属性同名时，我们必须显式的使用”this.变量”的方式，表明此变量是属性，而非形参。 this调用构造器 我们在类的构造器中，可以显式的使用”this(形参列表)”方式，调用本类中指定的其他构造器 构造器中不能通过”this(形参列表)”方式调用自己 如果一个类中有n个构造器，则最多有 n - 1构造器中使用了”this(形参列表)” 规定：”this(形参列表)”必须声明在当前构造器的首行 构造器内部，最多只能声明一个”this(形参列表)”，用来调用其他的构造器 关键字：package/import package的使用 使用说明： 为了更好的实现项目中类的管理，提供包的概念 使用package声明类或接口所属的包，声明在源文件的首行 包，属于标识符，遵循标识符的命名规则、规范(xxxyyyzzz)、“见名知意” 每”.”一次，就代表一层文件目录。 补充：同一个包下，不能命名同名的接口、类。不同的包下，可以命名同名的接口、类。 举例： 举例一：某航运软件系统包括：一组域对象、GUI和reports子系统 举例二：MVC设计模式 JDK中的主要包介绍： import的使用：import:导入 在源文件中显式的使用import结构导入指定包下的类、接口 声明在包的声明和类的声明之间 如果需要导入多个结构，则并列写出即可 可以使用”xxx.*”的方式，表示可以导入xxx包下的所有结构 如果使用的类或接口是java.lang包下定义的，则可以省略import结构 如果使用的类或接口是本包下定义的，则可以省略import结构 如果在源文件中，使用了不同包下的同名的类，则必须至少有一个类需要以全类名的方式显示。 使用”xxx.*”方式表明可以调用xxx包下的所有结构。但是如果使用的是xxx子包下的结构，则仍需要显式导入 import static:导入指定类或接口中的静态结构:属性或方法。 5.面向对象-中面向对象的特征二：继承性 为什么要有类的继承性？(继承性的好处） 减少了代码的冗余，提高了代码的复用性 便于功能的扩展 为之后多态性的使用，提供了前提 图示： 继承性的格式：class A extends B{} A:子类、派生类、subclass B:父类、超类、基类、superclass 子类继承父类以后有哪些不同？ 体现：一旦子类A继承父类B以后，子类A中就获取了父类B中声明的所有的属性和方法。 特别的，父类中声明为private的属性或方法，子类继承父类以后，仍然认为获取了父类中私有的结构。 只有因为封装性的影响，使得子类不能直接调用父类的结构而已。 子类继承父类以后，还可以声明自己特有的属性或方法：实现功能的拓展。 子类和父类的关系，不同于子集和集合的关系。 extends：延展、扩展 Java中关于继承性的规定 一个类可以被多个子类继承。 Java中类的单继承性：一个类只能有一个父类 子父类是相对的概念。 子类直接继承的父类，称为：直接父类。间接继承的父类称为：间接父类 子类继承父类以后，就获取了直接父类以及所有间接父类中声明的属性和方法 图示： java.lang.Object类的理解 如果我们没有显式的声明一个类的父类的话，则此类继承于java.lang.Object类 所有的java类（除java.lang.Object类之外）都直接或间接的继承于java.lang.Object类 意味着，所有的java类具有java.lang.Object类声明的功能。 方法的重写 什么是方法的重写(override 或 overwrite)？子类继承父类以后，可以对父类中同名同参数的方法，进行覆盖操作 应用：重写以后，当创建子类对象以后，通过子类对象调用子父类中的同名同参数的方法时，实际执行的是子类重写父类的方法。 举例： 12345678910111213class Circle&#123;public double findArea()&#123;&#125;//求面积&#125;class Cylinder extends Circle&#123;public double findArea()&#123;&#125;//求表面积&#125;***************class Account&#123;public boolean withdraw(double amt)&#123;&#125;&#125;class CheckAccount extends Account&#123;public boolean withdraw(double amt)&#123;&#125;&#125; 重写的规则： 方法的声明： 123权限修饰符 返回值类型 方法名(形参列表) throws 异常的类型&#123; //方法体&#125; 约定俗称：子类中的叫重写的方法，父类中的叫被重写的方法 子类重写的方法的方法名和形参列表与父类被重写的方法的方法名和形参列表相同 子类重写的方法的权限修饰符不小于父类被重写的方法的权限修饰符 特殊情况：子类不能重写父类中声明为private权限的方法 返回值类型： 父类被重写的方法的返回值类型是void，则子类重写的方法的返回值类型只能是void 父类被重写的方法的返回值类型是A类型，则子类重写的方法的返回值类型可以是A类或A类的子类 父类被重写的方法的返回值类型是基本数据类型(比如：double)，则子类重写的方法的返回值类型必须是相同的基本数据类型(必须也是double) 子类重写的方法抛出的异常类型不大于父类被重写的方法抛出的异常类型（具体放到异常处理时候讲） 补充：子类和父类中的同名同参数的方法要么都声明为非static的（考虑重写），要么都声明为static的（不是重写）。 面试题：区分方法的重写和重载？ ① 二者的概念： ② 重载和重写的具体规则 ③ 重载：不表现为多态性。 ​ 重写：表现为多态性。 重载，是指允许存在多个同名方法，而这些方法的参数不同。编译器根据方法不同的参数表，对同名方法的名称做修饰。对于编译器而言，这些同名方法就成了不同的方法。它们的调用地址在编译期就绑定了。Java的重载是可以包括父类和子类的，即子类可以重载父类的同名不同参数的方法。所以：对于重载而言，在方法调用之前，编译器就已经确定了所要调用的方法，这称为“早绑定”或“静态绑定”； 而对于多态，只等到方法调用的那一刻，解释运行器才会确定所要调用的具体方法，这称为“晚绑定”或“动态绑定”。 引用一句Bruce Eckel的话：“不要犯傻，如果它不是晚绑定，它就不是多态。” 关键字：super super理解为：父类的 可以用来调用的结构：属性、方法、构造器 super的使用：调用属性和方法 我们可以在子类的方法或构造器中。通过使用”super.属性”或”super.方法”的方式，显式的调用父类中声明的属性或方法。但是，通常情况下，我们习惯省略”super.” 特殊情况：当子类和父类中定义了同名的属性时，我们要想在子类中调用父类中声明的属性，则必须显式的使用”super.属性”的方式，表明调用的是父类中声明的属性。 特殊情况：当子类重写了父类中的方法以后，我们想在子类的方法中调用父类中被重写的方法时，则必须显式的使用”super.方法”的方式，表明调用的是父类中被重写的方法。 super调用构造器 我们可以在子类的构造器中显式的使用”super(形参列表)”的方式，调用父类中声明的指定的构造器 “super(形参列表)”的使用，必须声明在子类构造器的首行！ 我们在类的构造器中，针对于”this(形参列表)”或”super(形参列表)”只能二选一，不能同时出现 在构造器的首行，没有显式的声明”this(形参列表)”或”super(形参列表)”，则默认调用的是父类中空参的构造器：super() 在类的多个构造器中，至少有一个类的构造器中使用了”super(形参列表)”，调用父类中的构造器 子类对象实例化全过程 从结果上来看：（继承性） 子类继承父类以后，就获取了父类中声明的属性或方法。 创建子类的对象，在堆空间中，就会加载所有父类中声明的属性。 从过程上来看： 当我们通过子类的构造器创建子类对象时，我们一定会直接或间接的调用其父类的构造器，进而调用父类的父类的构造器，…直到调用了java.lang.Object类中空参的构造器为止。 正因为加载过所有的父类的结构，所以才可以看到内存中有父类中的结构，子类对象才可以考虑进行调用。 图示： 强调说明：虽然创建子类对象时，调用了父类的构造器，但是自始至终就创建过一个对象，即为new的子类对象。 面向对象的特征三：多态性 多态性的理解：可以理解为一个事物的多种形态。 何为多态性：对象的多态性：父类的引用指向子类的对象（或子类的对象赋给父类的引用） 举例： 12Person p = new Man();Object obj = new Date(); 多态性的使用：虚拟方法调用 有了对象的多态性以后，我们在编译期，只能调用父类中声明的方法，但在运行期，我们实际执行的是子类重写父类的方法。 总结：编译，看左边；运行，看右边。 多态性的使用前提： ① 类的继承关系 ② 方法的重写 多态性的应用举例： 举例一： 1234public void func(Animal animal)&#123;//Animal animal = new Dog(); animal.eat(); animal.shout(); &#125; 举例二： 123public void method(Object obj)&#123; &#125; 举例三： 1234567891011class Driver&#123; public void doData(Connection conn)&#123;//conn = new MySQlConnection(); / conn = new OracleConnection(); //规范的步骤去操作数据// conn.method1();// conn.method2();// conn.method3(); &#125; &#125; 多态性使用的注意点：对象的多态性，只适用于方法，不适用于属性（编译和运行都看左边） 关于向上转型与向下转型： 向上转型：多态 向下转型： 为什么使用向下转型：有了对象的多态性以后，内存中实际上是加载了子类特有的属性和方法的，但是由于变量声明为父类类型，导致编译时，只能调用父类中声明的属性和方法。子类特有的属性和方法不能调用。如何才能调用子类特的属性和方法？使用向下转型。 如何实现向下转型：使用强制类型转换符：() 使用时的注意点： 使用强转时，可能出现ClassCastException的异常。 使用强转时，可能出现ClassCastException的异常。② 为了避免在向下转型时出现ClassCastException的异常，我们在向下转型之前，先进行instanceof的判断，一旦返回true，就进行向下转型。如果返回false，不进行向下转型。 instanceof的使用： a instanceof A:判断对象a是否是类A的实例。如果是，返回true；如果不是，返回false。 如果 a instanceof A返回true,则 a instanceof B也返回true.其中，类B是类A的父类。 要求a所属的类与类A必须是子类和父类的关系，否则编译错误。 图示： 面试题： 谈谈你对多态性的理解？ 实现代码的通用性。 Object类中定义的public boolean equals(Object obj){ } JDBC:使用java程序操作(获取数据库连接、CRUD)数据库(MySQL、Oracle、DB2、SQL Server) 抽象类、接口的使用肯定体现了多态性。（抽象类、接口不能实例化） 多态是编译时行为还是运行时行为？运行时行为 Object类的使用 java.lang.Object类的说明： Object类是所有Java类的根父类 如果在类的声明中未使用extends关键字指明其父类，则默认父类为java.lang.Object类 Object类中的功能(属性、方法)就具有通用性。 属性：无 方法：equals() / toString() / getClass() /hashCode() / clone() / finalize()/wait() /notify()/notifyAll() Object类只声明了一个空参的构造器 equals()方法 equals()的使用： 是一个方法，而非运算符 只能适用于引用数据类型 Object类中equals()的定义： 123public boolean equals(Object obj) &#123; return (this == obj); &#125; 说明：Object类中定义的equals()和==的作用是相同的：比较两个对象的地址值是否相同.即两个引用是否指向同一个对象实体 像String、Date、File、包装类等都重写了Object类中的equals()方法。重写以后，比较的不是两个引用的地址是否相同，而是比较两个对象的”实体内容”是否相同。 通常情况下，我们自定义的类如果使用equals()的话，也通常是比较两个对象的”实体内容”是否相同。那么，我们就需要对Object类中的equals()进行重写. 重写的原则：比较两个对象的实体内容是否相同. 如何重写equals() 手动重写举例： 123456789101112131415class User&#123;String name;int age; //重写其equals()方法 public boolean equals(Object obj)&#123; if(obj == this)&#123; return true; &#125; if(obj instanceof User)&#123; User u = (User)obj; return this.age == u.age &amp;&amp; this.name.equals(u.name); &#125; return false; &#125;&#125; 开发中如何实现：自动生成的 回顾 == 运算符的使用： 可以使用在基本数据类型变量和引用数据类型变量中 如果比较的是基本数据类型变量：比较两个变量保存的数据是否相等。（不一定类型要相同） 如果比较的是引用数据类型变量：比较两个对象的地址值是否相同.即两个引用是否指向同一个对象实体 补充： == 符号使用时，必须保证符号左右两边的变量类型一致。 toString()方法 toString()的使用： 当我们输出一个对象的引用时，实际上就是调用当前对象的toString() Object类中toString()的定义： 123public String toString() &#123; return getClass().getName() + &quot;@&quot; + Integer.toHexString(hashCode()); &#125; 像String、Date、File、包装类等都重写了Object类中的toString()方法。使得在调用对象的toString()时，返回”实体内容”信息 自定义类也可以重写toString()方法，当调用此方法时，返回对象的”实体内容” 如何重写toString() 举例： 12345//自动实现 @Override public String toString() &#123; return &quot;Customer [name=&quot; + name + &quot;, age=&quot; + age + &quot;]&quot;; &#125; 面试题： final、finally、finalize的区别？ == 和 equals() 区别 单元测试方法Java中的JUnit单元测试 步骤： 选中当前工程 - 右键选择：build path - add libraries - JUnit 4 - 下一步 创建Java类，进行单元测试。此时的Java类要求：① 此类是public的 ②此类提供公共的无参的构造器 此类中声明单元测试方法。 此时的单元测试方法：方法的权限是public,没有返回值，没有形参 此单元测试方法上需要声明注解：@Test,并在单元测试类中导入：import org.junit.Test; 声明好单元测试方法以后，就可以在方法体内测试相关的代码。 写完代码以后，左键双击单元测试方法名，右键：run as - JUnit Test 说明： 如果执行结果没有任何异常：绿条 如果执行结果出现异常：红条 包装类的使用 为什么要有包装类(或封装类）？ java提供了8种基本数据类型对应的包装类，使得基本数据类型的变量具有类的特征 基本数据类型与对应的包装类： 需要掌握的类型间的转换：（基本数据类型、包装类、String） 简易版： 基本数据类型&lt;—&gt;包装类：JDK 5.0 新特性：自动装箱 与自动拆箱 基本数据类型、包装类—&gt;String:调用String重载的valueOf(Xxx xxx) String—&gt;基本数据类型、包装类:调用包装类的parseXxx(String s) 注意：转换时，可能会报NumberFormatException 应用场景举例： Vector类中关于添加元素，只定义了形参为Object类型的方法：v.addElement(Object obj); //基本数据类型 —&gt;包装类 —&gt;使用多态 6.面向对象-下关键字：staticstatic:静态的 可以用来修饰的结构：主要用来修饰类的内部结构——–&gt;属性、方法、代码块、内部类 static修饰属性：静态变量（或类变量） 属性，按是否使用static修饰，又分为：静态属性 vs 非静态属性(实例变量) 实例变量：我们创建了类的多个对象，每个对象都独立的拥有一套类中的非静态属性。当修改其中一个对象中的非静态属性时，不会导致其他对象中同样的属性值的修改。 静态变量：我们创建了类的多个对象，多个对象共享同一个静态变量。当通过某一个对象修改静态变量时，会导致其他对象调用此静态变量时，是修改过了的。 static修饰属性的其他说明： 静态变量随着类的加载而加载。可以通过”类.静态变量”的方式进行调用 静态变量的加载要早于对象的创建。 由于类只会加载一次，则静态变量在内存中也只会存在一份：存在方法区的静态域中。 类变量 类变量 类 yes no 对象 yes yes 静态属性举例：System.out; Math.PI; 静态变量内存解析： static修饰方法：静态方法、类方法 随着类的加载而加载，可以通过”类.静态方法”的方式进行调用 静态方法 非静态方法 类 yes no 对象 yes yes 静态方法中，只能调用静态的方法或属性; 非静态方法中，既可以调用非静态的方法或属性，也可以调用静态的方法或属性 static注意点： 在静态的方法内，不能使用this关键字、super关键字 关于静态属性和静态方法的使用，大家都从生命周期的角度去理解。 开发中，如何确定一个属性是否要声明为static的？ 属性是可以被多个对象所共享的，不会随着对象的不同而不同的。 类中的常量也常常声明为static 开发中，如何确定一个方法是否要声明为static的？ 操作静态属性的方法，通常设置为static的 工具类中的方法，习惯上声明为static的。 比如：Math、Arrays、Collections 使用举例： 举例一：Arrays、Math、Collections等工具类 举例二：单例模式 举例三： 12345678910111213141516171819202122232425262728293031323334353637383940414243class Circle&#123; private double radius; private int id;//自动赋值 public Circle()&#123; id = init++; total++; &#125; public Circle(double radius)&#123; this();// id = init++;// total++; this.radius = radius; &#125; private static int total;//记录创建的圆的个数 private static int init = 1001;//static声明的属性被所对象所共享 public double findArea()&#123; return 3.14 * radius * radius; &#125; public double getRadius() &#123; return radius; &#125; public void setRadius(double radius) &#123; this.radius = radius; &#125; public int getId() &#123; return id; &#125; public static int getTotal() &#123; return total; &#125;&#125; 单例模式 设计模式的说明 理解：设计模式是在大量的实践中总结和理论化之后优的代码结构、编程风格、以及解决问题的思考方式。 常用设计模式 — 23种经典的设计模式 GOF 创建型模式，共5种：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。 结构型模式，共7种：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。 行为型模式，共11种：策略模式、模板方法模式、观察者模式、迭代器模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。 单例模式 要解决的问题：所谓类的单例设计模式，就是采取一定的方法保证在整个的软件系统中，对某个类只能存在一个对象实例。 具体代码的实现： 饿汉式1： 12345678910111213141516class Bank&#123; //1.私化类的构造器 private Bank()&#123; &#125; //2.内部创建类的对象 //4.要求此对象也必须声明为静态的 private static Bank instance = new Bank(); //3.提供公共的静态的方法，返回类的对象 public static Bank getInstance()&#123; return instance; &#125;&#125; 饿汉式2：使用了静态代码块 123456789101112131415161718192021class Order&#123; //1.私化类的构造器 private Order()&#123; &#125; //2.声明当前类对象，没初始化 //4.此对象也必须声明为static的 private static Order instance = null; static&#123; instance = new Order(); &#125; //3.声明public、static的返回当前类对象的方法 public static Order getInstance()&#123; return instance; &#125; &#125; 懒汉式： 1234567891011121314151617181920212223class Order&#123; //1.私化类的构造器 private Order()&#123; &#125; //2.声明当前类对象，没初始化 //4.此对象也必须声明为static的 private static Order instance = null; //3.声明public、static的返回当前类对象的方法 public static Order getInstance()&#123; if(instance == null)&#123; instance = new Order(); &#125; return instance; &#125; &#125; 两种方式的对比： 饿汉式： 坏处：对象加载时间过长。 好处：饿汉式是线程安全的 懒汉式： 好处：延迟对象的创建。 目前的写法坏处：线程不安全。—&gt;到多线程内容时，再修改 main()的使用说明 main()方法作为程序的入口 main()方法也是一个普通的静态方法 main()方法可以作为我们与控制台交互的方式。（之前：使用Scanner） 如何将控制台获取的数据传给形参： 123456String[] args? 运行时：java 类名 &quot;Tom&quot; &quot;Jerry&quot; &quot;123&quot; &quot;true&quot;sysout(args[0]);//&quot;Tom&quot;sysout(args[3]);//&quot;true&quot; --&gt;Boolean.parseBoolean(args[3]);sysout(args[4]);//报异常 小结：一叶知秋 public static void main(String[] args)&#123;//方法体&#125; 权限修饰符：private 缺省 protected pubilc —-&gt;封装性 修饰符：static \\ final \\ abstract \\native 可以用来修饰方法 返回值类型： 无返回值 / 有返回值 –&gt;return方法名：需要满足标识符命名的规则、规范；”见名知意” 形参列表：重载 vs 重写；参数的值传递机制；体现对象的多态性 方法体：来体现方法的功能 类的结构：代码块类的成员之四：代码块(初始化块)（重要性较属性、方法、构造器差一些） 代码块的作用：用来初始化类、对象的信息 分类：代码块要是使用修饰符，只能使用static 分类：静态代码块 vs 非静态代码块 静态代码块 内部可以有输出语句 随着类的加载而执行,而且只执行一次 作用：初始化类的信息 如果一个类中定义了多个静态代码块，则按照声明的先后顺序执行 静态代码块的执行要优先于非静态代码块的执行 静态代码块内只能调用静态的属性、静态的方法，不能调用非静态的结构 非静态代码块 内部可以有输出语句 随着对象的创建而执行 每创建一个对象，就执行一次非静态代码块 作用：可以在创建对象时，对对象的属性等进行初始化 如果一个类中定义了多个非静态代码块，则按照声明的先后顺序执行 非静态代码块内可以调用静态的属性、静态的方法，或非静态的属性、非静态的方法 实例化子类对象时，涉及到父类、子类中静态代码块、非静态代码块、构造器的加载顺序：由父及子，静态先行。 属性的赋值顺序①默认初始化 ②显式初始化/⑤在代码块中赋值 ③构造器中初始化 ④有了对象以后，可以通过”对象.属性”或”对象.方法”的方式，进行赋值 执行的先后顺序：① - ② / ⑤ - ③ - ④ 关键字：finalfinal：最终的 final可以用来修饰的结构：类、方法、变量 具体的： final 用来修饰一个类:此类不能被其他类所继承。比如：String类、System类、StringBuffer类 final 用来修饰方法：表明此方法不可以被重写，比如：Object类中getClass(); final 用来修饰变量：此时的”变量”就称为是一个常量 final修饰属性：可以考虑赋值的位置有：显式初始化、代码块中初始化、构造器中初始化 final修饰局部变量：尤其是使用final修饰形参时，表明此形参是一个常量。当我们调用此方法时，给常量形参赋一个实参。一旦赋值以后，就只能在方法体内使用此形参，但不能进行重新赋值。 static final 用来修饰属性：全局常量 关键字：abstractabstract: 抽象的 可以用来修饰：类、方法 具体的： abstract修饰类：抽象类 此类不能实例化 抽象类中一定有构造器，便于子类实例化时调用（涉及：子类对象实例化的全过程） 开发中，都会提供抽象类的子类，让子类对象实例化，完成相关的操作 abstract修饰方法：抽象方法 抽象方法只有方法的声明，没有方法体 包含抽象方法的类，一定是一个抽象类。反之，抽象类中可以没有抽象方法的。 若子类重写了父类中的所有的抽象方法后，此子类方可实例化 若子类没有重写父类中的所有的抽象方法，则此子类也是一个抽象类，需要使用abstract修饰 注意点： abstract不能用来修饰：属性、构造器等结构 abstract不能用来修饰私方法、静态方法、final的方法、final的类 abstract的应用举例： 举例一： 举例二： 123456789abstract class GeometricObject&#123;public abstract double findArea();&#125;class Circle extends GeometricObject&#123;private double radius;public double findArea()&#123; return 3.14 * radius * radius;&#125;;&#125; 举例三：IO流中设计到的抽象类：InputStream/OutputStream / Reader /Writer。在其内部定义了抽象的read()、write()方法。 模板方法的设计模式 解决的问题：在软件开发中实现一个算法时，整体步骤很固定、通用，这些步骤已经在父类中写好了。但是某些部分易变，易变部分可以抽象出来，供不同子类实现。这就是一种模板模式。 举例 1234567891011121314151617181920212223242526272829303132333435363738394041abstract class Template&#123; //计算某段代码执行所需要花费的时间 public void spendTime()&#123; long start = System.currentTimeMillis(); this.code();//不确定的部分、易变的部分 long end = System.currentTimeMillis(); System.out.println(&quot;花费的时间为：&quot; + (end - start)); &#125; public abstract void code(); &#125;class SubTemplate extends Template&#123; @Override public void code() &#123; for(int i = 2;i &lt;= 1000;i++)&#123; boolean isFlag = true; for(int j = 2;j &lt;= Math.sqrt(i);j++)&#123; if(i % j == 0)&#123; isFlag = false; break; &#125; &#125; if(isFlag)&#123; System.out.println(i); &#125; &#125; &#125; &#125; 应用场景 关键字：interfaceinterface:接口 使用说明： 接口使用interface来定义 Java中，接口和类是并列的两个结构 如何定义接口：定义接口中的成员 JDK7及以前：只能定义全局常量和抽象方法 全局常量：public static final的.但是书写时，可以省略不写 抽象方法：public abstract的 JDK8：除了定义全局常量和抽象方法之外，还可以定义静态方法、默认方法（略） 接口中不能定义构造器的！意味着接口不可以实例化 Java开发中，接口通过让类去实现(implements)的方式来使用. 如果实现类覆盖了接口中的所有抽象方法，则此实现类就可以实例化 如果实现类没有覆盖接口中所有的抽象方法，则此实现类仍为一个抽象类 Java类可以实现多个接口 —&gt;弥补了Java单继承性的局限性 格式：class AA extends BB implements CC,DD,EE 接口与接口之间可以继承，而且可以多继承 接口的具体使用，体现多态性 接口，实际上可以看做是一种规范 举例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748class Computer&#123; public void transferData(USB usb)&#123;//USB usb = new Flash(); usb.start(); System.out.println(&quot;具体传输数据的细节&quot;); usb.stop(); &#125; &#125;interface USB&#123; //常量：定义了长、宽、最大最小的传输速度等 void start(); void stop(); &#125;class Flash implements USB&#123; @Override public void start() &#123; System.out.println(&quot;U盘开启工作&quot;); &#125; @Override public void stop() &#123; System.out.println(&quot;U盘结束工作&quot;); &#125; &#125;class Printer implements USB&#123; @Override public void start() &#123; System.out.println(&quot;打印机开启工作&quot;); &#125; @Override public void stop() &#123; System.out.println(&quot;打印机结束工作&quot;); &#125; &#125; 体会： 1.接口使用上也满足多态性 2.接口，实际上就是定义了一种规范 3.开发中，体会面向接口编程！ 体会面向接口编程的思想 面向接口编程：我们在应用程序中，调用的结构都是JDBC中定义的接口，不会出现具体某一个数据库厂商的API。 Java8中关于接口的新规范 知识点1：接口中定义的静态方法，只能通过接口来调用。 知识点2：通过实现类的对象，可以调用接口中的默认方法。 如果实现类重写了接口中的默认方法，调用时，仍然调用的是重写以后的方法 知识点3：如果子类(或实现类)继承的父类和实现的接口中声明了同名同参数的默认方法，那么子类在没重写此方法的情况下，默认调用的是父类中的同名同参数的方法。–&gt;类优先原则 知识点4：如果实现类实现了多个接口，而这多个接口中定义了同名同参数的默认方法，那么在实现类没重写此方法的情况下，报错。–&gt;接口冲突。 这就需要我们必须在实现类中重写此方法 知识点5：如何在子类(或实现类)的方法中调用父类、接口中被重写的方法 1234567public void myMethod()&#123; method3();//调用自己定义的重写的方法 super.method3();//调用的是父类中声明的 //调用接口中的默认方法 CompareA.super.method3(); CompareB.super.method3();&#125; 面试题：抽象类和接口的异同？ 相同点：不能实例化；都可以包含抽象方法的。 不同点： 把抽象类和接口(java7,java8,java9)的定义、内部结构解释说明 类：单继承性 接口：多继承 类与接口：多实现 代理模式 解决的问题：代理模式是Java开发中使用较多的一种设计模式。代理设计就是为其他对象提供一种代理以控制对这个对象的访问。 举例 123456789101112131415161718192021222324252627282930313233343536373839interface NetWork&#123; public void browse(); &#125;//被代理类class Server implements NetWork&#123; @Override public void browse() &#123; System.out.println(&quot;真实的服务器访问网络&quot;); &#125;&#125;//代理类class ProxyServer implements NetWork&#123; private NetWork work; public ProxyServer(NetWork work)&#123; this.work = work; &#125; public void check()&#123; System.out.println(&quot;联网之前的检查工作&quot;); &#125; @Override public void browse() &#123; check(); work.browse(); &#125; &#125; 应用场景 工厂的设计模式 解决的问题：实现了创建者与调用者的分离，即将创建对象的具体过程屏蔽隔离起来，达到提高灵活性的目的。 具体模式 简单工厂模式：用来生产同一等级结构中的任意产品。（对于增加新的产品，需要修改已有代码） 工厂方法模式：用来生产同一等级结构中的固定产品。（支持增加任意产品) 抽象工厂模式：用来生产不同产品族的全部产品。（对于增加新的产品，无能为力；支持增加产品族) 类的结构：内部类内部类：类的第五个成员 定义：Java中允许将一个类A声明在另一个类B中，则类A就是内部类，类B称为外部类 内部类的分类：成员内部类（静态、非静态） vs 局部内部类(方法内、代码块内、构造器内) 成员内部类的理解： 一方面，作为外部类的成员： 调用外部类的结构 可以被static修饰 可以被4种不同的权限修饰 另一方面，作为一个类： 类内可以定义属性、方法、构造器等 可以被final修饰，表示此类不能被继承。言外之意，不使用final，就可以被继承 可以被abstract修饰 成员内部类： 如何创建成员内部类的对象？(静态的，非静态的) 1234567//创建静态的Dog内部类的实例(静态的成员内部类):Person.Dog dog = new Person.Dog();//创建非静态的Bird内部类的实例(非静态的成员内部类)://Person.Bird bird = new Person.Bird();//错误的Person p = new Person();Person.Bird bird = p.new Bird(); 如何在成员内部类中调用外部类的结构？ 123456789101112131415class Person&#123; String name = &quot;小明&quot;;public void eat()&#123;&#125;//非静态成员内部类 class Bird&#123; String name = &quot;杜鹃&quot;; public void display(String name)&#123; System.out.println(name);//方法的形参 System.out.println(this.name);//内部类的属性 System.out.println(Person.this.name);//外部类的属性 //Person.this.eat(); &#125; &#125;&#125; 局部内部类的使用： 123456789101112131415161718192021222324252627 //返回一个实现了Comparable接口的类的对象 public Comparable getComparable()&#123; //创建一个实现了Comparable接口的类:局部内部类 //方式一：// class MyComparable implements Comparable&#123;//// @Override// public int compareTo(Object o) &#123;// return 0;// &#125;// // &#125;// // return new MyComparable(); //方式二： return new Comparable()&#123; @Override public int compareTo(Object o) &#123; return 0; &#125; &#125;; &#125; 注意点：在局部内部类的方法中（比如：show如果调用局部内部类所声明的方法(比如：method)中的局部变量(比如：num)的话,要求此局部变量声明为final的。 jdk 7及之前版本：要求此局部变量显式的声明为final的 jdk 8及之后的版本：可以省略final的声明 总结： 成员内部类和局部内部类，在编译以后，都会生成字节码文件。 格式： 成员内部类：外部类$内部类名.class 局部内部类：外部类$数字 内部类名.class 7.异常处理异常 异常的体系结构 1234567891011121314* java.lang.Throwable* |-----java.lang.Error:一般不编写针对性的代码进行处理。* |-----java.lang.Exception:可以进行异常的处理* |------编译时异常(checked)* |-----IOException* |-----FileNotFoundException* |-----ClassNotFoundException* |------运行时异常(unchecked,RuntimeException)* |-----NullPointerException* |-----ArrayIndexOutOfBoundsException* |-----ClassCastException* |-----NumberFormatException* |-----InputMismatchException* |-----ArithmeticException 从程序执行过程，看编译时异常和运行时异常 编译时异常：执行javac.exe命名时，可能出现的异常 运行时异常：执行java.exe命名时，出现的异常 常见的异常类型，请举例说明： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475//******************以下是运行时异常*************************** //ArithmeticException @Test public void test6()&#123; int a = 10; int b = 0; System.out.println(a / b); &#125; //InputMismatchException @Test public void test5()&#123; Scanner scanner = new Scanner(System.in); int score = scanner.nextInt(); System.out.println(score); scanner.close(); &#125; //NumberFormatException @Test public void test4()&#123; String str = &quot;123&quot;; str = &quot;abc&quot;; int num = Integer.parseInt(str); &#125; //ClassCastException @Test public void test3()&#123; Object obj = new Date(); String str = (String)obj; &#125; //IndexOutOfBoundsException @Test public void test2()&#123; //ArrayIndexOutOfBoundsException// int[] arr = new int[10];// System.out.println(arr[10]); //StringIndexOutOfBoundsException String str = &quot;abc&quot;; System.out.println(str.charAt(3)); &#125; //NullPointerException @Test public void test1()&#123; // int[] arr = null;// System.out.println(arr[3]); String str = &quot;abc&quot;; str = null; System.out.println(str.charAt(0)); &#125; //******************以下是编译时异常*************************** @Test public void test7()&#123;// File file = new File(&quot;hello.txt&quot;);// FileInputStream fis = new FileInputStream(file);// // int data = fis.read();// while(data != -1)&#123;// System.out.print((char)data);// data = fis.read();// &#125;// // fis.close(); &#125; 异常的处理 java异常处理的抓抛模型 过程一：”抛”：程序在正常执行的过程中，一旦出现异常，就会在异常代码处生成一个对应异常类的对象,并将此对象抛出。 一旦抛出对象以后，其后的代码就不再执行。 关于异常对象的产生：① 系统自动生成的异常对象② 手动的生成一个异常对象，并抛出（throw） 过程二：”抓”：可以理解为异常的处理方式：① try-catch-finally ② throws 异常处理方式一：try-catch-finally 使用说明： 1234567891011121314* try&#123;* //可能出现异常的代码* * &#125;catch(异常类型1 变量名1)&#123;* //处理异常的方式1* &#125;catch(异常类型2 变量名2)&#123;* //处理异常的方式2* &#125;catch(异常类型3 变量名3)&#123;* //处理异常的方式3* &#125;* ....* finally&#123;* //一定会执行的代码* &#125; finally是可选的。 使用try将可能出现异常代码包装起来，在执行过程中，一旦出现异常，就会生成一个对应异常类的对象，根据此对象的类型，去catch中进行匹配 一旦try中的异常对象匹配到某一个catch时，就进入catch中进行异常的处理。一旦处理完成，就跳出当前的try-catch结构（在没有写finally的情况）。继续执行其后的代码 catch中的异常类型如果没有子父类关系，则谁声明在上，谁声明在下无所谓。 catch中的异常类型如果满足子父类关系，则要求子类一定声明在父类的上面。否则，报错 常用的异常对象处理的方式： ① String getMessage() ② printStackTrace() 在try结构中声明的变量，再出了try结构以后，就不能再被调用 try-catch-finally结构可以嵌套 总结：如何看待代码中的编译时异常和运行时异常？ 体会1：使用try-catch-finally处理编译时异常，是得程序在编译时就不再报错，但是运行时仍可能报错。相当于我们使用try-catch-finally将一个编译时可能出现的异常，延迟到运行时出现。 体会2：开发中，由于运行时异常比较常见，所以我们通常就不针对运行时异常编写try-catch-finally了。针对于编译时异常，我们说一定要考虑异常的处理。 finally的再说明： finally是可选的 finally中声明的是一定会被执行的代码。即使catch中又出现异常了，try中有return语句，catch中有return语句等情况。 像数据库连接、输入输出流、网络编程Socket等资源，JVM是不能自动的回收的，我们需要自己手动的进行资源的释放。此时的资源释放，就需要声明在finally中。 [面试题]final、finally、finalize三者的区别？ 123456789101112类似：throw 和 throwsCollection 和 CollectionsString 、StringBuffer、StringBuilderArrayList 、 LinkedListHashMap 、LinkedHashMap重写、重载结构不相似的：抽象类、接口== 、 equals()sleep()、wait() 异常处理方式二： “throws + 异常类型”写在方法的声明处。指明此方法执行时，可能会抛出的异常类型。 一旦当方法体执行时，出现异常，仍会在异常代码处生成一个异常类的对象，此对象满足throws后异常类型时，就会被抛出。异常代码后续的代码，就不再执行！ 对比两种处理方式 try-catch-finally:真正的将异常给处理掉了。 throws的方式只是将异常抛给了方法的调用者。 并没有真正将异常处理掉。 体会开发中应该如何选择两种处理方式？ 如果父类中被重写的方法没有throws方式处理异常，则子类重写的方法也不能使用throws，意味着如果子类重写的方法中有异常，必须使用try-catch-finally方式处理。 执行的方法a中，先后又调用了另外的几个方法，这几个方法是递进关系执行的。我们建议这几个方法使用throws的方式进行处理。而执行的方法a可以考虑使用try-catch-finally方式进行处理。 补充： 方法重写的规则之一：子类重写的方法抛出的异常类型不大于父类被重写的方法抛出的异常类型 手动抛出异常对象 使用说明：在程序执行中，除了自动抛出异常对象的情况之外，我们还可以手动的throw一个异常类的对象。 [面试题]throw 和 throws区别： throw 表示抛出一个异常类的对象，生成异常对象的过程。声明在方法体内。 throws 属于异常处理的一种方式，声明在方法的声明处。 典型例题 12345678910111213141516171819202122class Student&#123; private int id; public void regist(int id) throws Exception &#123; if(id &gt; 0)&#123; this.id = id; &#125;else&#123; //手动抛出异常对象// throw new RuntimeException(&quot;您输入的数据非法！&quot;);// throw new Exception(&quot;您输入的数据非法！&quot;); throw new MyException(&quot;不能输入负数&quot;); &#125; &#125; @Override public String toString() &#123; return &quot;Student [id=&quot; + id + &quot;]&quot;; &#125; &#125; 自定义异常类 如何自定义异常类？ 继承于现的异常结构：RuntimeException 、Exception 提供全局常量：serialVersionUID 提供重载的构造器 例子 123456789101112public class MyException extends Exception&#123; static final long serialVersionUID = -7034897193246939L; public MyException()&#123; &#125; public MyException(String msg)&#123; super(msg); &#125;&#125;","categories":[{"name":"java","slug":"java","permalink":"http://110.42.136.235/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"http://110.42.136.235/tags/java/"}]},{"title":"MyBatis Plus","slug":"MyBatis-Plus","date":"2022-04-24T13:56:38.000Z","updated":"2022-05-06T10:49:28.400Z","comments":true,"path":"2022/04/24/MyBatis-Plus/","link":"","permalink":"http://110.42.136.235/2022/04/24/MyBatis-Plus/","excerpt":"","text":"MyBatisPlus的优点 无侵入：只做增强不做改变，引入它不会对现有工程产生影响，如丝般顺滑 损耗小：启动即会自动注入基本 CURD，性能基本无损耗，直接面向对象操作 强大的 CRUD 操作：内置通用 Mapper、通用 Service，仅仅通过少量配置即可实现单表大部分 CRUD 操作，更有强大的条件构造器，满足各类使用需求 支持 Lambda 形式调用：通过 Lambda 表达式，方便的编写各类查询条件，无需再担心字段写错 支持主键自动生成：支持多达 4 种主键策略（内含分布式唯一 ID 生成器 - Sequence），可自由配置，完美解决主键问题 支持 ActiveRecord 模式：支持 ActiveRecord 形式调用，实体类只需继承 Model 类即可进行强大的 CRUD 操作 支持自定义全局通用操作：支持全局通用方法注入（ Write once, use anywhere ） 内置代码生成器：采用代码或者 Maven 插件可快速生成 Mapper 、 Model 、 Service 、 Controller 层代码，支持模板引擎，更有超多自定义配置等您来使用 内置分页插件：基于 MyBatis 物理分页，开发者无需关心具体操作，配置好插件之后，写分页等同于普通 List 查询 分页插件支持多种数据库：支持 MySQL、MariaDB、Oracle、DB2、H2、HSQL、SQLite、Postgre、SQLServer 等多种数据库 内置性能分析插件：可输出 SQL 语句以及其执行时间，建议开发测试时启用该功能，能快速揪出慢查询 内置全局拦截插件：提供全表 delete 、 update 操作智能分析阻断，也可自定义拦截规则，预防误操作MyBatis-Plus使用配置环境配置pom.xml123456789101112131415161718&lt;!--MybatisPlus--&gt; &lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt; &lt;version&gt;3.5.1&lt;/version&gt; &lt;/dependency&gt;&lt;!-- lombok用于简化开发--&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt;&lt;!-- mysql驱动--&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; 配置yml文件12345678910spring:# 配置数据源信息 datasource:# 配置数据源类型 type: com.zaxxer.hikari.HikariDataSource# 配置连接数据库的各个信息 driver-class-name: com.mysql.cj.jdbc.Driver url: jdbc:mysql://localhost:3306/mybatis_plus?characterEncoding=utf-8&amp;useSSL=false&amp;serverTimezone=UTC username: root password: password 在Mapper接口中继承BaseMapper，相当于有了增删改查功能12public interface UserMapper extends BaseMapper&lt;User&gt; &#123;&#125; 启动类 1234567@SpringBootApplication@MapperScan(&quot;com.atguigu.mybatisplus.mapper&quot;)public class MybatisplusApplication &#123;public static void main(String[] args) &#123;SpringApplication.run(MybatisplusApplication.class, args);&#125;&#125; 添加实体 1234567@Data //lombok注解public class User &#123;private Long id;private String name;private Integer age;private String email;&#125; 添加mapper 注意：BaseMapper是MyBatis-Plus提供的模板mapper，其中包含了基本的CRUD方法，泛型为操作的实体类型 12public interface UserMapper extends BaseMapper&lt;User&gt; &#123;&#125; 添加service 12public interface UserService extends IService&lt;User&gt; &#123;&#125; 添加serviceImpl 1234@Servicepublic class UserServiceImpl extends ServiceImpl&lt;UserMapper, User&gt; implements UserService &#123;&#125; 添加日志 1234# 配置MyBatis日志mybatis-plus:configuration:log-impl: org.apache.ibatis.logging.stdout.StdOutImpl 常用注解@TableName在使用MyBatis-Plus实现基本的CRUD时，我们并没有指定要操作的表，只是在Mapper接口继承BaseMapper时，设置了泛型User，而操作的表为user表 由此得出结论，MyBatis-Plus在确定操作的表时，由BaseMapper的泛型决定，即实体类型决定，且默认操作的表名和实体类型的类名一致 可以在实体类上添加TableName(“”)注解,括号里的就是数据库中表的名字 TableIdMyBatis-Plus在实现CRUD时，会默认将id作为主键列，并在插入数据时，默认基于雪花算法的策略生成id，但是当主键并不是id时，需要在实体类的主键上添加@TableId注解 @TableId的value属性 若实体类中主键对应的属性为id，而表中表示主键的是字段uid此时需要通过@TableId注解的value属性，指定表中的主键字段，@TableId(“uid”)或@TableId(value=”uid”) @TableId的type属性 值 描述 IdType.ASSIGN_ID（默认） 基于雪花算法的策略生成数据id，与数据库id是否设置自增无关 IdType.AUTO 使用数据库的自增策略，注意，该类型请确保数据库设置了id自增，否则无效 配置全局主键策略 1234567891011mybatis-plus:configuration:# 配置MyBatis日志log-impl: org.apache.ibatis.logging.stdout.StdOutImplglobal-config:db-config:# 配置MyBatis-Plus操作表的默认前缀table-prefix: t_# 配置MyBatis-Plus的主键策略id-type: auto @TableField情况1 若实体类中的属性使用的是驼峰命名风格，而表中的字段使用的是下划线命名风格例如实体类属性userName，表中字段user_name此时MyBatis-Plus会自动将下划线命名风格转化为驼峰命名风格相当于在MyBatis中配置 情况2 若实体类中的属性和表中的字段不满足情况1例如实体类属性name，表中字段username此时需要在实体类属性上使用@TableField(“username”)设置属性所对应的字段名 @TableLogic逻辑删除 物理删除：真实删除，将对应数据从数据库中删除，之后查询不到此条被删除的数据 逻辑删除：假删除，将对应数据中代表是否被删除字段的状态修改为“被删除状态”，之后在数据库中仍旧能看到此条数据记录 使用场景：可以进行数据恢复 实现逻辑删除 step1：数据库中创建逻辑删除状态列，设置默认值为0 step2：实体类中添加逻辑删除属性 条件构造器和常用接口Wapper Wrapper ： 条件构造抽象类，最顶端父类 AbstractWrapper ： 用于查询条件封装，生成 sql 的 where 条件 QueryWrapper ： 查询条件封装 UpdateWrapper ： Update 条件封装 AbstractLambdaWrapper ： 使用Lambda 语法 LambdaQueryWrapper ：用于Lambda语法使用的查询Wrapper LambdaUpdateWrapper ： Lambda 更新封装Wrapper QueryWrapper12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152组装查询@Testpublic void test01()&#123;//查询用户名包含a，年龄在20到30之间，并且邮箱不为null的用户信息//SELECT id,username AS name,age,email,is_deleted FROM t_user WHEREis_deleted=0 AND (username LIKE ? AND age BETWEEN ? AND ? AND email IS NOT NULL)QueryWrapper&lt;User&gt; queryWrapper = new QueryWrapper&lt;&gt;();queryWrapper.like(&quot;username&quot;, &quot;a&quot;).between(&quot;age&quot;, 20, 30).isNotNull(&quot;email&quot;);List&lt;User&gt; list = userMapper.selectList(queryWrapper);list.forEach(System.out::println);&#125;组装排序@Testpublic void test02()&#123;//按年龄降序查询用户，如果年龄相同则按id升序排列//SELECT id,username AS name,age,email,is_deleted FROM t_user WHEREis_deleted=0 ORDER BY age DESC,id ASCQueryWrapper&lt;User&gt; queryWrapper = new QueryWrapper&lt;&gt;();queryWrapper.orderByDesc(&quot;age&quot;).orderByAsc(&quot;id&quot;);List&lt;User&gt; users = userMapper.selectList(queryWrapper);users.forEach(System.out::println);&#125;组装删除@Testpublic void test03()&#123;//删除email为空的用户//DELETE FROM t_user WHERE (email IS NULL)QueryWrapper&lt;User&gt; queryWrapper = new QueryWrapper&lt;&gt;();queryWrapper.isNull(&quot;email&quot;);//条件构造器也可以构建删除语句的条件int result = userMapper.delete(queryWrapper);System.out.println(&quot;受影响的行数：&quot; + result);&#125;组装select子句@Testpublic void test05() &#123;//查询用户信息的username和age字段//SELECT username,age FROM t_userQueryWrapper&lt;User&gt; queryWrapper = new QueryWrapper&lt;&gt;();queryWrapper.select(&quot;username&quot;, &quot;age&quot;);//selectMaps()返回Map集合列表，通常配合select()使用，避免User对象中没有被查询到的列值为nullList&lt;Map&lt;String, Object&gt;&gt; maps = userMapper.selectMaps(queryWrapper);maps.forEach(System.out::println);&#125; MyBatisPlus分页插件创建配置类 1234567891011@Configuration//扫描mapper包@MapperScan(&quot;com/example/mybatisplus/mapper&quot;)public class MyBatisPlusConfig &#123; @Bean public MybatisPlusInterceptor mybatisPlusInterceptor()&#123; MybatisPlusInterceptor interceptor = new MybatisPlusInterceptor(); interceptor.addInnerInterceptor(new PaginationInnerInterceptor(DbType.MYSQL)); return interceptor; &#125;&#125; 测试方法 1234567891011121314151617181920212223@Test public void testPage()&#123; Page&lt;User&gt; page = new Page&lt;&gt;(1,3); userMapper.selectPage(page,null); System.out.println(page.getRecords()); &#125;@Testpublic void testPage()&#123;//设置分页参数Page&lt;User&gt; page = new Page&lt;&gt;(1, 5);userMapper.selectPage(page, null);//获取分页数据List&lt;User&gt; list = page.getRecords();list.forEach(System.out::println);System.out.println(&quot;当前页：&quot;+page.getCurrent());System.out.println(&quot;每页显示的条数：&quot;+page.getSize());System.out.println(&quot;总记录数：&quot;+page.getTotal());System.out.println(&quot;总页数：&quot;+page.getPages());System.out.println(&quot;是否有上一页：&quot;+page.hasPrevious());System.out.println(&quot;是否有下一页：&quot;+page.hasNext());&#125; Xml自定义分页UserMapper中自定义接口方法 12345678910/*** 根据年龄查询用户列表，分页显示* @param page 分页对象,xml中可以从里面进行取值,传递参数 Page 即自动分页,必须放在第一位* @param age 年龄* @return*/IPage&lt;User&gt; selectPageVo(@Param(&quot;page&quot;) Page&lt;User&gt; page, @Param(&quot;age&quot;)Integer age); UserMapper.xml中编写SQL 1234567&lt;!--SQL片段，记录基础字段--&gt;&lt;sql id=&quot;BaseColumns&quot;&gt;id,username,age,email&lt;/sql&gt;&lt;!--IPage&lt;User&gt; selectPageVo(Page&lt;User&gt; page, Integer age);--&gt;&lt;select id=&quot;selectPageVo&quot; resultType=&quot;User&quot;&gt;SELECT &lt;include refid=&quot;BaseColumns&quot;&gt;&lt;/include&gt; FROM t_user WHERE age = #&#123;age&#125;&lt;/select&gt; 代码生成器第一步引入依赖 1234567891011&lt;!--代码生成器--&gt; &lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-generator&lt;/artifactId&gt; &lt;version&gt;3.5.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.freemarker&lt;/groupId&gt; &lt;artifactId&gt;freemarker&lt;/artifactId&gt; &lt;version&gt;2.3.31&lt;/version&gt; &lt;/dependency&gt; 第二步执行方法 12345678910111213141516171819202122 public static void main(String[] args) &#123; FastAutoGenerator.create(&quot;jdbc:mysql://127.0.0.1:3306/mybatis_plus? characterEncoding=utf-8&amp;userSSL=false&quot;, &quot;root&quot;, &quot;password&quot;) .globalConfig(builder -&gt; &#123; builder.author(&quot;atguigu&quot;) // 设置作者//.enableSwagger() // 开启 swagger 模式 .fileOverride() // 覆盖已生成文件 .outputDir(&quot;D://mybatis_plus&quot;); // 指定输出目录 &#125;) .packageConfig(builder -&gt; &#123; builder.parent(&quot;com.example&quot;) // 设置父包名 .moduleName(&quot;mybatisplus&quot;) // 设置父包模块名 .pathInfo(Collections.singletonMap(OutputFile.mapperXml, &quot;D://mybatis_plus&quot;));// 设置mapperXml生成路径 &#125;) .strategyConfig(builder -&gt; &#123; builder.addInclude(&quot;user&quot;) // 设置需要生成的表名 .addTablePrefix(&quot;t_&quot;, &quot;c_&quot;); // 设置过滤表前缀 &#125;) .templateEngine(new FreemarkerTemplateEngine()) // 使用Freemarker引擎模板，默认的是Velocity引擎模板 .execute(); &#125;","categories":[{"name":"MyBatisPlus","slug":"MyBatisPlus","permalink":"http://110.42.136.235/categories/MyBatisPlus/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://110.42.136.235/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"Redis6学习笔记","slug":"Redis6学习笔记","date":"2022-04-24T12:58:53.000Z","updated":"2022-05-03T01:17:24.069Z","comments":true,"path":"2022/04/24/Redis6学习笔记/","link":"","permalink":"http://110.42.136.235/2022/04/24/Redis6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"","text":"NoSQL数据库概述什么是NoSQL数据库NoSQL(NoSQL = Not Only SQL )，意即“不仅仅是SQL”，泛指非关系型的数据库。 NoSQL 不依赖业务逻辑方式存储，而以简单的key-value模式存储。因此大大的增加了数据库的扩展能力。 不遵循SQL标准。 不支持ACID。原子性 一致性 隔离性 持续性 远超于SQL的性能。 NoSQL适用场景 对数据高并发的读写 海量数据的读写 对数据高可扩展性的 NoSQL不适用场景 需要事务支持 基于sql的结构化查询存储，处理复杂的关系,需要即席查询。 Redis的优点 几乎覆盖了Memcached的绝大部分功能 数据都在内存中，支持持久化，主要用作备份恢复 除了支持简单的key-value模式，还支持多种数据结构的存储，比如**list、set、hash、zset**等。 一般是作为缓存数据库辅助持久化的数据库 Redis是单线程+多路IO复用技术多路复用是指使用一个线程来检查多个文件描述符（Socket）的就绪状态，比如调用select和poll函数，传入多个文件描述符，如果有一个文件描述符就绪，则返回，否则阻塞直到超时。得到就绪状态后进行真正的操作可以在同一个线程里执行，也可以启动线程执行（比如使用线程池） 串行 vs 多线程+锁（memcached） vs 单线程+多路IO复用(Redis) Redis 使用 Windows下使用1234567127.0.0.1:6379&gt; pingPONG127.0.0.1:6379&gt; set name whtOK127.0.0.1:6379&gt; get name&quot;wht&quot;127.0.0.1:6379&gt; Redis linux下使用(常用命令)redis一共有16个数据库，默认使用第一个数据库 ，可以使用select来切换数据库 12345[root@VM-12-7-centos ~]# redis-cli127.0.0.1:6379&gt; select 1OK127.0.0.1:6379[1]&gt; dbsize(integer) 0 插入key值 12127.0.0.1:6379&gt; set name whtOK 查看当前所有key值 12127.0.0.1:6379&gt; keys *1) &quot;name&quot; 查看key值内容 1234127.0.0.1:6379&gt; set name whtOK127.0.0.1:6379&gt; get name&quot;wht&quot; 删除某个key值 mov +key值+当前数据库 12127.0.0.1:6379&gt; move name 1(integer) 1 给某个key值加上过期时间和查看剩余时间 123456789127.0.0.1:6379&gt; set name whtOK127.0.0.1:6379&gt; expire name 10(integer) 1127.0.0.1:6379&gt; ttl name(integer) 7127.0.0.1:6379&gt; ttl name(integer) 1127.0.0.1:6379 查看当前key的类型 1234567127.0.0.1:6379&gt; keys *1) &quot;age&quot;2) &quot;name&quot;127.0.0.1:6379&gt; type agestring127.0.0.1:6379&gt; type namestring 清空当库的全部key值 1234127.0.0.1:6379&gt; flushdbOK127.0.0.1:6379&gt; keys *(empty array) 清除所有数据库 1flushall 查看当前key值是否存在 1exists name Redis是单线程 Redis是基于内存操作的，CPU并不是Redis的性能瓶颈，主要由机器内存和网络带宽决定 为什么单线程还这么快Redis所示c语言写的，官方数据，100000+QPS 核心：Redis将所有数据都放在内存中，所以使用单线程去操作是效率最高的 多线程上下文切换是个耗时的操作 Redis五大基本数据String字符串给key值追加字段 append 1234127.0.0.1:6379&gt; set name whtOK127.0.0.1:6379&gt; append name wht2(integer) 7 查看当前key值得长度 1234127.0.0.1:6379&gt; get name&quot;whtwht2&quot;127.0.0.1:6379&gt; STRLEN name(integer) 7 加一减一操作 12345678910127.0.0.1:6379&gt; get view&quot;0&quot;127.0.0.1:6379&gt; incr view(integer) 1127.0.0.1:6379&gt; get view &quot;1&quot;127.0.0.1:6379&gt; decr view (integer) 0127.0.0.1:6379&gt; get view &quot;0&quot; 连续增加和连续减少 123456127.0.0.1:6379&gt; get view &quot;0&quot;127.0.0.1:6379&gt; INCRBY view 10(integer) 10127.0.0.1:6379&gt; DECRBY view 5(integer) 5 获取某个区间的字符(如果是0到-1表示获取全部字符串) 1234127.0.0.1:6379&gt; get name&quot;whttttttt&quot;127.0.0.1:6379&gt; GETRANGE name 0 3&quot;whtt&quot; setex(set with expire) 设置key3的值为hello 30秒后过期 1234127.0.0.1:6379&gt; setex key3 30 &quot;hello&quot;OK127.0.0.1:6379&gt; ttl key3(integer) 21 setnx (set if not exist) 不存在则设置，在分布式锁中常用 1234127.0.0.1:6379&gt; setnx name &quot;wht2&quot;(integer) 0127.0.0.1:6379&gt; get name&quot;whttttttt&quot;#还是原来的值，因为已经存在，所以创建失败 mset 批量创建 123456127.0.0.1:6379&gt; mset k1 v1 k2 v2 k3 v3OK127.0.0.1:6379&gt; keys *1) &quot;k2&quot;2) &quot;k1&quot;3) &quot;k3&quot; mget 批量获取 1234127.0.0.1:6379&gt; mget k1 k2 k31) &quot;v1&quot;2) &quot;v2&quot;3) &quot;v3&quot; msetnx 如果不存在则批量创建(遵循原子性原则) 123456127.0.0.1:6379&gt; msetnx k1 v1 k2 v2 k4 v4(integer) 0127.0.0.1:6379&gt; keys *1) &quot;k2&quot;2) &quot;k1&quot;3) &quot;k3 #因为k1 和k2存在，所以k4没有创建成功 设置一个json字符串保存数据 1234set user1:1&#123;name:zhangsan,age:3&#125;127.0.0.1:6379&gt; get user1:1&quot;&#123;name:zhangsan,age:3&#125;&quot; user:{id}:{filed} 12345127.0.0.1:6379&gt; mset user2:1:name wht user2:1:age 18OK127.0.0.1:6379&gt; mget user2:1:name user2:1:age1) &quot;wht&quot;2) &quot;18&quot; getset 先get再set，如果不存在则创建,返回的是当前get的值 1234127.0.0.1:6379&gt; GETSET db redis(nil)127.0.0.1:6379&gt; get db&quot;redis&quot; 字符串时应用场景最多的地方，不仅可以是字符串，还可以是数字 List所有list命令都是l开头的 LPUSH LRANGE list作为堆栈使用，先进后出 1234567891011127.0.0.1:6379&gt; LPUSH list one(integer) 1127.0.0.1:6379&gt; LPUSH list two(integer) 2127.0.0.1:6379&gt; LPUSH list three(integer) 3127.0.0.1:6379&gt; LRANGE list 0 -11) &quot;three&quot;2) &quot;two&quot;3) &quot;one&quot; RPUSH LPUSH list作为队列使用,可以从左边或者右边插入 123456789101112131415127.0.0.1:6379&gt; RPUSH list right(integer) 4127.0.0.1:6379&gt; LRANGE list 0 -11) &quot;three&quot;2) &quot;two&quot;3) &quot;one&quot;4) &quot;right&quot;127.0.0.1:6379&gt; LPUSH list left(integer) 5127.0.0.1:6379&gt; LRANGE list 0 -11) &quot;left&quot;2) &quot;three&quot;3) &quot;two&quot;4) &quot;one&quot;5) &quot;right&quot; LPOP RPOP 出栈 1234567127.0.0.1:6379&gt; LPOP list&quot;left&quot;127.0.0.1:6379&gt; LRANGE list 0 -11) &quot;three&quot;2) &quot;two&quot;3) &quot;one&quot;4) &quot;right&quot; LINDEX 通过索引获取元素 12127.0.0.1:6379&gt; LINDEX list 0&quot;three&quot; LLEN获取list长度 12127.0.0.1:6379&gt; LLEN list(integer) 4 LREM 移除指定元素，可以指定数量 12345678910127.0.0.1:6379&gt; LRANGE list 0 -11) &quot;three&quot;2) &quot;three&quot;3) &quot;two&quot;4) &quot;right&quot;127.0.0.1:6379&gt; LREM list 2 three(integer) 2127.0.0.1:6379&gt; lrange list 0 -11) &quot;two&quot;2) &quot;right&quot; ltrim 截取指定list 12345678910127.0.0.1:6379&gt; LRANGE list 0 -11) &quot;three&quot;2) &quot;three&quot;3) &quot;two&quot;4) &quot;right&quot;127.0.0.1:6379&gt; ltrim list 1 2OK127.0.0.1:6379&gt; LRANGE list 0 -1 #list已经被改变了1) &quot;three&quot;2) &quot;two&quot; RPOPLPUSH 移除列表最后一个元素，移入新的lsit 1234127.0.0.1:6379&gt; RPOPLPUSH list newlist&quot;two&quot;127.0.0.1:6379&gt; LRANGE newlist 0 -11) &quot;two&quot; LINSERT +before 和after 在指定字段后面或者前面插入新的值 12345678127.0.0.1:6379&gt; LINSERT list before &quot;three&quot; new (integer) 2127.0.0.1:6379&gt; LINSERT list after three new2(integer) 3127.0.0.1:6379&gt; LRANGE list 0 -11) &quot;new&quot;2) &quot;three&quot;3) &quot;new2&quot; 使用场景 ：消息队列，栈 set（集合）set集合的命令都是以s开头的 集合是不能重复的,且无序 插入sadd 和查询smembers 12345678910127.0.0.1:6379&gt; sadd myset hello(integer) 1127.0.0.1:6379&gt; sadd myset wht(integer) 1127.0.0.1:6379&gt; sadd myset wht2(integer) 1127.0.0.1:6379&gt; smembers myset1) &quot;wht&quot;2) &quot;hello&quot;3) &quot;wht2&quot; sismember判断某一个元素是不是在集合中’ 1sismember myset wht scard 查看当前集合中有多少个元素 12127.0.0.1:6379&gt; SCARD myset(integer) 3 srem(remove)从当前集合中移除某个元素 12127.0.0.1:6379&gt; SREM myset hello(integer) 1 srandmember随机抽取一个集合的元素(类似抽奖) 1234127.0.0.1:6379&gt; srandmember myset&quot;wht2&quot;127.0.0.1:6379&gt; srandmember myset&quot;wht&quot; spop 随机删除一个集合中的元素 1spop myset smove将制定元素移动到另外一个集合中 123456127.0.0.1:6379&gt; smove myset myset2 wht7 (integer) 1127.0.0.1:6379&gt; smembers myset21) &quot;bbb&quot;2) &quot;aaa&quot;3) &quot;wht7&quot; sdiff求差集 sinter求交集 sunion求并集 12345678910111213141516127.0.0.1:6379&gt; smembers myset21) &quot;bbb&quot;2) &quot;aaa&quot;3) &quot;wht7&quot;127.0.0.1:6379&gt; smembers myset1) &quot;wht8&quot;2) &quot;aaa&quot;127.0.0.1:6379&gt; SDIFF myset myset21) &quot;wht8&quot;127.0.0.1:6379&gt; sinter myset myset21) &quot;aaa&quot;127.0.0.1:6379&gt; SUNION myset myset21) &quot;bbb&quot;2) &quot;wht8&quot;3) &quot;aaa&quot;4) &quot;wht7&quot; 交集可以做共同好友，共同关注，可能认识的人等功能 Hash（哈希）Map集合，key-value集合，这时候是map集合 所有hash命令都已h开头！ hset 加入值 ，hget取值 1234127.0.0.1:6379&gt; hset myhash field1 wht1(integer) 1127.0.0.1:6379&gt; hget myhash field1&quot;wht1&quot; hmset加入多个值， mget获取多个值, hgetall获取所有数据 12345678910127.0.0.1:6379&gt; hmset myhash field1 hello1 field2 hello2OK127.0.0.1:6379&gt; hmget myhash field1 field21) &quot;wht1&quot;2) &quot;hello2&quot;127.0.0.1:6379&gt; hgetall myhash1) &quot;field1&quot;2) &quot;hello1&quot;5) &quot;field2&quot;6) &quot;hello2&quot; 设置值若有重复值则会覆盖原来的值 hdel删除指定的key字段 1hdel myhash filed1 hlen获取hash表的字段长度 12127.0.0.1:6379&gt; hlen myhash(integer) 2 exists当前键是否存在 12127.0.0.1:6379&gt; exists myhash field1(integer) 1 hinceby给指定值增加指定值 1234127.0.0.1:6379&gt; hset myhash field3 5(integer) 1127.0.0.1:6379&gt; hincrby myhash field3 2(integer) 7 hsetnx 如果不存在则创建，否则创建失败 设置键值对的方式 1234127.0.0.1:6379&gt; hset user:1 name wht(integer) 1127.0.0.1:6379&gt; hget user:1 name&quot;wht&quot; Zset有序集合zadd添加 ，zrange 查询 12345678127.0.0.1:6379&gt; zadd myset 1 one(integer) 1127.0.0.1:6379&gt; zadd myset 2 two 3 three(integer) 2127.0.0.1:6379&gt; zrange myset 0 -11) &quot;one&quot;2) &quot;two&quot;3) &quot;three&quot; zrangebyscore按照score从小到大排序 1234567127.0.0.1:6379&gt; zrangebyscore myset -inf +inf withscores1) &quot;one&quot;2) &quot;1&quot;3) &quot;two&quot;4) &quot;2&quot;5) &quot;three&quot;6) &quot;3&quot; ZREVRANGEBYSCORE按照score从大到小排序 123127.0.0.1:6379&gt; ZREVRANGEBYSCORE myset +inf -inf1) &quot;three&quot;2) &quot;two&quot; zrevrange按照索引从大到小排序 反之rerange是按照索引从小到大排序 123127.0.0.1:6379&gt; zrevrange myset 0 -11) &quot;three&quot;2) &quot;two&quot; zrem移除某个元素 1zrem myset one zcard获取有序集合中的个数 zcount获取某个区间的个数 12127.0.0.1:6379&gt; ZCOUNT myset 2 3(integer) 2 应用场景：排行榜，班级排序 三种特殊数据类型geospatial地理位置在redis3.2中支持推出地理位置功能，根据经度和纬度 geoadd添加地理位置 12GEOADD china:city 116.40 39.90 beijingGEOADD china:city 121.47 31.23 shanghai geopos获取地理位置 12345127.0.0.1:6379&gt; geopos china:city beijing shanghai1) 1) &quot;116.39999896287918091&quot; 2) &quot;39.90000009167092543&quot;2) 1) &quot;121.47000163793563843&quot; 2) &quot;31.22999903975783553&quot; geodist获取两个位置的距离，单位默认是米，可以在最后指定单位 1234127.0.0.1:6379&gt; geodist china:city beijing shanghai&quot;1067378.7564&quot;127.0.0.1:6379&gt; geodist china:city beijing shanghai km&quot;1067.3788&quot; georadius以给定值为半径，在圆圈内寻找 12127.0.0.1:6379&gt; georadius china:city 110 40 1000 km1) &quot;beijing&quot; 功能：附近的人 georadiusbymember以城市为圆心 12127.0.0.1:6379&gt; georadiusbymember china:city beijing 1000 km1) &quot;beijing&quot; Hyperloglog基数基数就是不重复元素的个数，比如网站的访问人数，一个人访问一个网站多次是记作一次的 会有一定的错误率但在可接受范围内 pfadd增加 pfcount计算基数个数 123456127.0.0.1:6379&gt; pfadd mykey a b c d e f(integer) 1127.0.0.1:6379&gt; pfadd mykey2 a b c d e f g(integer) 1127.0.0.1:6379&gt; pfcount mykey mykey2(integer) 7 如果允许容错，则可以使用hyperloglog，否则应该使用集合 Bitmaps 位存储 占用内存较少 用途：统计用户活跃度，打卡 setbit 设置状态 bitcount查询1的个数 12345678127.0.0.1:6379&gt; setbit sign 0 1(integer) 0127.0.0.1:6379&gt; setbit sign 1 0(integer) 0127.0.0.1:6379&gt; setbit sign 2 1(integer) 0127.0.0.1:6379&gt; bitcount sign(integer) 2 Redis事务redis单条命令是符合原子性的 但redis的事务是没有原子性和隔离级别的 所有命令并没有直接被执行，而是发起执行命令时才会被执行 redis事务 开启事务 命令入队 执行事务 multi开启事务，exec执行队列 123456789101112131415127.0.0.1:6379&gt; MULTIOK127.0.0.1:6379(TX)&gt; set k1 v1QUEUED127.0.0.1:6379(TX)&gt; set k2 v2QUEUED127.0.0.1:6379(TX)&gt; get k1QUEUED127.0.0.1:6379(TX)&gt; get k2QUEUED127.0.0.1:6379(TX)&gt; EXEC1) OK2) OK3) &quot;v1&quot;4) &quot;v2&quot; discard放弃事务,队列里的命令并不会执行 123456127.0.0.1:6379(TX)&gt; set k3 v3QUEUED127.0.0.1:6379(TX)&gt; DISCARDOK127.0.0.1:6379&gt; get k3(nil) 事务错误类型 编译型异常 ，代码或命令有问题，事务中的所有命令都不会执行 运行时出现异常，事务队列中存在语法异常，执行命令时，其他命令可以正常执行，错误命令抛出异常 乐观锁什么是悲观锁和乐观锁悲观锁：认为什么时候都会出问题，无论做什么都会加锁，影响性能 乐观锁：认为不会出问题，所以不会加锁，更新数据的时候去判断一下，在此期间是否有人修改过这个数据 watch可以开启监视对象 Redis发布订阅subscribe订阅wht 12345678127.0.0.1:6379&gt; subscribe whtReading messages... (press Ctrl-C to quit)1) &quot;subscribe&quot;2) &quot;wht&quot;3) (integer) 11) &quot;message&quot;2) &quot;wht&quot;3) &quot;hello redis&quot; publish发布订阅 123127.0.0.1:6379&gt; PUBLISH wht &quot;hello redis&quot;(integer) 1127.0.0.1:6379&gt; Redis集群info replication查看集群信息 12345678910111213127.0.0.1:6379&gt; info replication# Replicationrole:masterconnected_slaves:0master_failover_state:no-failovermaster_replid:8a44af6f2d0b6738eae98e2f3c5f0ef76503378cmaster_replid2:0000000000000000000000000000000000000000master_repl_offset:0second_repl_offset:-1repl_backlog_active:0repl_backlog_size:1048576repl_backlog_first_byte_offset:0repl_backlog_histlen:0","categories":[{"name":"Redis","slug":"Redis","permalink":"http://110.42.136.235/categories/Redis/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://110.42.136.235/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"SpringBoot","slug":"SpringBoot","date":"2022-04-16T12:55:33.000Z","updated":"2022-04-26T03:17:41.519Z","comments":true,"path":"2022/04/16/SpringBoot/","link":"","permalink":"http://110.42.136.235/2022/04/16/SpringBoot/","excerpt":"","text":"SpringBootSpring 缺点1） 配置繁琐虽然Spring的组件代码是轻量级的，但它的配置却是重量级的。一开始，Spring用XML配置，而且是很多XML配置。Spring 2.5引入了基于注解的组件扫描，这消除了大量针对应用程序自身组件的显式XML配置。Spring 3.0引入了基于Java的配置，这是一种类型安全的可重构配置方式，可以代替XML。所有这些配置都代表了开发时的损耗。因为在思考Spring特性配置和解决业务问题之间需要进行思维切换，所以编写配置挤占了编写应用程序逻辑的时间。和所有框架一样，Spring实用，但它要求的回报也不少。 2）依赖繁琐项目的依赖管理也是一件耗时耗力的事情。在环境搭建时，需要分析要导入哪些库的坐标，而且还需要分析导入与之有依赖关系的其他库的坐标，一旦选错了依赖的版本，随之而来的不兼容问题就会严重阻碍项目的开发进度。 SpringBoot 概述SpringBoot 功能1） 自动配置Spring Boot的自动配置是一个运行时（更准确地说，是应用程序启动时）的过程，考虑了众多因素，才决定Spring配置应该用哪个，不该用哪个。该过程是SpringBoot自动完成的。 2） 起步依赖起步依赖本质上是一个Maven项目对象模型（Project Object Model，POM），定义了对其他库的传递依赖，这些东西加在一起即支持某项功能。简单的说，起步依赖就是将具备某种功能的坐标打包到一起，并提供一些默认的功能。 3） 辅助功能提供了一些大型项目中常见的非功能性特性，如嵌入式服务器、安全、指标，健康检测、外部配置等。Spring Boot 并不是对 Spring 功能上的增强，而是提供了一种快速使用 Spring 的方式。 SpringBoot 起步依赖原理分析 在spring-boot-starter-parent中定义了各种技术的版本信息，组合了一套最优搭配的技术版本。 在各种starter中，定义了完成该功能需要的坐标合集，其中大部分版本信息来自于父工程。 我们的工程继承parent，引入starter后，通过依赖传递，就可以简单方便获得需要的jar包，并且不会存在版本冲突等问题。 SpringBoot 配置配置文件分类SpringBoot是基于约定的，所以很多配置都有默认值，但如果想使用自己的配置替换默认配置的话，就可以使用application.properties或者application.yml（application.yaml）进行配置。 properties： server.port=8080 yml: server: port: 8080 YAMLYAML全称是 YAML Ain’t Markup Language 。YAML是一种直观的能够被电脑识别的的数据数据序列化格式，并且容易被人类阅读，容易和脚本语言交互的，可以被支持YAML库的不同的编程语言程序导入，比如： C/C++, Ruby, Python, Java, Perl, C#, PHP等。YML文件是以数据为核心的，比传统的xml方式更加简洁。YAML文件的扩展名可以使用.yml或者.yaml。 YAML：基本语法 大小写敏感 数据值前边必须有空格，作为分隔符 使用缩进表示层级关系 缩进时不允许使用Tab键，只允许使用空格（各个系统 Tab对应的 空格数目可能不同，导致层次混乱）。 缩进的空格数目不重要，只要相同层级的元素左侧对齐即可 ‘#’ 表示注释，从这个字符一直到行尾，都会被解析器忽略。1234server: port: 8080address: 127.0.0.1name: abc YAML：数据格式 对象(map)：键值对的集合。1234person:name: zhangsan# 行内写法person: &#123;name: zhangsan&#125; 数组：一组按次序排列的值12345address:- beijing- shanghai# 行内写法address: [beijing,shanghai] 纯量：单个的、不可再分的值12msg1: &#x27;hello \\n world&#x27; # 单引忽略转义字符msg2: &quot;hello \\n world&quot; # 双引识别转义字符 YAML：参数引用123name: lisiperson:name: $&#123;name&#125; # 引用上边定义的name值 小结 1） 配置文件类型 properties：和以前一样 yml/yaml：注意空格 2） yaml：简洁，以数据为核心 基本语法 • 大小写敏感 • 数据值前边必须有空格，作为分隔符 • 使用空格缩进表示层级关系，相同缩进表示同一级&gt; 数据格式 • 对象 • 数组: 使用 “- ”表示数组每个元素 • 纯量 参数引用 • ${key} SpringBoot注入yml使用value注解123456@Value(&quot;$&#123;name&#125;&quot;)//元素注入private String name1;@Value(&quot;$&#123;person.age&#125;&quot;)//对象注入private int age;@Value(&quot;$&#123;address[0]&#125;&quot;)//数组注入private String address; 使用Environment获取yml对象12345//使用Environment获取yml对象 @Autowired Environment environment; //在方法中 String name = environment.getProperty(&quot;address&quot;); ConfigurationProperties12345@Component@ConfigurationProperties(&quot;person&quot;)public class Person &#123; private String name; private int age; profile我们在开发Spring Boot应用时，通常同一套程序会被安装到不同环境，比如：开发、测试、生产等。其中数据库地址、服务器端口等等配置都不同，如果每次打包时，都要修改配置文件，那么非常麻烦。profile功能就是来进行动态配置切换的。 1） profile配置方式 多profile文件方式 yml多文档方式 2） profile激活方式 配置文件 虚拟机参数 命令行参数","categories":[{"name":"spring","slug":"spring","permalink":"http://110.42.136.235/categories/spring/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://110.42.136.235/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"SpringMVC","slug":"SpringMVC笔记","date":"2022-04-13T13:33:24.000Z","updated":"2022-04-23T02:51:24.974Z","comments":true,"path":"2022/04/13/SpringMVC笔记/","link":"","permalink":"http://110.42.136.235/2022/04/13/SpringMVC%E7%AC%94%E8%AE%B0/","excerpt":"","text":"[TOC] 一、SpringMVC简介1、什么是MVCMVC是一种软件架构的思想，将软件按照模型、视图、控制器来划分 M：Model，模型层，指工程中的JavaBean，作用是处理数据 JavaBean分为两类： 一类称为实体类Bean：专门存储业务数据的，如 Student、User 等 一类称为业务处理 Bean：指 Service 或 Dao 对象，专门用于处理业务逻辑和数据访问。 V：View，视图层，指工程中的html或jsp等页面，作用是与用户进行交互，展示数据 C：Controller，控制层，指工程中的servlet，作用是接收请求和响应浏览器 MVC的工作流程：用户通过视图层发送请求到服务器，在服务器中请求被Controller接收，Controller调用相应的Model层处理请求，处理完毕将结果返回到Controller，Controller再根据请求处理的结果找到相应的View视图，渲染数据后最终响应给浏览器 2、什么是SpringMVCSpringMVC是Spring的一个后续产品，是Spring的一个子项目 SpringMVC 是 Spring 为表述层开发提供的一整套完备的解决方案。在表述层框架历经 Strust、WebWork、Strust2 等诸多产品的历代更迭之后，目前业界普遍选择了 SpringMVC 作为 Java EE 项目表述层开发的首选方案。 注：三层架构分为表述层（或表示层）、业务逻辑层、数据访问层，表述层表示前台页面和后台servlet 3、SpringMVC的特点 Spring 家族原生产品，与 IOC 容器等基础设施无缝对接 基于原生的Servlet，通过了功能强大的前端控制器DispatcherServlet，对请求和响应进行统一处理 表述层各细分领域需要解决的问题全方位覆盖，提供全面解决方案 代码清新简洁，大幅度提升开发效率 内部组件化程度高，可插拔式组件即插即用，想要什么功能配置相应组件即可 性能卓著，尤其适合现代大型、超大型互联网项目要求 二、HelloWorld1、开发环境IDE：idea 2019.2 构建工具：maven3.5.4 服务器：tomcat7 Spring版本：5.3.1 2、创建maven工程a&gt;添加web模块b&gt;打包方式：warc&gt;引入依赖123456789101112131415161718192021222324252627282930&lt;dependencies&gt; &lt;!-- SpringMVC --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;5.3.1&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 日志 --&gt; &lt;dependency&gt; &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt; &lt;artifactId&gt;logback-classic&lt;/artifactId&gt; &lt;version&gt;1.2.3&lt;/version&gt; &lt;/dependency&gt; &lt;!-- ServletAPI --&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;3.1.0&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- Spring5和Thymeleaf整合包 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.thymeleaf&lt;/groupId&gt; &lt;artifactId&gt;thymeleaf-spring5&lt;/artifactId&gt; &lt;version&gt;3.0.12.RELEASE&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 注：由于 Maven 的传递性，我们不必将所有需要的包全部配置依赖，而是配置最顶端的依赖，其他靠传递性导入。 3、配置web.xml注册SpringMVC的前端控制器DispatcherServlet a&gt;默认配置方式此配置作用下，SpringMVC的配置文件默认位于WEB-INF下，默认名称为&lt;servlet-name&gt;-servlet.xml，例如，以下配置所对应SpringMVC的配置文件位于WEB-INF下，文件名为springMVC-servlet.xml 1234567891011121314&lt;!-- 配置SpringMVC的前端控制器，对浏览器发送的请求统一进行处理 --&gt;&lt;servlet&gt; &lt;servlet-name&gt;springMVC&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;springMVC&lt;/servlet-name&gt; &lt;!-- 设置springMVC的核心控制器所能处理的请求的请求路径 /所匹配的请求可以是/login或.html或.js或.css方式的请求路径 但是/不能匹配.jsp请求路径的请求 --&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; b&gt;扩展配置方式可通过init-param标签设置SpringMVC配置文件的位置和名称，通过load-on-startup标签设置SpringMVC前端控制器DispatcherServlet的初始化时间 123456789101112131415161718192021222324252627&lt;!-- 配置SpringMVC的前端控制器，对浏览器发送的请求统一进行处理 --&gt;&lt;servlet&gt; &lt;servlet-name&gt;springMVC&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!-- 通过初始化参数指定SpringMVC配置文件的位置和名称 --&gt; &lt;init-param&gt; &lt;!-- contextConfigLocation为固定值 --&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;!-- 使用classpath:表示从类路径查找配置文件，例如maven工程中的src/main/resources --&gt; &lt;param-value&gt;classpath:springMVC.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;!-- 作为框架的核心组件，在启动过程中有大量的初始化操作要做 而这些操作放在第一次请求时才执行会严重影响访问速度 因此需要通过此标签将启动控制DispatcherServlet的初始化时间提前到服务器启动时 --&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;springMVC&lt;/servlet-name&gt; &lt;!-- 设置springMVC的核心控制器所能处理的请求的请求路径 /所匹配的请求可以是/login或.html或.js或.css方式的请求路径 但是/不能匹配.jsp请求路径的请求 --&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 注： &lt;url-pattern&gt;标签中使用/和/*的区别： /所匹配的请求可以是/login或.html或.js或.css方式的请求路径，但是/不能匹配.jsp请求路径的请求 因此就可以避免在访问jsp页面时，该请求被DispatcherServlet处理，从而找不到相应的页面 /*则能够匹配所有请求，例如在使用过滤器时，若需要对所有请求进行过滤，就需要使用/*的写法 4、创建请求控制器由于前端控制器对浏览器发送的请求进行了统一的处理，但是具体的请求有不同的处理过程，因此需要创建处理具体请求的类，即请求控制器 请求控制器中每一个处理请求的方法成为控制器方法 因为SpringMVC的控制器由一个POJO（普通的Java类）担任，因此需要通过@Controller注解将其标识为一个控制层组件，交给Spring的IoC容器管理，此时SpringMVC才能够识别控制器的存在 1234@Controllerpublic class HelloController &#123; &#125; 5、创建springMVC的配置文件1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;!-- 自动扫描包 --&gt;&lt;context:component-scan base-package=&quot;com.atguigu.mvc.controller&quot;/&gt;&lt;!-- 配置Thymeleaf视图解析器 --&gt;&lt;bean id=&quot;viewResolver&quot; class=&quot;org.thymeleaf.spring5.view.ThymeleafViewResolver&quot;&gt; &lt;property name=&quot;order&quot; value=&quot;1&quot;/&gt; &lt;property name=&quot;characterEncoding&quot; value=&quot;UTF-8&quot;/&gt; &lt;property name=&quot;templateEngine&quot;&gt; &lt;bean class=&quot;org.thymeleaf.spring5.SpringTemplateEngine&quot;&gt; &lt;property name=&quot;templateResolver&quot;&gt; &lt;bean class=&quot;org.thymeleaf.spring5.templateresolver.SpringResourceTemplateResolver&quot;&gt; &lt;!-- 视图前缀 --&gt; &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/templates/&quot;/&gt; &lt;!-- 视图后缀 --&gt; &lt;property name=&quot;suffix&quot; value=&quot;.html&quot;/&gt; &lt;property name=&quot;templateMode&quot; value=&quot;HTML5&quot;/&gt; &lt;property name=&quot;characterEncoding&quot; value=&quot;UTF-8&quot; /&gt; &lt;/bean&gt; &lt;/property&gt; &lt;/bean&gt; &lt;/property&gt;&lt;/bean&gt;&lt;!-- 处理静态资源，例如html、js、css、jpg 若只设置该标签，则只能访问静态资源，其他请求则无法访问 此时必须设置&lt;mvc:annotation-driven/&gt;解决问题 --&gt;&lt;mvc:default-servlet-handler/&gt;&lt;!-- 开启mvc注解驱动 --&gt;&lt;mvc:annotation-driven&gt; &lt;mvc:message-converters&gt; &lt;!-- 处理响应中文内容乱码 --&gt; &lt;bean class=&quot;org.springframework.http.converter.StringHttpMessageConverter&quot;&gt; &lt;property name=&quot;defaultCharset&quot; value=&quot;UTF-8&quot; /&gt; &lt;property name=&quot;supportedMediaTypes&quot;&gt; &lt;list&gt; &lt;value&gt;text/html&lt;/value&gt; &lt;value&gt;application/json&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; &lt;/mvc:message-converters&gt;&lt;/mvc:annotation-driven&gt; 6、测试HelloWorlda&gt;实现对首页的访问在请求控制器中创建处理请求的方法 12345678// @RequestMapping注解：处理请求和控制器方法之间的映射关系// @RequestMapping注解的value属性可以通过请求地址匹配请求，/表示的当前工程的上下文路径// localhost:8080/springMVC/@RequestMapping(&quot;/&quot;)public String index() &#123; //设置视图名称 return &quot;index&quot;;&#125; b&gt;通过超链接跳转到指定页面在主页index.html中设置超链接 1234567891011&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;首页&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;首页&lt;/h1&gt; &lt;a th:href=&quot;@&#123;/hello&#125;&quot;&gt;HelloWorld&lt;/a&gt;&lt;br/&gt;&lt;/body&gt;&lt;/html&gt; 在请求控制器中创建处理请求的方法 1234@RequestMapping(&quot;/hello&quot;)public String HelloWorld() &#123; return &quot;target&quot;;&#125; 7、总结浏览器发送请求，若请求地址符合前端控制器的url-pattern，该请求就会被前端控制器DispatcherServlet处理。前端控制器会读取SpringMVC的核心配置文件，通过扫描组件找到控制器，将请求地址和控制器中@RequestMapping注解的value属性值进行匹配，若匹配成功，该注解所标识的控制器方法就是处理请求的方法。处理请求的方法需要返回一个字符串类型的视图名称，该视图名称会被视图解析器解析，加上前缀和后缀组成视图的路径，通过Thymeleaf对视图进行渲染，最终转发到视图所对应页面 三、@RequestMapping注解1、@RequestMapping注解的功能从注解名称上我们可以看到，@RequestMapping注解的作用就是将请求和处理请求的控制器方法关联起来，建立映射关系。 SpringMVC 接收到指定的请求，就会来找到在映射关系中对应的控制器方法来处理这个请求。 2、@RequestMapping注解的位置@RequestMapping标识一个类：设置映射请求的请求路径的初始信息 @RequestMapping标识一个方法：设置映射请求请求路径的具体信息 1234567891011@Controller@RequestMapping(&quot;/test&quot;)public class RequestMappingController &#123; //此时请求映射所映射的请求的请求路径为：/test/testRequestMapping @RequestMapping(&quot;/testRequestMapping&quot;) public String testRequestMapping()&#123; return &quot;success&quot;; &#125;&#125; 3、@RequestMapping注解的value属性@RequestMapping注解的value属性通过请求的请求地址匹配请求映射 @RequestMapping注解的value属性是一个字符串类型的数组，表示该请求映射能够匹配多个请求地址所对应的请求 @RequestMapping注解的value属性必须设置，至少通过请求地址匹配请求映射 12&lt;a th:href=&quot;@&#123;/testRequestMapping&#125;&quot;&gt;测试@RequestMapping的value属性--&gt;/testRequestMapping&lt;/a&gt;&lt;br&gt;&lt;a th:href=&quot;@&#123;/test&#125;&quot;&gt;测试@RequestMapping的value属性--&gt;/test&lt;/a&gt;&lt;br&gt; 123456@RequestMapping( value = &#123;&quot;/testRequestMapping&quot;, &quot;/test&quot;&#125;)public String testRequestMapping()&#123; return &quot;success&quot;;&#125; 4、@RequestMapping注解的method属性@RequestMapping注解的method属性通过请求的请求方式（get或post）匹配请求映射 @RequestMapping注解的method属性是一个RequestMethod类型的数组，表示该请求映射能够匹配多种请求方式的请求 若当前请求的请求地址满足请求映射的value属性，但是请求方式不满足method属性，则浏览器报错405：Request method ‘POST’ not supported 1234&lt;a th:href=&quot;@&#123;/test&#125;&quot;&gt;测试@RequestMapping的value属性--&gt;/test&lt;/a&gt;&lt;br&gt;&lt;form th:action=&quot;@&#123;/test&#125;&quot; method=&quot;post&quot;&gt; &lt;input type=&quot;submit&quot;&gt;&lt;/form&gt; 1234567@RequestMapping( value = &#123;&quot;/testRequestMapping&quot;, &quot;/test&quot;&#125;, method = &#123;RequestMethod.GET, RequestMethod.POST&#125;)public String testRequestMapping()&#123; return &quot;success&quot;;&#125; 注： 1、对于处理指定请求方式的控制器方法，SpringMVC中提供了@RequestMapping的派生注解 处理get请求的映射–&gt;@GetMapping 处理post请求的映射–&gt;@PostMapping 处理put请求的映射–&gt;@PutMapping 处理delete请求的映射–&gt;@DeleteMapping 2、常用的请求方式有get，post，put，delete 但是目前浏览器只支持get和post，若在form表单提交时，为method设置了其他请求方式的字符串（put或delete），则按照默认的请求方式get处理 若要发送put和delete请求，则需要通过spring提供的过滤器HiddenHttpMethodFilter，在RESTful部分会讲到 5、@RequestMapping注解的params属性（了解）@RequestMapping注解的params属性通过请求的请求参数匹配请求映射 @RequestMapping注解的params属性是一个字符串类型的数组，可以通过四种表达式设置请求参数和请求映射的匹配关系 “param”：要求请求映射所匹配的请求必须携带param请求参数 “!param”：要求请求映射所匹配的请求必须不能携带param请求参数 “param=value”：要求请求映射所匹配的请求必须携带param请求参数且param=value “param!=value”：要求请求映射所匹配的请求必须携带param请求参数但是param!=value 1&lt;a th:href=&quot;@&#123;/test(username=&#x27;admin&#x27;,password=123456)&quot;&gt;测试@RequestMapping的params属性--&gt;/test&lt;/a&gt;&lt;br&gt; 12345678@RequestMapping( value = &#123;&quot;/testRequestMapping&quot;, &quot;/test&quot;&#125; ,method = &#123;RequestMethod.GET, RequestMethod.POST&#125; ,params = &#123;&quot;username&quot;,&quot;password!=123456&quot;&#125;)public String testRequestMapping()&#123; return &quot;success&quot;;&#125; 注： 若当前请求满足@RequestMapping注解的value和method属性，但是不满足params属性，此时页面回报错400：Parameter conditions “username, password!=123456” not met for actual request parameters: username={admin}, password={123456} 6、@RequestMapping注解的headers属性（了解）@RequestMapping注解的headers属性通过请求的请求头信息匹配请求映射 @RequestMapping注解的headers属性是一个字符串类型的数组，可以通过四种表达式设置请求头信息和请求映射的匹配关系 “header”：要求请求映射所匹配的请求必须携带header请求头信息 “!header”：要求请求映射所匹配的请求必须不能携带header请求头信息 “header=value”：要求请求映射所匹配的请求必须携带header请求头信息且header=value “header!=value”：要求请求映射所匹配的请求必须携带header请求头信息且header!=value 若当前请求满足@RequestMapping注解的value和method属性，但是不满足headers属性，此时页面显示404错误，即资源未找到 7、SpringMVC支持ant风格的路径？：表示任意的单个字符 *：表示任意的0个或多个字符 **：表示任意的一层或多层目录 注意：在使用**时，只能使用/**/xxx的方式 8、SpringMVC支持路径中的占位符（重点）原始方式：/deleteUser?id=1 rest方式：/deleteUser/1 SpringMVC路径中的占位符常用于RESTful风格中，当请求路径中将某些数据通过路径的方式传输到服务器中，就可以在相应的@RequestMapping注解的value属性中通过占位符{xxx}表示传输的数据，在通过@PathVariable注解，将占位符所表示的数据赋值给控制器方法的形参 1&lt;a th:href=&quot;@&#123;/testRest/1/admin&#125;&quot;&gt;测试路径中的占位符--&gt;/testRest&lt;/a&gt;&lt;br&gt; 123456@RequestMapping(&quot;/testRest/&#123;id&#125;/&#123;username&#125;&quot;)public String testRest(@PathVariable(&quot;id&quot;) String id, @PathVariable(&quot;username&quot;) String username)&#123; System.out.println(&quot;id:&quot;+id+&quot;,username:&quot;+username); return &quot;success&quot;;&#125;//最终输出的内容为--&gt;id:1,username:admin 四、SpringMVC获取请求参数1、通过ServletAPI获取将HttpServletRequest作为控制器方法的形参，此时HttpServletRequest类型的参数表示封装了当前请求的请求报文的对象 1234567@RequestMapping(&quot;/testParam&quot;)public String testParam(HttpServletRequest request)&#123; String username = request.getParameter(&quot;username&quot;); String password = request.getParameter(&quot;password&quot;); System.out.println(&quot;username:&quot;+username+&quot;,password:&quot;+password); return &quot;success&quot;;&#125; 2、通过控制器方法的形参获取请求参数在控制器方法的形参位置，设置和请求参数同名的形参，当浏览器发送请求，匹配到请求映射时，在DispatcherServlet中就会将请求参数赋值给相应的形参 1&lt;a th:href=&quot;@&#123;/testParam(username=&#x27;admin&#x27;,password=123456)&#125;&quot;&gt;测试获取请求参数--&gt;/testParam&lt;/a&gt;&lt;br&gt; 12345@RequestMapping(&quot;/testParam&quot;)public String testParam(String username, String password)&#123; System.out.println(&quot;username:&quot;+username+&quot;,password:&quot;+password); return &quot;success&quot;;&#125; 注： 若请求所传输的请求参数中有多个同名的请求参数，此时可以在控制器方法的形参中设置字符串数组或者字符串类型的形参接收此请求参数 若使用字符串数组类型的形参，此参数的数组中包含了每一个数据 若使用字符串类型的形参，此参数的值为每个数据中间使用逗号拼接的结果 3、@RequestParam@RequestParam是将请求参数和控制器方法的形参创建映射关系 @RequestParam注解一共有三个属性： value：指定为形参赋值的请求参数的参数名 required：设置是否必须传输此请求参数，默认值为true 若设置为true时，则当前请求必须传输value所指定的请求参数，若没有传输该请求参数，且没有设置defaultValue属性，则页面报错400：Required String parameter ‘xxx’ is not present；若设置为false，则当前请求不是必须传输value所指定的请求参数，若没有传输，则注解所标识的形参的值为null defaultValue：不管required属性值为true或false，当value所指定的请求参数没有传输或传输的值为””时，则使用默认值为形参赋值 4、@RequestHeader@RequestHeader是将请求头信息和控制器方法的形参创建映射关系 @RequestHeader注解一共有三个属性：value、required、defaultValue，用法同@RequestParam 5、@CookieValue@CookieValue是将cookie数据和控制器方法的形参创建映射关系 @CookieValue注解一共有三个属性：value、required、defaultValue，用法同@RequestParam 6、通过POJO获取请求参数可以在控制器方法的形参位置设置一个实体类类型的形参，此时若浏览器传输的请求参数的参数名和实体类中的属性名一致，那么请求参数就会为此属性赋值 12345678&lt;form th:action=&quot;@&#123;/testpojo&#125;&quot; method=&quot;post&quot;&gt; 用户名：&lt;input type=&quot;text&quot; name=&quot;username&quot;&gt;&lt;br&gt; 密码：&lt;input type=&quot;password&quot; name=&quot;password&quot;&gt;&lt;br&gt; 性别：&lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;男&quot;&gt;男&lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;女&quot;&gt;女&lt;br&gt; 年龄：&lt;input type=&quot;text&quot; name=&quot;age&quot;&gt;&lt;br&gt; 邮箱：&lt;input type=&quot;text&quot; name=&quot;email&quot;&gt;&lt;br&gt; &lt;input type=&quot;submit&quot;&gt;&lt;/form&gt; 123456@RequestMapping(&quot;/testpojo&quot;)public String testPOJO(User user)&#123; System.out.println(user); return &quot;success&quot;;&#125;//最终结果--&gt;User&#123;id=null, username=&#x27;张三&#x27;, password=&#x27;123&#x27;, age=23, sex=&#x27;男&#x27;, email=&#x27;123@qq.com&#x27;&#125; 7、解决获取请求参数的乱码问题解决获取请求参数的乱码问题，可以使用SpringMVC提供的编码过滤器CharacterEncodingFilter，但是必须在web.xml中进行注册 1234567891011121314151617&lt;!--配置springMVC的编码过滤器--&gt;&lt;filter&gt; &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;forceResponseEncoding&lt;/param-name&gt; &lt;param-value&gt;true&lt;/param-value&gt; &lt;/init-param&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; 注： SpringMVC中处理编码的过滤器一定要配置到其他过滤器之前，否则无效 五、域对象共享数据1、使用ServletAPI向request域对象共享数据12345@RequestMapping(&quot;/testServletAPI&quot;)public String testServletAPI(HttpServletRequest request)&#123; request.setAttribute(&quot;testScope&quot;, &quot;hello,servletAPI&quot;); return &quot;success&quot;;&#125; 2、使用ModelAndView向request域对象共享数据1234567891011121314@RequestMapping(&quot;/testModelAndView&quot;)public ModelAndView testModelAndView()&#123; /** * ModelAndView有Model和View的功能 * Model主要用于向请求域共享数据 * View主要用于设置视图，实现页面跳转 */ ModelAndView mav = new ModelAndView(); //向请求域共享数据 mav.addObject(&quot;testScope&quot;, &quot;hello,ModelAndView&quot;); //设置视图，实现页面跳转 mav.setViewName(&quot;success&quot;); return mav;&#125; 3、使用Model向request域对象共享数据12345@RequestMapping(&quot;/testModel&quot;)public String testModel(Model model)&#123; model.addAttribute(&quot;testScope&quot;, &quot;hello,Model&quot;); return &quot;success&quot;;&#125; 4、使用map向request域对象共享数据12345@RequestMapping(&quot;/testMap&quot;)public String testMap(Map&lt;String, Object&gt; map)&#123; map.put(&quot;testScope&quot;, &quot;hello,Map&quot;); return &quot;success&quot;;&#125; 5、使用ModelMap向request域对象共享数据12345@RequestMapping(&quot;/testModelMap&quot;)public String testModelMap(ModelMap modelMap)&#123; modelMap.addAttribute(&quot;testScope&quot;, &quot;hello,ModelMap&quot;); return &quot;success&quot;;&#125; 6、Model、ModelMap、Map的关系Model、ModelMap、Map类型的参数其实本质上都是 BindingAwareModelMap 类型的 1234public interface Model&#123;&#125;public class ModelMap extends LinkedHashMap&lt;String, Object&gt; &#123;&#125;public class ExtendedModelMap extends ModelMap implements Model &#123;&#125;public class BindingAwareModelMap extends ExtendedModelMap &#123;&#125; 7、向session域共享数据12345@RequestMapping(&quot;/testSession&quot;)public String testSession(HttpSession session)&#123; session.setAttribute(&quot;testSessionScope&quot;, &quot;hello,session&quot;); return &quot;success&quot;;&#125; 8、向application域共享数据123456@RequestMapping(&quot;/testApplication&quot;)public String testApplication(HttpSession session)&#123; ServletContext application = session.getServletContext(); application.setAttribute(&quot;testApplicationScope&quot;, &quot;hello,application&quot;); return &quot;success&quot;;&#125; 六、SpringMVC的视图SpringMVC中的视图是View接口，视图的作用渲染数据，将模型Model中的数据展示给用户 SpringMVC视图的种类很多，默认有转发视图和重定向视图 当工程引入jstl的依赖，转发视图会自动转换为JstlView 若使用的视图技术为Thymeleaf，在SpringMVC的配置文件中配置了Thymeleaf的视图解析器，由此视图解析器解析之后所得到的是ThymeleafView 1、ThymeleafView当控制器方法中所设置的视图名称没有任何前缀时，此时的视图名称会被SpringMVC配置文件中所配置的视图解析器解析，视图名称拼接视图前缀和视图后缀所得到的最终路径，会通过转发的方式实现跳转 1234@RequestMapping(&quot;/testHello&quot;)public String testHello()&#123; return &quot;hello&quot;;&#125; 2、转发视图SpringMVC中默认的转发视图是InternalResourceView SpringMVC中创建转发视图的情况： 当控制器方法中所设置的视图名称以”forward:”为前缀时，创建InternalResourceView视图，此时的视图名称不会被SpringMVC配置文件中所配置的视图解析器解析，而是会将前缀”forward:”去掉，剩余部分作为最终路径通过转发的方式实现跳转 例如”forward:/“，”forward:/employee” 1234@RequestMapping(&quot;/testForward&quot;)public String testForward()&#123; return &quot;forward:/testHello&quot;;&#125; 3、重定向视图SpringMVC中默认的重定向视图是RedirectView 当控制器方法中所设置的视图名称以”redirect:”为前缀时，创建RedirectView视图，此时的视图名称不会被SpringMVC配置文件中所配置的视图解析器解析，而是会将前缀”redirect:”去掉，剩余部分作为最终路径通过重定向的方式实现跳转 例如”redirect:/“，”redirect:/employee” 1234@RequestMapping(&quot;/testRedirect&quot;)public String testRedirect()&#123; return &quot;redirect:/testHello&quot;;&#125; 注： 重定向视图在解析时，会先将redirect:前缀去掉，然后会判断剩余部分是否以/开头，若是则会自动拼接上下文路径 4、视图控制器view-controller当控制器方法中，仅仅用来实现页面跳转，即只需要设置视图名称时，可以将处理器方法使用view-controller标签进行表示 12345&lt;!-- path：设置处理的请求地址 view-name：设置请求地址所对应的视图名称--&gt;&lt;mvc:view-controller path=&quot;/testView&quot; view-name=&quot;success&quot;&gt;&lt;/mvc:view-controller&gt; 注： 当SpringMVC中设置任何一个view-controller时，其他控制器中的请求映射将全部失效，此时需要在SpringMVC的核心配置文件中设置开启mvc注解驱动的标签： &lt;mvc:annotation-driven /&gt; 七、RESTful1、RESTful简介REST：Representational State Transfer，表现层资源状态转移。 a&gt;资源资源是一种看待服务器的方式，即，将服务器看作是由很多离散的资源组成。每个资源是服务器上一个可命名的抽象概念。因为资源是一个抽象的概念，所以它不仅仅能代表服务器文件系统中的一个文件、数据库中的一张表等等具体的东西，可以将资源设计的要多抽象有多抽象，只要想象力允许而且客户端应用开发者能够理解。与面向对象设计类似，资源是以名词为核心来组织的，首先关注的是名词。一个资源可以由一个或多个URI来标识。URI既是资源的名称，也是资源在Web上的地址。对某个资源感兴趣的客户端应用，可以通过资源的URI与其进行交互。 b&gt;资源的表述资源的表述是一段对于资源在某个特定时刻的状态的描述。可以在客户端-服务器端之间转移（交换）。资源的表述可以有多种格式，例如HTML/XML/JSON/纯文本/图片/视频/音频等等。资源的表述格式可以通过协商机制来确定。请求-响应方向的表述通常使用不同的格式。 c&gt;状态转移状态转移说的是：在客户端和服务器端之间转移（transfer）代表资源状态的表述。通过转移和操作资源的表述，来间接实现操作资源的目的。 2、RESTful的实现具体说，就是 HTTP 协议里面，四个表示操作方式的动词：GET、POST、PUT、DELETE。 它们分别对应四种基本操作：GET 用来获取资源，POST 用来新建资源，PUT 用来更新资源，DELETE 用来删除资源。 REST 风格提倡 URL 地址使用统一的风格设计，从前到后各个单词使用斜杠分开，不使用问号键值对方式携带请求参数，而是将要发送给服务器的数据作为 URL 地址的一部分，以保证整体风格的一致性。 操作 传统方式 REST风格 查询操作 getUserById?id=1 user/1–&gt;get请求方式 保存操作 saveUser user–&gt;post请求方式 删除操作 deleteUser?id=1 user/1–&gt;delete请求方式 更新操作 updateUser user–&gt;put请求方式 3、HiddenHttpMethodFilter由于浏览器只支持发送get和post方式的请求，那么该如何发送put和delete请求呢？ SpringMVC 提供了 HiddenHttpMethodFilter 帮助我们将 POST 请求转换为 DELETE 或 PUT 请求 HiddenHttpMethodFilter 处理put和delete请求的条件： a&gt;当前请求的请求方式必须为post b&gt;当前请求必须传输请求参数_method 满足以上条件，HiddenHttpMethodFilter 过滤器就会将当前请求的请求方式转换为请求参数_method的值，因此请求参数_method的值才是最终的请求方式 在web.xml中注册HiddenHttpMethodFilter 12345678&lt;filter&gt; &lt;filter-name&gt;HiddenHttpMethodFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.HiddenHttpMethodFilter&lt;/filter-class&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;HiddenHttpMethodFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; 注： 目前为止，SpringMVC中提供了两个过滤器：CharacterEncodingFilter和HiddenHttpMethodFilter 在web.xml中注册时，必须先注册CharacterEncodingFilter，再注册HiddenHttpMethodFilter 原因： 在 CharacterEncodingFilter 中通过 request.setCharacterEncoding(encoding) 方法设置字符集的 request.setCharacterEncoding(encoding) 方法要求前面不能有任何获取请求参数的操作 而 HiddenHttpMethodFilter 恰恰有一个获取请求方式的操作： 1String paramValue = request.getParameter(this.methodParam); 八、RESTful案例1、准备工作和传统 CRUD 一样，实现对员工信息的增删改查。 搭建环境 准备实体类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354package com.atguigu.mvc.bean;public class Employee &#123; private Integer id; private String lastName; private String email; //1 male, 0 female private Integer gender; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getLastName() &#123; return lastName; &#125; public void setLastName(String lastName) &#123; this.lastName = lastName; &#125; public String getEmail() &#123; return email; &#125; public void setEmail(String email) &#123; this.email = email; &#125; public Integer getGender() &#123; return gender; &#125; public void setGender(Integer gender) &#123; this.gender = gender; &#125; public Employee(Integer id, String lastName, String email, Integer gender) &#123; super(); this.id = id; this.lastName = lastName; this.email = email; this.gender = gender; &#125; public Employee() &#123; &#125;&#125; 准备dao模拟数据 12345678910111213141516171819202122232425262728293031323334353637383940414243444546package com.atguigu.mvc.dao;import java.util.Collection;import java.util.HashMap;import java.util.Map;import com.atguigu.mvc.bean.Employee;import org.springframework.stereotype.Repository;@Repositorypublic class EmployeeDao &#123; private static Map&lt;Integer, Employee&gt; employees = null; static&#123; employees = new HashMap&lt;Integer, Employee&gt;(); employees.put(1001, new Employee(1001, &quot;E-AA&quot;, &quot;aa@163.com&quot;, 1)); employees.put(1002, new Employee(1002, &quot;E-BB&quot;, &quot;bb@163.com&quot;, 1)); employees.put(1003, new Employee(1003, &quot;E-CC&quot;, &quot;cc@163.com&quot;, 0)); employees.put(1004, new Employee(1004, &quot;E-DD&quot;, &quot;dd@163.com&quot;, 0)); employees.put(1005, new Employee(1005, &quot;E-EE&quot;, &quot;ee@163.com&quot;, 1)); &#125; private static Integer initId = 1006; public void save(Employee employee)&#123; if(employee.getId() == null)&#123; employee.setId(initId++); &#125; employees.put(employee.getId(), employee); &#125; public Collection&lt;Employee&gt; getAll()&#123; return employees.values(); &#125; public Employee get(Integer id)&#123; return employees.get(id); &#125; public void delete(Integer id)&#123; employees.remove(id); &#125;&#125; 2、功能清单 功能 URL 地址 请求方式 访问首页√ / GET 查询全部数据√ /employee GET 删除√ /employee/2 DELETE 跳转到添加数据页面√ /toAdd GET 执行保存√ /employee POST 跳转到更新数据页面√ /employee/2 GET 执行更新√ /employee PUT 3、具体功能：访问首页a&gt;配置view-controller1&lt;mvc:view-controller path=&quot;/&quot; view-name=&quot;index&quot;/&gt; b&gt;创建页面1234567891011&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; &gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;首页&lt;/h1&gt;&lt;a th:href=&quot;@&#123;/employee&#125;&quot;&gt;访问员工信息&lt;/a&gt;&lt;/body&gt;&lt;/html&gt; 4、具体功能：查询所有员工数据a&gt;控制器方法123456@RequestMapping(value = &quot;/employee&quot;, method = RequestMethod.GET)public String getEmployeeList(Model model)&#123; Collection&lt;Employee&gt; employeeList = employeeDao.getAll(); model.addAttribute(&quot;employeeList&quot;, employeeList); return &quot;employee_list&quot;;&#125; b&gt;创建employee_list.html123456789101112131415161718192021222324252627282930313233&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Employee Info&lt;/title&gt; &lt;script type=&quot;text/javascript&quot; th:src=&quot;@&#123;/static/js/vue.js&#125;&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;table border=&quot;1&quot; cellpadding=&quot;0&quot; cellspacing=&quot;0&quot; style=&quot;text-align: center;&quot; id=&quot;dataTable&quot;&gt; &lt;tr&gt; &lt;th colspan=&quot;5&quot;&gt;Employee Info&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;th&gt;id&lt;/th&gt; &lt;th&gt;lastName&lt;/th&gt; &lt;th&gt;email&lt;/th&gt; &lt;th&gt;gender&lt;/th&gt; &lt;th&gt;options(&lt;a th:href=&quot;@&#123;/toAdd&#125;&quot;&gt;add&lt;/a&gt;)&lt;/th&gt; &lt;/tr&gt; &lt;tr th:each=&quot;employee : $&#123;employeeList&#125;&quot;&gt; &lt;td th:text=&quot;$&#123;employee.id&#125;&quot;&gt;&lt;/td&gt; &lt;td th:text=&quot;$&#123;employee.lastName&#125;&quot;&gt;&lt;/td&gt; &lt;td th:text=&quot;$&#123;employee.email&#125;&quot;&gt;&lt;/td&gt; &lt;td th:text=&quot;$&#123;employee.gender&#125;&quot;&gt;&lt;/td&gt; &lt;td&gt; &lt;a class=&quot;deleteA&quot; @click=&quot;deleteEmployee&quot; th:href=&quot;@&#123;&#x27;/employee/&#x27;+$&#123;employee.id&#125;&#125;&quot;&gt;delete&lt;/a&gt; &lt;a th:href=&quot;@&#123;&#x27;/employee/&#x27;+$&#123;employee.id&#125;&#125;&quot;&gt;update&lt;/a&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt;&lt;/body&gt;&lt;/html&gt; 5、具体功能：删除a&gt;创建处理delete请求方式的表单12345&lt;!-- 作用：通过超链接控制表单的提交，将post请求转换为delete请求 --&gt;&lt;form id=&quot;delete_form&quot; method=&quot;post&quot;&gt; &lt;!-- HiddenHttpMethodFilter要求：必须传输_method请求参数，并且值为最终的请求方式 --&gt; &lt;input type=&quot;hidden&quot; name=&quot;_method&quot; value=&quot;delete&quot;/&gt;&lt;/form&gt; b&gt;删除超链接绑定点击事件引入vue.js 1&lt;script type=&quot;text/javascript&quot; th:src=&quot;@&#123;/static/js/vue.js&#125;&quot;&gt;&lt;/script&gt; 删除超链接 1&lt;a class=&quot;deleteA&quot; @click=&quot;deleteEmployee&quot; th:href=&quot;@&#123;&#x27;/employee/&#x27;+$&#123;employee.id&#125;&#125;&quot;&gt;delete&lt;/a&gt; 通过vue处理点击事件 123456789101112131415161718&lt;script type=&quot;text/javascript&quot;&gt; var vue = new Vue(&#123; el:&quot;#dataTable&quot;, methods:&#123; //event表示当前事件 deleteEmployee:function (event) &#123; //通过id获取表单标签 var delete_form = document.getElementById(&quot;delete_form&quot;); //将触发事件的超链接的href属性为表单的action属性赋值 delete_form.action = event.target.href; //提交表单 delete_form.submit(); //阻止超链接的默认跳转行为 event.preventDefault(); &#125; &#125; &#125;);&lt;/script&gt; c&gt;控制器方法12345@RequestMapping(value = &quot;/employee/&#123;id&#125;&quot;, method = RequestMethod.DELETE)public String deleteEmployee(@PathVariable(&quot;id&quot;) Integer id)&#123; employeeDao.delete(id); return &quot;redirect:/employee&quot;;&#125; 6、具体功能：跳转到添加数据页面a&gt;配置view-controller1&lt;mvc:view-controller path=&quot;/toAdd&quot; view-name=&quot;employee_add&quot;&gt;&lt;/mvc:view-controller&gt; b&gt;创建employee_add.html123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Add Employee&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form th:action=&quot;@&#123;/employee&#125;&quot; method=&quot;post&quot;&gt; lastName:&lt;input type=&quot;text&quot; name=&quot;lastName&quot;&gt;&lt;br&gt; email:&lt;input type=&quot;text&quot; name=&quot;email&quot;&gt;&lt;br&gt; gender:&lt;input type=&quot;radio&quot; name=&quot;gender&quot; value=&quot;1&quot;&gt;male &lt;input type=&quot;radio&quot; name=&quot;gender&quot; value=&quot;0&quot;&gt;female&lt;br&gt; &lt;input type=&quot;submit&quot; value=&quot;add&quot;&gt;&lt;br&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 7、具体功能：执行保存a&gt;控制器方法12345@RequestMapping(value = &quot;/employee&quot;, method = RequestMethod.POST)public String addEmployee(Employee employee)&#123; employeeDao.save(employee); return &quot;redirect:/employee&quot;;&#125; 8、具体功能：跳转到更新数据页面a&gt;修改超链接1&lt;a th:href=&quot;@&#123;&#x27;/employee/&#x27;+$&#123;employee.id&#125;&#125;&quot;&gt;update&lt;/a&gt; b&gt;控制器方法123456@RequestMapping(value = &quot;/employee/&#123;id&#125;&quot;, method = RequestMethod.GET)public String getEmployeeById(@PathVariable(&quot;id&quot;) Integer id, Model model)&#123; Employee employee = employeeDao.get(id); model.addAttribute(&quot;employee&quot;, employee); return &quot;employee_update&quot;;&#125; c&gt;创建employee_update.html123456789101112131415161718192021222324&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Update Employee&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form th:action=&quot;@&#123;/employee&#125;&quot; method=&quot;post&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;_method&quot; value=&quot;put&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;id&quot; th:value=&quot;$&#123;employee.id&#125;&quot;&gt; lastName:&lt;input type=&quot;text&quot; name=&quot;lastName&quot; th:value=&quot;$&#123;employee.lastName&#125;&quot;&gt;&lt;br&gt; email:&lt;input type=&quot;text&quot; name=&quot;email&quot; th:value=&quot;$&#123;employee.email&#125;&quot;&gt;&lt;br&gt; &lt;!-- th:field=&quot;$&#123;employee.gender&#125;&quot;可用于单选框或复选框的回显 若单选框的value和employee.gender的值一致，则添加checked=&quot;checked&quot;属性 --&gt; gender:&lt;input type=&quot;radio&quot; name=&quot;gender&quot; value=&quot;1&quot; th:field=&quot;$&#123;employee.gender&#125;&quot;&gt;male &lt;input type=&quot;radio&quot; name=&quot;gender&quot; value=&quot;0&quot; th:field=&quot;$&#123;employee.gender&#125;&quot;&gt;female&lt;br&gt; &lt;input type=&quot;submit&quot; value=&quot;update&quot;&gt;&lt;br&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 9、具体功能：执行更新a&gt;控制器方法12345@RequestMapping(value = &quot;/employee&quot;, method = RequestMethod.PUT)public String updateEmployee(Employee employee)&#123; employeeDao.save(employee); return &quot;redirect:/employee&quot;;&#125; 八、HttpMessageConverterHttpMessageConverter，报文信息转换器，将请求报文转换为Java对象，或将Java对象转换为响应报文 HttpMessageConverter提供了两个注解和两个类型：@RequestBody，@ResponseBody，RequestEntity， ResponseEntity 1、@RequestBody@RequestBody可以获取请求体，需要在控制器方法设置一个形参，使用@RequestBody进行标识，当前请求的请求体就会为当前注解所标识的形参赋值 12345&lt;form th:action=&quot;@&#123;/testRequestBody&#125;&quot; method=&quot;post&quot;&gt; 用户名：&lt;input type=&quot;text&quot; name=&quot;username&quot;&gt;&lt;br&gt; 密码：&lt;input type=&quot;password&quot; name=&quot;password&quot;&gt;&lt;br&gt; &lt;input type=&quot;submit&quot;&gt;&lt;/form&gt; 12345@RequestMapping(&quot;/testRequestBody&quot;)public String testRequestBody(@RequestBody String requestBody)&#123; System.out.println(&quot;requestBody:&quot;+requestBody); return &quot;success&quot;;&#125; 输出结果： requestBody:username=admin&amp;password=123456 2、RequestEntityRequestEntity封装请求报文的一种类型，需要在控制器方法的形参中设置该类型的形参，当前请求的请求报文就会赋值给该形参，可以通过getHeaders()获取请求头信息，通过getBody()获取请求体信息 123456@RequestMapping(&quot;/testRequestEntity&quot;)public String testRequestEntity(RequestEntity&lt;String&gt; requestEntity)&#123; System.out.println(&quot;requestHeader:&quot;+requestEntity.getHeaders()); System.out.println(&quot;requestBody:&quot;+requestEntity.getBody()); return &quot;success&quot;;&#125; 输出结果：requestHeader:[host:”localhost:8080”, connection:”keep-alive”, content-length:”27”, cache-control:”max-age=0”, sec-ch-ua:”” Not A;Brand”;v=”99”, “Chromium”;v=”90”, “Google Chrome”;v=”90””, sec-ch-ua-mobile:”?0”, upgrade-insecure-requests:”1”, origin:”http://localhost:8080&quot;, user-agent:”Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/90.0.4430.93 Safari/537.36”]requestBody:username=admin&amp;password=123 3、@ResponseBody@ResponseBody用于标识一个控制器方法，可以将该方法的返回值直接作为响应报文的响应体响应到浏览器 12345@RequestMapping(&quot;/testResponseBody&quot;)@ResponseBodypublic String testResponseBody()&#123; return &quot;success&quot;;&#125; 结果：浏览器页面显示success 4、SpringMVC处理json@ResponseBody处理json的步骤： a&gt;导入jackson的依赖 12345&lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.12.1&lt;/version&gt;&lt;/dependency&gt; b&gt;在SpringMVC的核心配置文件中开启mvc的注解驱动，此时在HandlerAdaptor中会自动装配一个消息转换器：MappingJackson2HttpMessageConverter，可以将响应到浏览器的Java对象转换为Json格式的字符串 1&lt;mvc:annotation-driven /&gt; c&gt;在处理器方法上使用@ResponseBody注解进行标识 d&gt;将Java对象直接作为控制器方法的返回值返回，就会自动转换为Json格式的字符串 12345@RequestMapping(&quot;/testResponseUser&quot;)@ResponseBodypublic User testResponseUser()&#123; return new User(1001,&quot;admin&quot;,&quot;123456&quot;,23,&quot;男&quot;);&#125; 浏览器的页面中展示的结果： {“id”:1001,”username”:”admin”,”password”:”123456”,”age”:23,”sex”:”男”} 5、SpringMVC处理ajaxa&gt;请求超链接： 123&lt;div id=&quot;app&quot;&gt; &lt;a th:href=&quot;@&#123;/testAjax&#125;&quot; @click=&quot;testAjax&quot;&gt;testAjax&lt;/a&gt;&lt;br&gt;&lt;/div&gt; b&gt;通过vue和axios处理点击事件： 12345678910111213141516171819202122&lt;script type=&quot;text/javascript&quot; th:src=&quot;@&#123;/static/js/vue.js&#125;&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot; th:src=&quot;@&#123;/static/js/axios.min.js&#125;&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot;&gt; var vue = new Vue(&#123; el:&quot;#app&quot;, methods:&#123; testAjax:function (event) &#123; axios(&#123; method:&quot;post&quot;, url:event.target.href, params:&#123; username:&quot;admin&quot;, password:&quot;123456&quot; &#125; &#125;).then(function (response) &#123; alert(response.data); &#125;); event.preventDefault(); &#125; &#125; &#125;);&lt;/script&gt; c&gt;控制器方法： 123456@RequestMapping(&quot;/testAjax&quot;)@ResponseBodypublic String testAjax(String username, String password)&#123; System.out.println(&quot;username:&quot;+username+&quot;,password:&quot;+password); return &quot;hello,ajax&quot;;&#125; 6、@RestController注解@RestController注解是springMVC提供的一个复合注解，标识在控制器的类上，就相当于为类添加了@Controller注解，并且为其中的每个方法添加了@ResponseBody注解 7、ResponseEntityResponseEntity用于控制器方法的返回值类型，该控制器方法的返回值就是响应到浏览器的响应报文 九、文件上传和下载1、文件下载使用ResponseEntity实现下载文件的功能 123456789101112131415161718192021222324@RequestMapping(&quot;/testDown&quot;)public ResponseEntity&lt;byte[]&gt; testResponseEntity(HttpSession session) throws IOException &#123; //获取ServletContext对象 ServletContext servletContext = session.getServletContext(); //获取服务器中文件的真实路径 String realPath = servletContext.getRealPath(&quot;/static/img/1.jpg&quot;); //创建输入流 InputStream is = new FileInputStream(realPath); //创建字节数组 byte[] bytes = new byte[is.available()]; //将流读到字节数组中 is.read(bytes); //创建HttpHeaders对象设置响应头信息 MultiValueMap&lt;String, String&gt; headers = new HttpHeaders(); //设置要下载方式以及下载文件的名字 headers.add(&quot;Content-Disposition&quot;, &quot;attachment;filename=1.jpg&quot;); //设置响应状态码 HttpStatus statusCode = HttpStatus.OK; //创建ResponseEntity对象 ResponseEntity&lt;byte[]&gt; responseEntity = new ResponseEntity&lt;&gt;(bytes, headers, statusCode); //关闭输入流 is.close(); return responseEntity;&#125; 2、文件上传文件上传要求form表单的请求方式必须为post，并且添加属性enctype=”multipart/form-data” SpringMVC中将上传的文件封装到MultipartFile对象中，通过此对象可以获取文件相关信息 上传步骤： a&gt;添加依赖： 123456&lt;!-- https://mvnrepository.com/artifact/commons-fileupload/commons-fileupload --&gt;&lt;dependency&gt; &lt;groupId&gt;commons-fileupload&lt;/groupId&gt; &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt; &lt;version&gt;1.3.1&lt;/version&gt;&lt;/dependency&gt; b&gt;在SpringMVC的配置文件中添加配置： 12&lt;!--必须通过文件解析器的解析才能将文件转换为MultipartFile对象--&gt;&lt;bean id=&quot;multipartResolver&quot; class=&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;&gt;&lt;/bean&gt; c&gt;控制器方法： 12345678910111213141516171819@RequestMapping(&quot;/testUp&quot;)public String testUp(MultipartFile photo, HttpSession session) throws IOException &#123; //获取上传的文件的文件名 String fileName = photo.getOriginalFilename(); //处理文件重名问题 String hzName = fileName.substring(fileName.lastIndexOf(&quot;.&quot;)); fileName = UUID.randomUUID().toString() + hzName; //获取服务器中photo目录的路径 ServletContext servletContext = session.getServletContext(); String photoPath = servletContext.getRealPath(&quot;photo&quot;); File file = new File(photoPath); if(!file.exists())&#123; file.mkdir(); &#125; String finalPath = photoPath + File.separator + fileName; //实现上传功能 photo.transferTo(new File(finalPath)); return &quot;success&quot;;&#125; 十、拦截器1、拦截器的配置SpringMVC中的拦截器用于拦截控制器方法的执行 SpringMVC中的拦截器需要实现HandlerInterceptor SpringMVC的拦截器必须在SpringMVC的配置文件中进行配置： 1234567891011&lt;bean class=&quot;com.atguigu.interceptor.FirstInterceptor&quot;&gt;&lt;/bean&gt;&lt;ref bean=&quot;firstInterceptor&quot;&gt;&lt;/ref&gt;&lt;!-- 以上两种配置方式都是对DispatcherServlet所处理的所有的请求进行拦截 --&gt;&lt;mvc:interceptor&gt; &lt;mvc:mapping path=&quot;/**&quot;/&gt; &lt;mvc:exclude-mapping path=&quot;/testRequestEntity&quot;/&gt; &lt;ref bean=&quot;firstInterceptor&quot;&gt;&lt;/ref&gt;&lt;/mvc:interceptor&gt;&lt;!-- 以上配置方式可以通过ref或bean标签设置拦截器，通过mvc:mapping设置需要拦截的请求，通过mvc:exclude-mapping设置需要排除的请求，即不需要拦截的请求--&gt; 2、拦截器的三个抽象方法SpringMVC中的拦截器有三个抽象方法： preHandle：控制器方法执行之前执行preHandle()，其boolean类型的返回值表示是否拦截或放行，返回true为放行，即调用控制器方法；返回false表示拦截，即不调用控制器方法 postHandle：控制器方法执行之后执行postHandle() afterComplation：处理完视图和模型数据，渲染视图完毕之后执行afterComplation() 3、多个拦截器的执行顺序a&gt;若每个拦截器的preHandle()都返回true 此时多个拦截器的执行顺序和拦截器在SpringMVC的配置文件的配置顺序有关： preHandle()会按照配置的顺序执行，而postHandle()和afterComplation()会按照配置的反序执行 b&gt;若某个拦截器的preHandle()返回了false preHandle()返回false和它之前的拦截器的preHandle()都会执行，postHandle()都不执行，返回false的拦截器之前的拦截器的afterComplation()会执行 十一、异常处理器1、基于配置的异常处理SpringMVC提供了一个处理控制器方法执行过程中所出现的异常的接口：HandlerExceptionResolver HandlerExceptionResolver接口的实现类有：DefaultHandlerExceptionResolver和SimpleMappingExceptionResolver SpringMVC提供了自定义的异常处理器SimpleMappingExceptionResolver，使用方式： 123456789101112131415&lt;bean class=&quot;org.springframework.web.servlet.handler.SimpleMappingExceptionResolver&quot;&gt; &lt;property name=&quot;exceptionMappings&quot;&gt; &lt;props&gt; &lt;!-- properties的键表示处理器方法执行过程中出现的异常 properties的值表示若出现指定异常时，设置一个新的视图名称，跳转到指定页面 --&gt; &lt;prop key=&quot;java.lang.ArithmeticException&quot;&gt;error&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt; &lt;!-- exceptionAttribute属性设置一个属性名，将出现的异常信息在请求域中进行共享 --&gt; &lt;property name=&quot;exceptionAttribute&quot; value=&quot;ex&quot;&gt;&lt;/property&gt;&lt;/bean&gt; 2、基于注解的异常处理12345678910111213//@ControllerAdvice将当前类标识为异常处理的组件@ControllerAdvicepublic class ExceptionController &#123; //@ExceptionHandler用于设置所标识方法处理的异常 @ExceptionHandler(ArithmeticException.class) //ex表示当前请求处理中出现的异常对象 public String handleArithmeticException(Exception ex, Model model)&#123; model.addAttribute(&quot;ex&quot;, ex); return &quot;error&quot;; &#125;&#125; 十二、注解配置SpringMVC使用配置类和注解代替web.xml和SpringMVC配置文件的功能 1、创建初始化类，代替web.xml在Servlet3.0环境中，容器会在类路径中查找实现javax.servlet.ServletContainerInitializer接口的类，如果找到的话就用它来配置Servlet容器。Spring提供了这个接口的实现，名为SpringServletContainerInitializer，这个类反过来又会查找实现WebApplicationInitializer的类并将配置的任务交给它们来完成。Spring3.2引入了一个便利的WebApplicationInitializer基础实现，名为AbstractAnnotationConfigDispatcherServletInitializer，当我们的类扩展了AbstractAnnotationConfigDispatcherServletInitializer并将其部署到Servlet3.0容器的时候，容器会自动发现它，并用它来配置Servlet上下文。 123456789101112131415161718192021222324252627282930313233343536373839404142public class WebInit extends AbstractAnnotationConfigDispatcherServletInitializer &#123; /** * 指定spring的配置类 * @return */ @Override protected Class&lt;?&gt;[] getRootConfigClasses() &#123; return new Class[]&#123;SpringConfig.class&#125;; &#125; /** * 指定SpringMVC的配置类 * @return */ @Override protected Class&lt;?&gt;[] getServletConfigClasses() &#123; return new Class[]&#123;WebConfig.class&#125;; &#125; /** * 指定DispatcherServlet的映射规则，即url-pattern * @return */ @Override protected String[] getServletMappings() &#123; return new String[]&#123;&quot;/&quot;&#125;; &#125; /** * 添加过滤器 * @return */ @Override protected Filter[] getServletFilters() &#123; CharacterEncodingFilter encodingFilter = new CharacterEncodingFilter(); encodingFilter.setEncoding(&quot;UTF-8&quot;); encodingFilter.setForceRequestEncoding(true); HiddenHttpMethodFilter hiddenHttpMethodFilter = new HiddenHttpMethodFilter(); return new Filter[]&#123;encodingFilter, hiddenHttpMethodFilter&#125;; &#125;&#125; 2、创建SpringConfig配置类，代替spring的配置文件1234@Configurationpublic class SpringConfig &#123; //ssm整合之后，spring的配置信息写在此类中&#125; 3、创建WebConfig配置类，代替SpringMVC的配置文件12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879@Configuration//扫描组件@ComponentScan(&quot;com.atguigu.mvc.controller&quot;)//开启MVC注解驱动@EnableWebMvcpublic class WebConfig implements WebMvcConfigurer &#123; //使用默认的servlet处理静态资源 @Override public void configureDefaultServletHandling(DefaultServletHandlerConfigurer configurer) &#123; configurer.enable(); &#125; //配置文件上传解析器 @Bean public CommonsMultipartResolver multipartResolver()&#123; return new CommonsMultipartResolver(); &#125; //配置拦截器 @Override public void addInterceptors(InterceptorRegistry registry) &#123; FirstInterceptor firstInterceptor = new FirstInterceptor(); registry.addInterceptor(firstInterceptor).addPathPatterns(&quot;/**&quot;); &#125; //配置视图控制 /*@Override public void addViewControllers(ViewControllerRegistry registry) &#123; registry.addViewController(&quot;/&quot;).setViewName(&quot;index&quot;); &#125;*/ //配置异常映射 /*@Override public void configureHandlerExceptionResolvers(List&lt;HandlerExceptionResolver&gt; resolvers) &#123; SimpleMappingExceptionResolver exceptionResolver = new SimpleMappingExceptionResolver(); Properties prop = new Properties(); prop.setProperty(&quot;java.lang.ArithmeticException&quot;, &quot;error&quot;); //设置异常映射 exceptionResolver.setExceptionMappings(prop); //设置共享异常信息的键 exceptionResolver.setExceptionAttribute(&quot;ex&quot;); resolvers.add(exceptionResolver); &#125;*/ //配置生成模板解析器 @Bean public ITemplateResolver templateResolver() &#123; WebApplicationContext webApplicationContext = ContextLoader.getCurrentWebApplicationContext(); // ServletContextTemplateResolver需要一个ServletContext作为构造参数，可通过WebApplicationContext 的方法获得 ServletContextTemplateResolver templateResolver = new ServletContextTemplateResolver( webApplicationContext.getServletContext()); templateResolver.setPrefix(&quot;/WEB-INF/templates/&quot;); templateResolver.setSuffix(&quot;.html&quot;); templateResolver.setCharacterEncoding(&quot;UTF-8&quot;); templateResolver.setTemplateMode(TemplateMode.HTML); return templateResolver; &#125; //生成模板引擎并为模板引擎注入模板解析器 @Bean public SpringTemplateEngine templateEngine(ITemplateResolver templateResolver) &#123; SpringTemplateEngine templateEngine = new SpringTemplateEngine(); templateEngine.setTemplateResolver(templateResolver); return templateEngine; &#125; //生成视图解析器并未解析器注入模板引擎 @Bean public ViewResolver viewResolver(SpringTemplateEngine templateEngine) &#123; ThymeleafViewResolver viewResolver = new ThymeleafViewResolver(); viewResolver.setCharacterEncoding(&quot;UTF-8&quot;); viewResolver.setTemplateEngine(templateEngine); return viewResolver; &#125;&#125; 4、测试功能1234@RequestMapping(&quot;/&quot;)public String index()&#123; return &quot;index&quot;;&#125; 十三、SpringMVC执行流程1、SpringMVC常用组件 DispatcherServlet：前端控制器，不需要工程师开发，由框架提供 作用：统一处理请求和响应，整个流程控制的中心，由它调用其它组件处理用户的请求 HandlerMapping：处理器映射器，不需要工程师开发，由框架提供 作用：根据请求的url、method等信息查找Handler，即控制器方法 Handler：处理器，需要工程师开发 作用：在DispatcherServlet的控制下Handler对具体的用户请求进行处理 HandlerAdapter：处理器适配器，不需要工程师开发，由框架提供 作用：通过HandlerAdapter对处理器（控制器方法）进行执行 ViewResolver：视图解析器，不需要工程师开发，由框架提供 作用：进行视图解析，得到相应的视图，例如：ThymeleafView、InternalResourceView、RedirectView View：视图 作用：将模型数据通过页面展示给用户 2、DispatcherServlet初始化过程DispatcherServlet 本质上是一个 Servlet，所以天然的遵循 Servlet 的生命周期。所以宏观上是 Servlet 生命周期来进行调度。 a&gt;初始化WebApplicationContext所在类：org.springframework.web.servlet.FrameworkServlet 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354protected WebApplicationContext initWebApplicationContext() &#123; WebApplicationContext rootContext = WebApplicationContextUtils.getWebApplicationContext(getServletContext()); WebApplicationContext wac = null; if (this.webApplicationContext != null) &#123; // A context instance was injected at construction time -&gt; use it wac = this.webApplicationContext; if (wac instanceof ConfigurableWebApplicationContext) &#123; ConfigurableWebApplicationContext cwac = (ConfigurableWebApplicationContext) wac; if (!cwac.isActive()) &#123; // The context has not yet been refreshed -&gt; provide services such as // setting the parent context, setting the application context id, etc if (cwac.getParent() == null) &#123; // The context instance was injected without an explicit parent -&gt; set // the root application context (if any; may be null) as the parent cwac.setParent(rootContext); &#125; configureAndRefreshWebApplicationContext(cwac); &#125; &#125; &#125; if (wac == null) &#123; // No context instance was injected at construction time -&gt; see if one // has been registered in the servlet context. If one exists, it is assumed // that the parent context (if any) has already been set and that the // user has performed any initialization such as setting the context id wac = findWebApplicationContext(); &#125; if (wac == null) &#123; // No context instance is defined for this servlet -&gt; create a local one // 创建WebApplicationContext wac = createWebApplicationContext(rootContext); &#125; if (!this.refreshEventReceived) &#123; // Either the context is not a ConfigurableApplicationContext with refresh // support or the context injected at construction time had already been // refreshed -&gt; trigger initial onRefresh manually here. synchronized (this.onRefreshMonitor) &#123; // 刷新WebApplicationContext onRefresh(wac); &#125; &#125; if (this.publishContext) &#123; // Publish the context as a servlet context attribute. // 将IOC容器在应用域共享 String attrName = getServletContextAttributeName(); getServletContext().setAttribute(attrName, wac); &#125; return wac;&#125; b&gt;创建WebApplicationContext所在类：org.springframework.web.servlet.FrameworkServlet 1234567891011121314151617181920212223protected WebApplicationContext createWebApplicationContext(@Nullable ApplicationContext parent) &#123; Class&lt;?&gt; contextClass = getContextClass(); if (!ConfigurableWebApplicationContext.class.isAssignableFrom(contextClass)) &#123; throw new ApplicationContextException( &quot;Fatal initialization error in servlet with name &#x27;&quot; + getServletName() + &quot;&#x27;: custom WebApplicationContext class [&quot; + contextClass.getName() + &quot;] is not of type ConfigurableWebApplicationContext&quot;); &#125; // 通过反射创建 IOC 容器对象 ConfigurableWebApplicationContext wac = (ConfigurableWebApplicationContext) BeanUtils.instantiateClass(contextClass); wac.setEnvironment(getEnvironment()); // 设置父容器 wac.setParent(parent); String configLocation = getContextConfigLocation(); if (configLocation != null) &#123; wac.setConfigLocation(configLocation); &#125; configureAndRefreshWebApplicationContext(wac); return wac;&#125; c&gt;DispatcherServlet初始化策略FrameworkServlet创建WebApplicationContext后，刷新容器，调用onRefresh(wac)，此方法在DispatcherServlet中进行了重写，调用了initStrategies(context)方法，初始化策略，即初始化DispatcherServlet的各个组件 所在类：org.springframework.web.servlet.DispatcherServlet 1234567891011protected void initStrategies(ApplicationContext context) &#123; initMultipartResolver(context); initLocaleResolver(context); initThemeResolver(context); initHandlerMappings(context); initHandlerAdapters(context); initHandlerExceptionResolvers(context); initRequestToViewNameTranslator(context); initViewResolvers(context); initFlashMapManager(context);&#125; 3、DispatcherServlet调用组件处理请求a&gt;processRequest()FrameworkServlet重写HttpServlet中的service()和doXxx()，这些方法中调用了processRequest(request, response) 所在类：org.springframework.web.servlet.FrameworkServlet 123456789101112131415161718192021222324252627282930313233343536373839protected final void processRequest(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; long startTime = System.currentTimeMillis(); Throwable failureCause = null; LocaleContext previousLocaleContext = LocaleContextHolder.getLocaleContext(); LocaleContext localeContext = buildLocaleContext(request); RequestAttributes previousAttributes = RequestContextHolder.getRequestAttributes(); ServletRequestAttributes requestAttributes = buildRequestAttributes(request, response, previousAttributes); WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request); asyncManager.registerCallableInterceptor(FrameworkServlet.class.getName(), new RequestBindingInterceptor()); initContextHolders(request, localeContext, requestAttributes); try &#123; // 执行服务，doService()是一个抽象方法，在DispatcherServlet中进行了重写 doService(request, response); &#125; catch (ServletException | IOException ex) &#123; failureCause = ex; throw ex; &#125; catch (Throwable ex) &#123; failureCause = ex; throw new NestedServletException(&quot;Request processing failed&quot;, ex); &#125; finally &#123; resetContextHolders(request, previousLocaleContext, previousAttributes); if (requestAttributes != null) &#123; requestAttributes.requestCompleted(); &#125; logResult(request, response, failureCause, asyncManager); publishRequestHandledEvent(request, response, startTime, failureCause); &#125;&#125; b&gt;doService()所在类：org.springframework.web.servlet.DispatcherServlet 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354@Overrideprotected void doService(HttpServletRequest request, HttpServletResponse response) throws Exception &#123; logRequest(request); // Keep a snapshot of the request attributes in case of an include, // to be able to restore the original attributes after the include. Map&lt;String, Object&gt; attributesSnapshot = null; if (WebUtils.isIncludeRequest(request)) &#123; attributesSnapshot = new HashMap&lt;&gt;(); Enumeration&lt;?&gt; attrNames = request.getAttributeNames(); while (attrNames.hasMoreElements()) &#123; String attrName = (String) attrNames.nextElement(); if (this.cleanupAfterInclude || attrName.startsWith(DEFAULT_STRATEGIES_PREFIX)) &#123; attributesSnapshot.put(attrName, request.getAttribute(attrName)); &#125; &#125; &#125; // Make framework objects available to handlers and view objects. request.setAttribute(WEB_APPLICATION_CONTEXT_ATTRIBUTE, getWebApplicationContext()); request.setAttribute(LOCALE_RESOLVER_ATTRIBUTE, this.localeResolver); request.setAttribute(THEME_RESOLVER_ATTRIBUTE, this.themeResolver); request.setAttribute(THEME_SOURCE_ATTRIBUTE, getThemeSource()); if (this.flashMapManager != null) &#123; FlashMap inputFlashMap = this.flashMapManager.retrieveAndUpdate(request, response); if (inputFlashMap != null) &#123; request.setAttribute(INPUT_FLASH_MAP_ATTRIBUTE, Collections.unmodifiableMap(inputFlashMap)); &#125; request.setAttribute(OUTPUT_FLASH_MAP_ATTRIBUTE, new FlashMap()); request.setAttribute(FLASH_MAP_MANAGER_ATTRIBUTE, this.flashMapManager); &#125; RequestPath requestPath = null; if (this.parseRequestPath &amp;&amp; !ServletRequestPathUtils.hasParsedRequestPath(request)) &#123; requestPath = ServletRequestPathUtils.parseAndCache(request); &#125; try &#123; // 处理请求和响应 doDispatch(request, response); &#125; finally &#123; if (!WebAsyncUtils.getAsyncManager(request).isConcurrentHandlingStarted()) &#123; // Restore the original attribute snapshot, in case of an include. if (attributesSnapshot != null) &#123; restoreAttributesAfterInclude(request, attributesSnapshot); &#125; &#125; if (requestPath != null) &#123; ServletRequestPathUtils.clearParsedRequestPath(request); &#125; &#125;&#125; c&gt;doDispatch()所在类：org.springframework.web.servlet.DispatcherServlet 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293protected void doDispatch(HttpServletRequest request, HttpServletResponse response) throws Exception &#123; HttpServletRequest processedRequest = request; HandlerExecutionChain mappedHandler = null; boolean multipartRequestParsed = false; WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request); try &#123; ModelAndView mv = null; Exception dispatchException = null; try &#123; processedRequest = checkMultipart(request); multipartRequestParsed = (processedRequest != request); // Determine handler for the current request. /* mappedHandler：调用链 包含handler、interceptorList、interceptorIndex handler：浏览器发送的请求所匹配的控制器方法 interceptorList：处理控制器方法的所有拦截器集合 interceptorIndex：拦截器索引，控制拦截器afterCompletion()的执行 */ mappedHandler = getHandler(processedRequest); if (mappedHandler == null) &#123; noHandlerFound(processedRequest, response); return; &#125; // Determine handler adapter for the current request. // 通过控制器方法创建相应的处理器适配器，调用所对应的控制器方法 HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler()); // Process last-modified header, if supported by the handler. String method = request.getMethod(); boolean isGet = &quot;GET&quot;.equals(method); if (isGet || &quot;HEAD&quot;.equals(method)) &#123; long lastModified = ha.getLastModified(request, mappedHandler.getHandler()); if (new ServletWebRequest(request, response).checkNotModified(lastModified) &amp;&amp; isGet) &#123; return; &#125; &#125; // 调用拦截器的preHandle() if (!mappedHandler.applyPreHandle(processedRequest, response)) &#123; return; &#125; // Actually invoke the handler. // 由处理器适配器调用具体的控制器方法，最终获得ModelAndView对象 mv = ha.handle(processedRequest, response, mappedHandler.getHandler()); if (asyncManager.isConcurrentHandlingStarted()) &#123; return; &#125; applyDefaultViewName(processedRequest, mv); // 调用拦截器的postHandle() mappedHandler.applyPostHandle(processedRequest, response, mv); &#125; catch (Exception ex) &#123; dispatchException = ex; &#125; catch (Throwable err) &#123; // As of 4.3, we&#x27;re processing Errors thrown from handler methods as well, // making them available for @ExceptionHandler methods and other scenarios. dispatchException = new NestedServletException(&quot;Handler dispatch failed&quot;, err); &#125; // 后续处理：处理模型数据和渲染视图 processDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException); &#125; catch (Exception ex) &#123; triggerAfterCompletion(processedRequest, response, mappedHandler, ex); &#125; catch (Throwable err) &#123; triggerAfterCompletion(processedRequest, response, mappedHandler, new NestedServletException(&quot;Handler processing failed&quot;, err)); &#125; finally &#123; if (asyncManager.isConcurrentHandlingStarted()) &#123; // Instead of postHandle and afterCompletion if (mappedHandler != null) &#123; mappedHandler.applyAfterConcurrentHandlingStarted(processedRequest, response); &#125; &#125; else &#123; // Clean up any resources used by a multipart request. if (multipartRequestParsed) &#123; cleanupMultipart(processedRequest); &#125; &#125; &#125;&#125; d&gt;processDispatchResult()12345678910111213141516171819202122232425262728293031323334353637383940414243private void processDispatchResult(HttpServletRequest request, HttpServletResponse response, @Nullable HandlerExecutionChain mappedHandler, @Nullable ModelAndView mv, @Nullable Exception exception) throws Exception &#123; boolean errorView = false; if (exception != null) &#123; if (exception instanceof ModelAndViewDefiningException) &#123; logger.debug(&quot;ModelAndViewDefiningException encountered&quot;, exception); mv = ((ModelAndViewDefiningException) exception).getModelAndView(); &#125; else &#123; Object handler = (mappedHandler != null ? mappedHandler.getHandler() : null); mv = processHandlerException(request, response, handler, exception); errorView = (mv != null); &#125; &#125; // Did the handler return a view to render? if (mv != null &amp;&amp; !mv.wasCleared()) &#123; // 处理模型数据和渲染视图 render(mv, request, response); if (errorView) &#123; WebUtils.clearErrorRequestAttributes(request); &#125; &#125; else &#123; if (logger.isTraceEnabled()) &#123; logger.trace(&quot;No view rendering, null ModelAndView returned.&quot;); &#125; &#125; if (WebAsyncUtils.getAsyncManager(request).isConcurrentHandlingStarted()) &#123; // Concurrent handling started during a forward return; &#125; if (mappedHandler != null) &#123; // Exception (if any) is already handled.. // 调用拦截器的afterCompletion() mappedHandler.triggerAfterCompletion(request, response, null); &#125;&#125; 4、SpringMVC的执行流程 用户向服务器发送请求，请求被SpringMVC 前端控制器 DispatcherServlet捕获。 DispatcherServlet对请求URL进行解析，得到请求资源标识符（URI），判断请求URI对应的映射： a) 不存在 i. 再判断是否配置了mvc:default-servlet-handler ii. 如果没配置，则控制台报映射查找不到，客户端展示404错误 iii. 如果有配置，则访问目标资源（一般为静态资源，如：JS,CSS,HTML），找不到客户端也会展示404错误 b) 存在则执行下面的流程 根据该URI，调用HandlerMapping获得该Handler配置的所有相关的对象（包括Handler对象以及Handler对象对应的拦截器），最后以HandlerExecutionChain执行链对象的形式返回。 DispatcherServlet 根据获得的Handler，选择一个合适的HandlerAdapter。 如果成功获得HandlerAdapter，此时将开始执行拦截器的preHandler(…)方法【正向】 提取Request中的模型数据，填充Handler入参，开始执行Handler（Controller)方法，处理请求。在填充Handler的入参过程中，根据你的配置，Spring将帮你做一些额外的工作： a) HttpMessageConveter： 将请求消息（如Json、xml等数据）转换成一个对象，将对象转换为指定的响应信息 b) 数据转换：对请求消息进行数据转换。如String转换成Integer、Double等 c) 数据格式化：对请求消息进行数据格式化。 如将字符串转换成格式化数字或格式化日期等 d) 数据验证： 验证数据的有效性（长度、格式等），验证结果存储到BindingResult或Error中 Handler执行完成后，向DispatcherServlet 返回一个ModelAndView对象。 此时将开始执行拦截器的postHandle(…)方法【逆向】。 根据返回的ModelAndView（此时会判断是否存在异常：如果存在异常，则执行HandlerExceptionResolver进行异常处理）选择一个适合的ViewResolver进行视图解析，根据Model和View，来渲染视图。 渲染视图完毕执行拦截器的afterCompletion(…)方法【逆向】。 将渲染结果返回给客户端。","categories":[{"name":"spring","slug":"spring","permalink":"http://110.42.136.235/categories/spring/"}],"tags":[{"name":"spring","slug":"spring","permalink":"http://110.42.136.235/tags/spring/"}]},{"title":"Spring5","slug":"Spring5","date":"2022-04-11T01:11:02.000Z","updated":"2022-05-05T14:31:16.228Z","comments":true,"path":"2022/04/11/Spring5/","link":"","permalink":"http://110.42.136.235/2022/04/11/Spring5/","excerpt":"","text":"IOC什么是IOC 控制反转，把对象创建和对象之间的调用过程，交给Spring进行管理 使用IOC的目的：降低耦合度 IOC 底层原理 xml解析，工厂模式，反射IOC过程 第一步 xml配置文件，配置创建的对象 &lt;bean id=&quot;user&quot; class=&quot;com.wht.User&quot;&gt;&lt;/bean&gt; 第二部 有service类和dao类，创建工厂类 public static UserDao getDao()&#123; String classValue = class属性值;//通过xml解析 Class class = Class.forNmae(classValue);//反射 return (UserDao)class.newInstance(); &#125; IOC(接口) IOC思想基于IOC容器完成，IOC容器底层就是对象工厂 Spring提供IOC容器实现的两种方式：（两个接口） BeanFactory：IOC容器基本实现，是Spring内部使用的接口，不提供开发人员使用，加载配置文件时不会创建对象，在获取对象时才去创建对象 ApplicationContext：BeanFactory接口的子接口，提供更多功能，开发人员使用，加载配置文件时就会把配置文件中的对象创建 第二种更好，因为在可以做到慢启动，快响应 IOC 操作 Bean管理 Bean管理是指两个操作 Spring创建对象 Spring注入属性 Bean 管理操作的两种方式 xml创建对象 默认执行无参构造函数 id属性：唯一标识 class属性：类全路径 xml 注入属性 1.使用set方法 2.使用有参构造 DI：IOC的一种方法，依赖注入，就是注入属性 第一种注入方式：使用set方法 第二种注入方式：使用有参构造 注入空值 &lt;constructor-arg name=&quot;bName&quot;&gt; &lt;null&gt;&lt;/null&gt; &lt;/constructor-arg&gt; 注入特殊字符 1.可以使用转义 2.使用CDATA &lt;constructor-arg name=&quot;bName&quot;&gt; &lt;value&gt; &lt;![CDATA[&lt;&lt;数据结构&gt;&gt;]]&gt; &lt;/value&gt; &lt;/constructor-arg&gt; 注入外部bean &lt;!-- 注入外部bean--&gt; &lt;property name=&quot;userDao&quot; ref=&quot;userDaoImpl&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean id=&quot;userDaoImpl&quot; class=&quot;com.wht.dao.UserDaoImpl&quot;&gt;&lt;/bean&gt; 注入内部bean(实现一对多的关系) 也叫级联赋值 比如一个员工属于一个部门，但一个部门有多个员工，可以在员工类内加上一个部门对象，通过给部门这个属性赋值来规定员工的部门，这时可以用Spring来实现这种关系 &lt;!--注入内部bean--&gt; &lt;bean id=&quot;Emp&quot; class=&quot;com.wht.pojo.Emp&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;wht&quot;&gt;&lt;/property&gt; &lt;property name=&quot;dept&quot; ref=&quot;Dept&quot;&gt;&lt;/property&gt;&lt;/bean&gt; &lt;bean id=&quot;Dept&quot; class=&quot;com.wht.pojo.Dept&quot;&gt; &lt;property name=&quot;dName&quot; value=&quot;安保部门&quot;&gt;&lt;/property&gt; &lt;/bean&gt; 注入数组类型的属性 &lt;property name=&quot;strings&quot;&gt; &lt;array&gt; &lt;value&gt;数组1&lt;/value&gt; &lt;value&gt;数组2&lt;/value&gt; &lt;/array&gt; &lt;/property&gt; 注入List集合类型属性 &lt;property name=&quot;list&quot;&gt; &lt;list&gt; &lt;value&gt;list1&lt;/value&gt; &lt;value&gt;list2&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; 注入Map集合类型的属性 &lt;property name=&quot;map&quot;&gt; &lt;map&gt; &lt;entry key=&quot;key1&quot; value=&quot;value1&quot;&gt;&lt;/entry&gt; &lt;entry key=&quot;key2&quot; value=&quot;value2&quot;&gt;&lt;/entry&gt; &lt;/map&gt; &lt;/property&gt; 注入Set集合类型的属性 &lt;property name=&quot;set&quot;&gt; &lt;set&gt; &lt;value&gt;set1&lt;/value&gt; &lt;value&gt;set2&lt;/value&gt; &lt;/set&gt; &lt;/property&gt; set类型： set集合不允许有重复的如果内容重复，就只存进去第一次的，后面的就存不进去 set类型集合没有索引 如果注入的list集合类型是对象，则把value标签换成ref标签即可 提取list集合类型属性注入 第一步 在xml中使用util 第二步 提取list集合 &lt;util:list id=&quot;booklist&quot;&gt; &lt;value&gt;list-1&lt;/value&gt; &lt;value&gt;list-2&lt;/value&gt; &lt;value&gt;list-3&lt;/value&gt; &lt;/util:list&gt; 第三步 注入list集合 &lt;bean id=&quot;book&quot; class=&quot;com.wht.pojo.Book&quot;&gt; &lt;property name=&quot;bAuthor&quot; value=&quot;author&quot;&gt;&lt;/property&gt; &lt;property name=&quot;bName&quot; value=&quot;book&quot;&gt;&lt;/property&gt; &lt;property name=&quot;booklist&quot; ref=&quot;booklist&quot;&gt;&lt;/property&gt; &lt;/bean&gt; IOC操作Bean管理（FactoryBean）Spring有两种bean，一种普通bean，另一种工厂bean（FactoryBean） 普通bean：在配置文件中定义的bean类型就是返回类型 工厂bean：在配置文件定义bean类型可以和返回值不一样 IOC操作Bean管理（bran作用域）在Spring中，默认情况下，bean时单实例对象，也就是多次创建都是同一个对象 可以设置成多实例 使用scope设置 scope属性值 第一个值 singleton 单实例 第二个值 prototype 多实例 区别 单实例在加载配置文件时完成对象创建 不是在加载Spring对象时调用，而是在调用时才创建，每次创建的都是不同的对象 scope还有不常用的属性request和session IOC操作Bean管理(bean生命周期) bean生命周期 1.通过构造器创建bean实例（默认无参构造） 2.为bean的属性设置值和对其他bean引用（调用set方法） 3.调用bean初始化的方法（需要进行配置） 4.bean可以使用 5.当容器关闭时，调用bean销毁方法（需要配置销毁的方法） 配置bean初始化的方法 init-method 手动销毁bean context.close() 会自动强转 配置bean销毁的方法 destory-method bean后置处理器 配置后置处理器后，会在第三步，调用bean初始化之前和调用bean初始化之后分别执行 把bean实例传递给后置处理器的方法 把bean实例传递给后置处理器后的方法 bean配置后置处理器的方法 在对应的对象类中实现BeanPostProducer接口并实现其两个方法 @Override public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException &#123; System.out.println(&quot;1.bean传递给后置处理器&quot;); return bean; &#125; @Override public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException &#123; System.out.println(&quot;2.bean传递给后置处理器&quot;); return bean; &#125; IOC操作Bean管理（xml自动装配） byName自动装配 &lt;bean id=&quot;emp&quot; class=&quot;com.wht.autowire.Emp&quot; autowire=&quot;byName&quot;&gt;&lt;/bean&gt; 123&lt;bean id=&quot;dept&quot; class=&quot;com.wht.autowire.Dept&quot;&gt; &lt;property name=&quot;dName&quot; value=&quot;划水部门&quot;&gt;&lt;/property&gt;&lt;/bean&gt; 通过name属性自动装配，其中要装配的对象（划水部门）的name必须和bean内对应的属性name一致才可以 根据属性内容装配byType IOC操作Bean管理（引入外部属性文件） 普通连接方式 &lt;bean id=&quot;dataSource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot;&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.jdbc.Driver&quot;&gt;&lt;/property&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/users&quot;&gt;&lt;/property&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot;&gt;&lt;/property&gt; &lt;property name=&quot;password&quot; value=&quot;password&quot;&gt;&lt;/property&gt; &lt;/bean&gt; 使用外部属性文件进行连接的方式 第一步：在src下创建properties文件 第二步:在properties文件中写入信息 prop.driverClass=com.mysql.jdbc.Driver prop.url=jdbc:mysql://localhost:3306/users prop.username=root prop.password=password 第三步：在xml文件中引入context第四步：引入外部属性文件 &lt;!--引入外部属性文件--&gt; &lt;context:property-placeholder location=&quot;jdbc.properties&quot;&gt;&lt;/context:property-placeholder&gt; &lt;bean id=&quot;dataSource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot;&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;$&#123;prop.driverClass&#125;&quot;&gt;&lt;/property&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql:$&#123;prop.url&#125;&quot;&gt;&lt;/property&gt; &lt;property name=&quot;username&quot; value=&quot;$&#123;prop.username&#125;&quot;&gt;&lt;/property&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;prop.password&#125;&quot;&gt;&lt;/property&gt; &lt;/bean&gt; IOC操作Bean管理(基于注解方式)Spring针对Bean管理中创建对象提供的注解 @Component @Service @Controller @Repository 四个注解的功能都是一样的，都可以创建bean实例 基于注解方式实现对象创建第一步：引入依赖 第二步：开启组件扫描 &lt;context:component-scan base-package=&quot;com.wht&quot;&gt;&lt;/context:component-scan&gt; 第三步：开始使用注解创建对象 在xml中可以配置哪些扫描哪些不扫描 注解方式注入属性 @AutoWired 根据属性类型进行输入 @Qualifier 根据属性名称注入 @Resource 可以根据类型注入，也可以根据名称注入 使用Qualifier必须和AutoWired一起使用，在一个接口有多个实现类的时候可以进行使用 //使用注解进行注入不需要设置set方法 @Autowired //根据类型进行注入 @Qualifier(value = &quot;userDaoImpl&quot;)//如果一个接口有多个实现类，需要用名称 private UserDao userDao; 使用Resource注入 @Resource//根据类型 @Resource(name = &quot;userDaoImpl&quot;)//根据名称 使用Value注入 @Value(value = &quot;test1&quot;) private String test; 完全注解开发首先创建一个config类，在类中加入如下注解 @Configuration//替代配置文件 @ComponentScan(basePackages = &quot;com.wht&quot;) 然后在测试类中把加载配置文件换成加载配置类 ApplicationContext context = new AnnotationConfigApplicationContext(SpringConfig.class); AOP什么是AOPAOP是面向切面（方面）编程的缩写降低业务逻辑的耦合度，提高程序的可重用性，同时提高开发的效率 通俗理解：不通过修改源代码来增加一些新的功能 AOP底层原理 AOP底层使用动态代理 有两种情况 第一种：有接口 使用JDK动态代理，创建接口的代理对象，来增加一些新的功能 第二种：没有接口 CGLIB动态代理，创建子类的代理对象，增强类中的方法 AOP术语 连接点 类里面哪些方法可以被增强，这些方法称为连接点 切入点 实际真正增强的方法称为切入点 通知（增强） 实际增强的逻辑部分就叫通知 通知有多种类型 前置 后置 环绕 异常 最终 切面 是一个动作，把通知应用到切入点的过程就叫切面 AOP操作 Spring框架一般基于AspectJ实现AOP操作 AspectJ本身是一个单独的框架，一般把AspectJ和Spring框架一起使用，进行AOP操作 基于AspectJ实现AOP操作 基于xml配置文件实现 基于注解方式实现（使用较多） 第一步 导入依赖 &lt;!-- Aop相关依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aspects&lt;/artifactId&gt; &lt;version&gt;5.2.6.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.9.3&lt;/version&gt; &lt;--注意版本问题--&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;aopalliance&lt;/groupId&gt; &lt;artifactId&gt;aopalliance&lt;/artifactId&gt; &lt;version&gt;1.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;net.sourceforge.cglib&lt;/groupId&gt; &lt;artifactId&gt;com.springsource.net.sf.cglib&lt;/artifactId&gt; &lt;version&gt;2.2.0&lt;/version&gt; &lt;/dependency&gt; 切入点表达式语法结构 execution([权限修饰符][返回类型][类全路径][方法名称][参数列表]) 例如 对Book类中的add方法进行修改 execution(* com.wht.dao.Book.add(..)) 对dao包里面所有类，类里面的所有方法进行增强 execution(* com.wht.dao..(..)) AOP操作（AspectJ注解）第一步：开启注解扫描和Aspect &lt;!--开启注解扫描--&gt; &lt;context:component-scan base-package=&quot;com.wht&quot;&gt;&lt;/context:component-scan&gt; &lt;!-- 开启Aspect生成代理对象--&gt; &lt;aop:aspectj-autoproxy&gt;&lt;/aop:aspectj-autoproxy&gt; 第二部：在增强类和被增强类中分别加入注解其他通知 //前置通知 @Before(value = &quot;execution(* com.wht.pojo.User.add(..))&quot;) public void before()&#123; System.out.println(&quot;before...&quot;); &#125; //最终通知 @After(value = &quot;execution(* com.wht.pojo.User.add(..))&quot;) public void after()&#123; System.out.println(&quot;after...&quot;); &#125; //异常通知，当有异常时执行 @AfterThrowing(value = &quot;execution(* com.wht.pojo.User.add(..))&quot;) public void afterThrowing()&#123; System.out.println(&quot;afterThrowing...&quot;); &#125; //后置通知 @AfterReturning(value = &quot;execution(* com.wht.pojo.User.add(..))&quot;) public void afterReturning()&#123; System.out.println(&quot;afterReturning...&quot;); &#125; //环绕通知，在被增强方法之前和之后执行 @Around(value = &quot;execution(* com.wht.pojo.User.add(..))&quot;) public void around(ProceedingJoinPoint proceedingJoinPoint) throws Throwable &#123; System.out.println(&quot;around before&quot;); proceedingJoinPoint.proceed(); System.out.println(&quot;around after&quot;); &#125; after是最终通知，不管有没有异常都会执行 AfterThrowing是异常通知，当有异常时执行 当有异常是，环绕通知和后置通知(afterReturn)都不会执行 相同切入点抽取因为每个通知后面的切入点都是一样的，所以可以进行相同切入点抽取 @Pointcut(value = “execution(* com.wht.pojo.User.add(..))”) public void pointcut(){ //相同切入点抽取 } //前置通知 @Before(value = “pointcut()”) public void before(){ System.out.println(&quot;before...&quot;); } 多个增强类对同一个方法进行增强当多个增强类对同一个方法进行增强时，可以设置增强类优先级 //增强的类 @Component @Aspect //生成代理对象 @Order(1)//设置优先级，值越小，越优先执行 AOP操作（AspectJ配置文件）&lt;!-- 创建对象--&gt; &lt;bean id=&quot;user&quot; class=&quot;com.wht.pojo.User&quot;&gt;&lt;/bean&gt; &lt;bean id=&quot;userProxy&quot; class=&quot;com.wht.aopxml.UserProxy&quot;&gt;&lt;/bean&gt; &lt;aop:config&gt; &lt;!-- 切入点--&gt; &lt;aop:pointcut id=&quot;p&quot; expression=&quot;execution(* com.wht.pojo.User.add(..))&quot;/&gt; &lt;!--配置切面--&gt; &lt;aop:aspect ref=&quot;userProxy&quot;&gt; &lt;aop:before method=&quot;before&quot; pointcut-ref=&quot;p&quot;&gt;&lt;/aop:before&gt; &lt;/aop:aspect&gt; &lt;/aop:config&gt; AOP全注解开发创建一个配置类，不需要xml文件 @Configuration//配置类 @ComponentScan(basePackages = &quot;com.wht&quot;)//开启注解扫描 @EnableAspectJAutoProxy(proxyTargetClass = true)//开启Aspect生成代理对象 public class ConfigAop &#123; &#125; JdbcTemplate什么是JdbcTemplateSpring框架对JDBC进行了封装，使用JdbcTemplate对数据库进行操作 JdbcTemple操作数据库第一步 ： 配置xml文件 &lt;!--开启注解扫描--&gt; &lt;context:component-scan base-package=&quot;com.wht&quot;&gt;&lt;/context:component-scan&gt; &lt;!--引入外部属性文件--&gt; &lt;context:property-placeholder location=&quot;jdbc.properties&quot;&gt;&lt;/context:property-placeholder&gt; &lt;!--数据库连接池--&gt; &lt;bean id=&quot;dataSource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot;&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;$&#123;prop.driverClass&#125;&quot;&gt;&lt;/property&gt; &lt;property name=&quot;url&quot; value=&quot;$&#123;prop.url&#125;&quot;&gt;&lt;/property&gt; &lt;property name=&quot;username&quot; value=&quot;$&#123;prop.username&#125;&quot;&gt;&lt;/property&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;prop.password&#125;&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- JdbcTemplate对象--&gt; &lt;bean id=&quot;jdbcTemplate&quot; class=&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&gt; &lt;!-- 注入dataSource--&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt; &lt;/bean&gt; 第二步： 添加注解 在userdao的实现方法中 @Repository public class UserDaoImpl implements UserDao&#123; //注入JdbcTemplate @Autowired private JdbcTemplate jdbcTemplate; @Override public void add(User user) &#123; String sql=&quot;insert into users values(?,?)&quot;; int update = jdbcTemplate.update(sql, user.getPassword(), user.getUsername()); System.out.println(update); &#125; &#125; 在UserService中 @Service(value = &quot;userService&quot;) public class UserService &#123; @Autowired private UserDao userDao; public void add(User user)&#123; userDao.add(user); &#125; &#125; 第三步：在Test类中调用 事务什么是事务事务时数据库操作的最基本单元，逻辑上的一组操作，要么都成功，要么都失败 事务的四个特性 原子性（不可分割） 一致性 隔离性 持久性 //事务操作 public void account() &#123; try &#123; //开启事务 //没有出现异常,提交事务 &#125; catch (Exception e) &#123; //出现异常,事务回滚 &#125; &#125;//account 事务操作（Spring事务管理介绍） 事务一般添加在JavaEE三层结构里面的Service层(业务逻辑层) 在Spring中进行事务操作有两种方式 编程式 声明式（使用较多） 在Spring中进行声明式事务管理，底层使用AOP原理 Spring事务管理APISpring提供一个接口，代表事务管理器，这个接口针对不同框架提供不同的实现类 在Spring配置文件配置事务管理器第一步：配置事务管理器 &lt;!-- 配置事务管理器--&gt; &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt; 第二步：注入数据源，并开启事务管理 &lt;!-- 注入数据源--&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 开启事务管理--&gt; &lt;tx:annotation-driven transaction-manager=&quot;transactionManager&quot;&gt;&lt;/tx:annotation-driven&gt; 第三步：添加注解 @Transactional，这个注解可以添加到类上面，也可以添加到方法上面 注解添加到类上面，这个类里面的所有方法都添加了事务 注解添加到方法上，为这个方法添加事务Transactional中配置事务相关参数 propagation：事务传播行为 默认 @Transactional(propagation = Propagation.REQUIRED)也就是在其他方法中如果没有事务，会自动添加事务 ioslation：事务隔离级别 事务有隔离性的特性，多事务操作之间不会产生影响，不考虑隔离性产生很多问题 有三个问题：脏读，不可重复读，虚读（幻读） 脏读：一个未提交事务读取到另一个未提交事务的数据 不可重复读：一个未提交事务读取到另一个已经提交的事务的数据（是一种现象而不是一个问题） 虚读： 一个未提交事务读取到另一提交事务添加数据 timeout：超时时间 事务需要在一定时间内提交，否则回滚 timeout默认是-1，可以设置以秒为单位 readOnly：是否只读 默认值是false，可以查询也可以添加修改删除操作 rollBackFor：回滚 设置出现哪些异常进行事务回滚 noRollbackFor：不回滚 设置出现哪些异常不进行回滚 事务操作（XML声明式事务管理）第一步：配置事务管理器 第二步：配置通知 第三步：配置切入点和切面 &lt;!-- 1. 配置事务管理器--&gt; &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt; &lt;!-- 注入数据源--&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!--2.配置通知--&gt; &lt;tx:advice id=&quot;txadvice&quot;&gt; &lt;tx:attributes&gt; &lt;!-- 指定那种规则的方法上面添加事务--&gt; &lt;tx:method name=&quot;accountMoney&quot; propagation=&quot;REQUIRED&quot;/&gt;&lt;!--指定accountMoney方法--&gt; &lt;tx:method name=&quot;account*&quot;/&gt; &lt;!--指定以account开头的方法--&gt; &lt;/tx:attributes&gt; &lt;/tx:advice&gt; &lt;!-- 3.配置切入点和切入面--&gt; &lt;aop:config&gt; &lt;!-- 配置切入点--&gt; &lt;aop:pointcut id=&quot;pt&quot; expression=&quot;execution(* com.wht.service.UserService.add(..))&quot;/&gt; &lt;!-- 配置切面--&gt; &lt;aop:advisor advice-ref=&quot;txadvice&quot; pointcut-ref=&quot;pt&quot;/&gt; &lt;/aop:config&gt; 事务操作（完全注解声明式事务管理）第一步：创建配置类 @Configuration//配置类 @ComponentScan(basePackages = &quot;com.wht&quot;)//组件扫描 @EnableTransactionManagement//开启事务 public class TxConfig &#123; //创建数据库连接池 @Bean public DruidDataSource getDruidDataSource()&#123; DruidDataSource dataSource = new DruidDataSource(); dataSource.setDriverClassName(&quot;com.mysql.jdbc.Driver&quot;); dataSource.setUrl(&quot;jdbc:mysql://localhost:3306/student&quot;); dataSource.setUsername(&quot;root&quot;); dataSource.setPassword(&quot;password&quot;); return dataSource; &#125; //创建JdbcTemplate对象 @Bean public JdbcTemplate jdbcTemplate(DataSource dataSource)&#123; JdbcTemplate jdbcTemplate = new JdbcTemplate(); //注入datasource jdbcTemplate.setDataSource(dataSource); return jdbcTemplate; &#125; //创建事务管理器 @Bean public DataSourceTransactionManager dataSourceTransactionManager(DataSource dataSource)&#123; DataSourceTransactionManager dataSourceTransactionManager = new DataSourceTransactionManager(); dataSourceTransactionManager.setDataSource(dataSource); return dataSourceTransactionManager; &#125; &#125; Spring 5新特性 基于jdk8 日志 新增@nullable注解，可以使方法返回值为空，也可以使用在方法参数中和属性值中 函数式风格Lambda表达式 SpringWebflux介绍2022/4/13","categories":[{"name":"spring","slug":"spring","permalink":"http://110.42.136.235/categories/spring/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://110.42.136.235/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"JavaWeb","slug":"JavaWeb","date":"2022-04-07T09:45:16.000Z","updated":"2022-04-08T09:15:07.980Z","comments":true,"path":"2022/04/07/JavaWeb/","link":"","permalink":"http://110.42.136.235/2022/04/07/JavaWeb/","excerpt":"","text":"JavaWeb TomCat服务器 Tomcat 服务器是一个免费的开放源代码的Web应用服务器，属于轻量级应用服务器，在中小型系统和并发访问用户不是很多的场合下被普遍使用，是开发和调试JSP程序的首选 Http (超文本传输协议）是一个简单的请求-响应协议，它通常运行在TCP之上。 HTTP 的请求 get：请求能够携带的参数比较少，大小有限制，会在浏览器的URL地址栏显示数据内容，不安全，但高效 post:请求能够携带的参数没有限制，大小没有限制，不会在浏览器的URL地址栏显示数据内容，安全，但不高效 HTTP 的请求报文结构： 请求行：由请求方法（Method）、URL 字段和 HTTP 的协议版本组成，注意其中的空格、回车符和换行符均不可省略，所以我们的请求方法实际上就是位于请求行中的了。 请求头部：位于请求行之后，个数可以为 0~若干个，每个请求头部都包含一个头部字段名和一个值，它们之间用冒号 “:” 分隔，在最后用回车符和换行符表示结束。 请求数据：如果请求方法为 GET，那么请求数据为空。它主要是在 POST 中进行使用，适用于需要填表单（FORM）的场景。 请求方法：Get,Post,HEAD,DELETE,PUT,TRACT.…","categories":[],"tags":[]},{"title":"JDBC java数据库连接","slug":"JDBC","date":"2022-03-25T02:24:25.000Z","updated":"2022-03-25T11:56:44.436Z","comments":true,"path":"2022/03/25/JDBC/","link":"","permalink":"http://110.42.136.235/2022/03/25/JDBC/","excerpt":"","text":"下载安装驱动MYSQL驱动jar包下载 将jar包导入idea在项目下创建新文件夹，将jar包复制进去，右键jar包，选择add as library 开始操作数据库public static void main(String[] args) throws Exception &#123; //注册驱动 Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;); //获取连接,依次输入ip,端口号和连接的数据库名称 String url=&quot;jdbc:mysql://127.0.0.1:3306/student&quot;; String username=&quot;root&quot;; String password=&quot;password&quot;; Connection conn=DriverManager.getConnection(url,username,password); //定义sql String sql=&quot;UPDATE stu set math=88 WHERE stuname=\\&quot;王洪涛\\&quot;&quot;; //获取执行sql对象的statement Statement stmt = conn.createStatement(); //执行sql int count = stmt.executeUpdate(sql);//受影响的行数 //处理结果 System.out.println(count); //关闭资源 stmt.close(); conn.close(); &#125; JDBC APIDriverManager获取数据库连接 .getConnection(url,username,password) Connection1.获取执行SQL的对象 conn.createStatement(); 2.管理事务 try &#123; //开启事务 conn.setAutoCommit(false); //执行完毕，提交事务 conn.commit(); &#125;catch (SQLException throwables) &#123; //如果出现异常,回滚事务 conn.rollback(); throwables.printStackTrace(); &#125; statement 执行sql语句执行sql语句 .executeUpdate(sql);//更新数据库 .executeQuery(sql1);//查询数据库 ResultSetresultset可以对查询结果进行操作，比如获取查询结果中的各种字段 Statement stmt = conn.createStatement(); //执行sql ResultSet rs = stmt.executeQuery(sql1); re.getInt(列数);//获取相应列的int类型数据 re.getString(列数);//获取string类型的数据 PreparedStatement","categories":[],"tags":[]},{"title":"css学习日记","slug":"css学习日记","date":"2022-03-21T11:33:08.000Z","updated":"2022-03-23T08:48:25.429Z","comments":true,"path":"2022/03/21/css学习日记/","link":"","permalink":"http://110.42.136.235/2022/03/21/css%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/","excerpt":"","text":"css简介css是层叠样式表（cascading style sheets） css是用来美化网页页面的 css语法规范css由两大块组成，分别是选择器和样式 style的位置应该在head里 &lt;head&gt; &lt;style&gt; p &#123; &lt;!-- 修改文字为红色 --&gt; color: red &lt;!-- 修改字体大小 --&gt; font-size: 12px &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt;颜色&lt;/p&gt; &lt;/body&gt; css代码风格 样式格式展开式 p &#123; &lt;!-- 修改文字为红色 --&gt; color: red &lt;!-- 修改字体大小 --&gt; font-size: 12px &#125; 样式大小写：一般用小写 空格规范属性值前面和冒号后面，保留一个空格，选择器和大括号中间保留空格 css基础选择器css选择器分类 基础选择器、复合选择器 基础选择器分为：标签选择器、类选择器、id选择器、通配符选择器 标签选择器以html的标签名作为选择器，按照标签名分类，为页面中同一类别的标签统一css格式 例如：将p标签改为绿色，div标签改为红色 &lt;style&gt; p &#123; color: green; &#125; div &#123; color: red; &#125; &lt;/style&gt; 类选择器可以差异化选择不同的标签，单独选一个或者某几个标签 例如，将所有拥有red类的html元素均为红色 .red &#123; color: red; &#125; 在html中给某个标签添加class属性即可 &lt;li class=&quot;red&quot;&gt; 红色&lt;/li&gt; 类选择器-多类名标签可以选择多个类名，中间必须用空格隔开 &lt;div class=&quot;lei1 lei2&quot;&gt; &lt;/div&gt; id选择器定义格式 #idname &#123; color: red; &#125; 调用格式 &lt;li id=&quot;idname&quot;&gt;&lt;/li&gt; id选择器与类选择器的区别：id选择器定义方式不同，且只能调用一次 通配符选择器在css中，通配符选择器表示选取页面中所有标签 *&#123; 属性值1：属性值1； ... &#125; 通配符选择器不需要调用，会自动调用 css复合选择器后代选择器后代选择器用于选取某元素的后代元素。 div p &#123; background-color:yellow; &#125; 子元素选择器与后代选择器相比，子元素选择器（Child selectors）只能选择作为某元素直接/一级子元素的元素 div&gt;p &#123; background-color:yellow; &#125; 相邻兄弟选择器选取了所有位于 div 元素后的第一个 p 元素 div+p &#123; background-color:yellow; &#125; 后续兄弟选择器后续兄弟选择器选取所有指定元素之后的相邻兄弟元素 div~p &#123; background-color:yellow; &#125; css字体属性字体系列&lt;style&gt; P &#123; font-family: &#39;宋体&#39;,Times,serif &#125; &lt;/style&gt; 当有多个字体时，系统会默认使用第一种，如果第一种不可用在用后面的字体 字体大小 p &#123; font-size: 20px &#125; 字体粗细 p &#123; font-weight: bold 或 700 &#125; 文字样式文字斜体 P &#123; font-style: italic &#125; 文字不倾斜 p &#123; font-style: normal &#125; 文字复合属性 font-style font-weight font-size font-family 顺序不可颠倒 p &#123; font: italic 700 16px &#39;Microsoft yahei&#39; &#125; css文本属性文本颜色颜色&lt;style&gt; div &#123; &lt;!-- color: pink --&gt; &lt;!-- color: #ff0000 --&gt; &lt;!-- color: rgb(255,0,0) --&gt; &#125; &lt;/style&gt; 对齐文本div &#123; text-align: center; right left &#125; 装饰文本div &#123; text-decoration: underline;//下划线 text-decoration: line-through;//删除线 text-decoration: none;//默认没有装饰线（用的最多） &#125; 文本缩进p &#123; text-indent: 20px //文本首行缩进 text-indent: 2em //常用单位，1em就是缩进一个文字大小 &#125; 行间距p &#123; text-height: 26px;//是包括文字和上下间距 &#125; css引入方式内部样式表css写在html内部，放在style标签内部 一般用于控制整个html页面 行内样式表直接在标签内部修改样式 &lt;p style=&quot;color:red&quot;&gt; 红色&lt;/p&gt; 红色 一般不推荐使用 外部样式表单独写一个css文件，引入到html中 引入方式: &lt;link rel=&quot;stylesheet&quot; href=&quot;01.css&quot;&gt;//快捷键:link+tab css盒子 div &#123; width: 300px; border: 25px solid green; padding: 25px; margin: 25px; &#125; border-style :none: 默认无边框 dotted: 定义一个点线边框 dashed: 定义一个虚线边框 solid: 定义实线边框 double: 定义两个边框。 两个边框的宽度和 border-width 的值相同 groove: 定义3D沟槽边框。效果取决于边框的颜色值 ridge: 定义3D脊边框。效果取决于边框的颜色值 inset:定义一个3D的嵌入边框。效果取决于边框的颜色值 outset: 定义一个3D突出边框。 效果取决于边框的颜色值 p.none{ border-style:none; } p.dotted{ border-style:dotted; } p.dashed{ border-style:dashed; } p.ridge{ border-style: ridge; } p.ridge2{ border-style: ridge; border-color:red; border-width:5px } p.ridge3{ border-style: ridge; border-color:red; border-width:5px; outline-style: ridge; outline-color:green } css边框-border none dotted dashed ridge 指定边框宽度和边框颜色 p.ridge2&#123; border-style: ridge; border-color:red;//必须在style后面 border-width:5px &#125; ridge2 css轮廓-outline指定轮廓样式和颜色 p.ridge3&#123; border-style: ridge; border-color:red; border-width:5px; outline-style: ridge; outline-color:green &#125; ridge3 外边距-margin 填充-padding css可视指定h1不可见，但依然占有空间 h1.hidden &#123; visibility:hidden; &#125; css定位static relative fixed absolute sticky css伪类a:link &#123;color:#FF0000;&#125; /* 未访问的链接 */ a:visited &#123;color:#00FF00;&#125; /* 已访问的链接 */ a:hover &#123;color:#FF00FF;&#125; /* 鼠标划过链接 */ a:active &#123;color:#0000FF;&#125; /* 已选中的链接 */ css伪元素p:first-letter &#123; color:#ff0000; font-size:xx-large; &#125; first-letter表示首字母 first-line表示首行 css before元素h1:before &#123; content:url(smiley.gif); &#125; css导航栏&lt;ul&gt; &lt;li&gt;&lt;a href=&quot;#home&quot;&gt;主页&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#news&quot;&gt;新闻&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#contact&quot;&gt;联系&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#about&quot;&gt;关于&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; 主页 新闻 联系 关于 加入修饰 &lt;style&gt; .daohang &#123; list-style-type:none;//去掉小黑点 margin:0;//边距设为0 padding:0;//填充设为0 &#125; &lt;/style&gt; .daohang { border:1px solid #555; list-style-type:none; margin:0; padding:0; background-color:#f1f1f1; height:50%; /* position:fixed; */ overflow:auto } .daohang li { border-bottom:1px solid #555; } .daohang li:last-child{ border-bottom: none; } .daohang a{ text-align:center; display:block; color: #000; padding:8px 16px; text-decoration:none; } .daohang a:hover:not(.active) { background-color: #555; color: white; } ul a.active { background-color: #4CAF50; color: white; } 主页 新闻 联系 关于 css图片廊&lt;style&gt; div.img &#123; margin: 5px; border: 5px solid #ccc; float: center; width: 180px; &#125; div.img:hover &#123; border: 1px solid #777; &#125; div.desc &#123; padding: 15px; text-align: auto; &#125; &lt;/style&gt; &lt;div&gt; &lt;div class=&quot;img&quot;&gt; &lt;a target=&quot;_blank&quot; href=&quot;https://static.runoob.com/images/demo/demo1.jpg&quot;&gt; &lt;img src=&quot;https://static.runoob.com/images/demo/demo1.jpg&quot; alt=&quot;图片描述&quot;&gt; &lt;/a&gt; &lt;div class=&quot;desc&quot;&gt; 图文描述 &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; div.img { margin: 5px; border: 5px solid #ccc; float: center; width: 180px; } div.img:hover { border: 1px solid #777; } div.desc { padding: 15px; text-align: auto; } 图文描述","categories":[],"tags":[]},{"title":"java学习日记","slug":"java学习日记","date":"2022-03-20T10:37:02.000Z","updated":"2022-04-08T13:30:48.272Z","comments":true,"path":"2022/03/20/java学习日记/","link":"","permalink":"http://110.42.136.235/2022/03/20/java%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/","excerpt":"","text":"java学习路线： java基础：韩顺平 尚硅谷：spring5=》springMVC=》springboot git linux java基本知识 Class（类）是java中最小单元，java所有内容都是放在类中的 每一个.java文件都是由类组成 一个java文件可以有多个class(不提倡),但只能有一个public class public class的名字必须和文件名字一样，大小写都要完全一致 main函数的基本格式PSVM public static void main(String[] args) 自定义函数调用方法 public class hello &#123; public static void main(String[] args)&#123; System.out.println(&quot;hello&quot;); hello.in(); &#125; public static void in()&#123;//自定义函数在调用时才会执行 System.out.println(&quot;in函数&quot;); &#125; &#125; java 进阶 junit单元测试 @Test public void testAdd()&#123; int a=1; int b=2; int c=a+b; assert.assertEquals(3,c);//断言 &#125; 在所有方法执行前都会自动执行 @Before 在所有方法结束后都会执行 @After 反射反射：将类的各个部分封装为其他对象，这就是反射机制 .java文件被编译成字节码文件.class是类加载器会把成员变量封装进Filed ，构造方法会被封装进Constructor中，成员方法也会被封装进Method 好处 可以在程序运行过程中操作这些对象 可以解耦，提高程序的可扩展性 获取class对象的方式： class.forName(“全类名”)：将字节码文件加载进内存，返回class对象 多用于配置文件 类名.class:通过类名的属性class获取 多用于参数传递 对象.getClass() getClass()方法在Object类中定义着 多用于对象的获取字节码的方式","categories":[],"tags":[]},{"title":"hexo搭建个人博客","slug":"hexo搭建个人博客","date":"2022-03-20T02:54:07.000Z","updated":"2022-05-01T09:22:09.701Z","comments":true,"path":"2022/03/20/hexo搭建个人博客/","link":"","permalink":"http://110.42.136.235/2022/03/20/hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/","excerpt":"","text":"安装Nodejs安装 查看node版本node -v 查看npm版本npm -v 安装淘宝的cnpm 管理器npm install -g cnpm –registry=http://registry.npm.taobao.org 查看cnpm版本cnpm -v 安装hexo框架cnpm install -g hexo-cli 查看hexo版本hexo -v 创建blog目录mkdir blog 进入blog目录cd blog 生成博客 初始化博客sudo hexo init 启动本地博客服务hexo s 本地访问地址http://localhost:4000/ 创建新的文章hexo n “我的第一篇文章” 清理hexo clean 生成hexo g Github创建一个新的仓库 YourGithubName.github.io在blog目录下安装git部署插件ocnpm install –save hexo-deployer-git 配置_config.ymlDeploymentDocs: https://hexo.io/docs/deployment.html deploy: type: git repo: https://github.com/YourGithubName/YourGithubName.github.io.git branch: master 部署到Github仓库里hexo d 访问这个地址可以查看博客https://YourGithubName.github.io/ 下载yilia主题到本地 git clone https://github.com/litten/hexo-theme-yilia.git themes/yilia 修改hexo根目录下的 _config.yml 文件 theme: yilia 清理一下hexo c 生成hexo g 部署到远程Github仓库hexo d 查看博客https://YourGithubName.github.io/","categories":[],"tags":[]},{"title":"HTML学习日记","slug":"HTML学习日记","date":"2022-03-19T01:12:51.000Z","updated":"2022-03-21T12:20:49.449Z","comments":true,"path":"2022/03/19/HTML学习日记/","link":"","permalink":"http://110.42.136.235/2022/03/19/HTML%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/","excerpt":"","text":"HTML简介HTML是超文本标记语言(Hyper Text Markup Language)，是用来描述网页的一种语言HTML不是编程语言，而是一种标记语言，标记语言是一套标记标签 Web标准Web标准的构成 标准 说明 结构 用于对网页元素进行整理和分类，主要是HTML 表现 用于设置网页元素的板式、颜色、大小等外观，主要是css 行为 指网页模型的定义及交互的编写，主要是JavaScript HTML语法规范基本语法 HTML一般成对出现,有单标签，但是很少标签关系 包含关系123&lt;head&gt;&lt; title&gt; &lt; /title&gt;&lt;/head&gt; 并列关系12&lt;head&gt; &lt;/head&gt;&lt;body&gt; &lt;/body&gt; HTML基本结构标签 标签名 定义 说明 &lt;html&gt;&lt;/html&gt; HTML标签 页面最大标签，也称根标签 &lt;head&gt;&lt;/head&gt; 文档的头部 在head中必须设置title标签 &lt;title&gt;&lt;/title&gt; 文档的标题 让页面有自己的标题 &lt;body&gt;&lt;/body&gt; 文档的主体 页面内容基本都是在body中 文档类型声明标签&lt;!DOCTYPE html&gt;意思是告诉浏览器使用了那种HTML版本来显示网页这个标签表示使用最新的HTML5显示页面 lang语言类型用来定义当前文档显示的语言，en为英语，zh-CN定义为中文网页不影响页面显示，只是对浏览器提示 字符集在&lt;head&gt;标签中，可以通过&lt;meta&gt;标签的charset属性来规定HTML文档应该使用哪种字符编码,例如&lt;meta charset=&quot;UTF-8&quot;&gt; HTML常用标签标题标签&lt;h1&gt;-&lt;h6&gt;&lt;h1&gt;是一级标签,以此类推特点： 加了标题的文字会变大变粗 每个标题都是独占一行 段落标签和换行标签在HTML中，多个空格或者多个回车并不会起作用，必须使用标签&lt;p&gt;&lt;/p&gt;是一个段落标签（paragraph的缩写）特点： 文本会根据浏览器窗口大小自动换行 段落和段落间会有空隙&lt;br /&gt;是一个换行标签（break的缩写）特点： 这是一个单标签 会另起一行但不会有上下间距 文本格式化标签设置文字粗体、斜体或下划线等效果 语义 标签 说明 加粗 &lt;strong&gt;&lt;/strong&gt;或&lt;b&gt;&lt;/b&gt; 推荐用&lt;strong&gt; 倾斜 &lt;em&gt;&lt;/em&gt;或&lt;i&gt;&lt;/i&gt; 推荐使用&lt;em&gt; 删除线 &lt;del&gt;&lt;/del&gt;或&lt;s&gt;&lt;/s&gt; 推荐&lt;del&gt; 下划线 &lt;ins&gt;&lt;/ins&gt;或&lt;u&gt;&lt;/u&gt; 推荐&lt;ins&gt;&lt;/ins&gt; &lt;div&gt;和&lt;span&gt;标签&lt;div&gt;和&lt;span&gt;是没有语义的，它们就是一个盒子，用来装内容的 特点： div是division的缩写(分割，分区),单独占一行，用作大盒子 span(跨度、跨距)，一行可以放好多个，用作小盒子 图像标签和路径图像标签在HTML标签中，&lt;img&gt;标签用于定义HTML页面中的图像&lt;img src=&quot;狐狸.jpg&quot;/&gt;图像标签的其他属性 属性 属性值 说明 src 图片路径 必须属性 alt 文本 替换文本，图像不能正常显示，用该文字替代 title 文本 提示文本，鼠标放到图像上的提示文字 width 像素 设置图像的宽度 height 像素 设置图像的高度 border 像素 设置图像的边框粗细 例如：&lt;img src=&quot;img.png&quot; title=&quot;图像&quot;/&gt;属性之间不分顺序 路径相对路径 相对路径分类 符号 说明 同一级路径 图像与html文件处于同一级如&lt;img src=&quot;1.png&quot;/&gt; 下一级路径 / 图像在HTML文件的下一级如&lt;img src=&quot;/img/1.png&quot;/&gt; 上一级路径 ../ 图像在html文件的上一级&lt;img src=&quot;../1.png/&gt; 绝对路径完整的路径或网络地址&quot;C:\\Users\\1.png&quot;或&quot;www.xxx.com&quot; 超链接标签 a是anchor（锚）的缩写，herf是网站地址，是必须属性，target是打开方式，可选”_blank”或”_self”,标签中间可以是文字或者图片 链接可以分为内部链接和外部链接 下载链接:herf地址是一个文件或压缩包，会下载这个文件 空链接：herf里是#即可 &lt;a href=&quot;https://home.firefoxchina.cn&quot; target=&quot;_blank&quot;&gt; 火狐&lt;/a&gt; 火狐 &lt;a href=&quot;http://www.qq.com&quot; target=&quot;_self&quot;&gt; 腾讯&lt;/a&gt; 腾讯 锚点链接1.在链接文本的href属性中，设置属性值为#名字的形式,如： &lt;a href=&quot;#two&quot;&gt; 第二季&lt;/a&gt; 2.在目标位置添加id属性 &lt;h3 id=&quot;two&quot;&gt; 第二季&lt;/a&gt; 注释和特殊字符&lt;!--注释文字--&gt; 快捷键ctrl + / 表格标签 &lt;table&gt;&lt;/table&gt;是定义表格的标签 &lt;td&gt;&lt;/td&gt;是定义表格中的行的标签 &lt;td&gt;&lt;/td&gt;定义表格中行的单元格 &lt;table&gt; &lt;tr&gt;&lt;td&gt; 年龄&lt;/td&gt; &lt;td&gt;性别 &lt;/td&gt; &lt;td&gt;姓名&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;19&lt;/td&gt; &lt;td&gt;男&lt;/td&gt;&lt;td&gt; 王洪涛&lt;/td&gt;&lt;/tr&gt; &lt;/table&gt; 效果： 年龄 性别 姓名 19 男 王洪涛 表头单元格&lt;th&gt;&lt;/th&gt; 在表头加入表头标签会使表头文字加粗并居中，效果如下 年龄 性别 姓名 19 男 王洪涛 表格属性不建议在html中使用，一般在css中使用 属性名 属性值 描述 align left、center、right 规定表格在网页中的对齐方式 border 1或”” 规定表格单元是否拥有边框，默认没有，1表示有 cellpadding 像素值 规定单元边沿与其内容之间的空白，默认为1 cellspacing 像素值 规定单元格之间的空白，默认为2 width 像素值或百分比 规定表格的宽度 height 像素 规定表格的高度 表格结构标签&lt;thead&gt;&lt;/thead&gt; &lt;tbody&gt;&lt;/tbody&gt; thead内必须有tr 合并单元格 跨行合并 rowspan=“合并单元格的个数”，最上侧单元格为目标单元格，写合并代码 跨列合并 colspan=“合并单元格的个数”，最左侧单元格为目标单元格，写合并代码 &lt;table width=&quot;500&quot; height=&quot;249&quot; border=&quot;1&quot; cellspacing=&quot;0&quot;&gt; &lt;tr&gt; &lt;td&gt; &lt;/td&gt;&lt;td colspan=2&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt; &lt;/td&gt;&lt;td&gt; &lt;/td&gt;&lt;td&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt; &lt;/td&gt;&lt;td&gt; &lt;/td&gt;&lt;td&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; 效果如下： 列表标签无序列表&lt;ul&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;/ul&gt; 效果如下 1 2 注意：ul中只能放li标签，但li里面可以放任意标签 有序列表&lt;ol&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;/ol&gt; 效果如下 第一 第二 自定义列表&lt;dl&gt; &lt;dt&gt;联系方式&lt;/dt&gt; &lt;dd&gt;QQ&lt;/dd&gt; &lt;dd&gt;微信&lt;/dd&gt; &lt;/dl&gt; 效果如下： 联系方式 QQ 微信 表单标签表单的组成在HTML中，一个完整的表单由三部分组成，分别是 表单域 表单控件 提示信息 表单域在HTML标签中，&lt;form&gt;&lt;/form&gt;标签用于定义表单域form会把它范围内的表单元素提交给服务器 &lt;form action=&quot;url地址&quot; method= &quot;提交方式&quot; name=&quot;表单域名称&quot;&gt; 各种表单元素控件 &lt;/form&gt; 常用属性： 属性 属性值 作用 action url地址 用于指定接收并处理表单数据的服务器程序的url地址 method get/post 用于设置表单数据的提交方式，取其值为get或post name 名称 用于指定表单的名称，以区分同一个页面中的多个表单域 表单元素&lt;input&gt;表单元素&lt;input type=&quot;属性值&quot;/&gt; &lt;form&gt; 用户名：&lt;input type=&quot;text&quot; name=&quot;username&quot; value=&quot;请输入用户名&quot;/&gt;&lt;br&gt; 密码:&lt;input type=&quot;password&quot; name=&quot;password&quot;&gt; 性别:男&lt;input type=&quot;radio&quot; name=&quot;sex&quot;&gt;女&lt;input type=&quot;radio&quot; name=&quot;sex&quot;&gt; 爱好:男&lt;input type=&quot;chekbox&quot; name=&quot;hobby&quot;&gt;女&lt;input type=&quot;chekbox&quot; name=&quot;hobby&quot;&gt; &lt;input type=&quot;submit&quot;&gt; &lt;input type=&quot;button&quot; value=&quot;按钮&quot;&gt; 上传文件:&lt;input type=&quot;file&quot;&gt; &lt;/form&gt; 效果如下： 用户名： 密码: 性别:男女 选框组件可以选择checked属性为checked，默认勾选 爱好:男女 上传文件: lable标签lable标签可以绑定表单组件，使操作更快捷 &lt;label for=&quot;text&quot;&gt; 用户名:&lt;/label&gt;&lt;input type=&quot;checkbox&quot; id=&quot;text&quot;&gt; 效果如下: 用户名: 下拉标签&lt;select&gt; &lt;option selected=&quot;selected&quot;&gt;男&lt;/option&gt; &lt;option&gt;女&lt;/option&gt; &lt;/select&gt; 效果： 性别: 男 女 文本域标签&lt;textarea cols=&quot;50&quot; rows=&quot;5&quot;&gt;输入反馈&lt;/textarea&gt; cols和rows表示显示的列数和行数 今日反馈: 输入反馈","categories":[],"tags":[]},{"title":"互联网行业职业分析","slug":"互联网行业职业分析/互联网行业职业分析","date":"2022-03-18T13:46:04.000Z","updated":"2022-03-19T00:55:57.428Z","comments":true,"path":"2022/03/18/互联网行业职业分析/互联网行业职业分析/","link":"","permalink":"http://110.42.136.235/2022/03/18/%E4%BA%92%E8%81%94%E7%BD%91%E8%A1%8C%E4%B8%9A%E8%81%8C%E4%B8%9A%E5%88%86%E6%9E%90/%E4%BA%92%E8%81%94%E7%BD%91%E8%A1%8C%E4%B8%9A%E8%81%8C%E4%B8%9A%E5%88%86%E6%9E%90/","excerpt":"","text":"互联网公司职业之间的关系 以下对这些岗位的工作内容做更详细的讲解和说明： 销售/客服/商务 销售，将商品推销售卖出去的人； 客服，为客服服务解答疑问的人，售前、售中、售后都需要客服； 商务，为公司业务发展谈合作的人。 产品经理产品经理接受来自高层、销售、客服、商务、运营等同学提出的需求，其工作内容是明确以下内容，并督促大家按预期完成。 产品需要设计成什么样子才能满足需求方的要求？ 完成本次需求实现需要调动哪些产品组？ 各产品组之间分别需要负责什么改动? 各产品预期何时开发，何时测试，何时上线？ 分析 商业分析负责对竞品、行业进行调研分析，并完成行业报告，为业务的战略发展提供支持。 数据分析负责建设业务数据指标体系，并从数据指标变化观察业务异常、洞察行业机会、提出业务改进机会。 工程师 服务端开发工程师/前端工程师/算法工程师负责根据产品经理提出的需求，设计具体的技术方案，并完成代码实现和上线。 测试(开发)工程师负责根据产品需求、技术方案，设计测试用例验证需求实现并且代码无缺陷，开发完成的代码必须测试无误后才能上线。 运营 运营产品上线后，运营同学会建设关键运营指标，并通过各种手段提高关键运营指标，如与用户做沟通调查。 运维(开发)工程师负责代码上线后，服务器、部署环境方面的维护工作。 心得体会 了解互联网行业各个职位的工作和关系之后，我对自己的目标有了重新的定位，互联网行业并不是清一色的代码，也有许多需要沟通和交流的工作，结合我的自身性格，我觉得我更适合做开发岗。在以后的学习生活中，我要多学习和接触前端和后端的技术，争取能够独立开发项目。","categories":[],"tags":[]},{"title":"vscode连接使用MySQL","slug":"vscode连接使用MySQL","date":"2022-03-18T01:18:02.000Z","updated":"2022-03-18T13:26:27.853Z","comments":true,"path":"2022/03/18/vscode连接使用MySQL/","link":"","permalink":"http://110.42.136.235/2022/03/18/vscode%E8%BF%9E%E6%8E%A5%E4%BD%BF%E7%94%A8MySQL/","excerpt":"","text":"下载MySQL去官网下载MySQL 配置vscode下载Mysql安装配置Mysql 修改c_cpp_properties在c_cpp_properties中做出如下修改 修改launch在launch中做出如下修改 修改tasks在tasks中作出如下修改 连接MySQL安装MySQL插件安装完成后会在左下角出现该图标，点击加号如果找不到该图标可以检查资源管理器旁边的设置并勾选上MySQL依次输入localhost(或127.0.0.1)，用户名(默认是root),密码(MySQL设置的密码),端口号一般默认是3306,后面直接回车跳过即可 连接成功之后会出现下图所示，系统会自带几个database 使用MySQL此时可以正式在vscode中使用Mysql了，右击数据库会生成一个.sql文件使用sql语句，右击，选择Run MySQL Querysql语句 运行结果截图 参考文献","categories":[],"tags":[]},{"title":"SQL Server学习日记","slug":"SQL-Server学习日记","date":"2022-03-17T13:09:29.000Z","updated":"2022-03-22T13:24:43.775Z","comments":true,"path":"2022/03/17/SQL-Server学习日记/","link":"","permalink":"http://110.42.136.235/2022/03/17/SQL-Server%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/","excerpt":"","text":"创建数据库（1） 数据库名称 Test2。（2） 主要数据文件：逻辑文件名为Test2_data1，物理文件名为Test2_data1.mdf，初始容量为10MB，最大容量为100MB，增幅为10MB。次要数据文件会自动生成 create database Test2 on primary (name = Test2_data1, filename = &#39;d:\\SQL Server Project\\Test2\\Test2_data1.mdf&#39;, size=10,maxsize=100,filegrowth=10) log on(name=Test2_log1, filename = &#39;d:\\SQL Server Project\\Test2\\Test2_data2.ndf&#39;, size=10,maxsize=50,filegrowth=20) 修改数据库数据库更名alter database test1 modify name=new_test1 修改数据库属性alter database Test2 modify file(name=Test2_data1, size=50,maxsize=200,filegrowth=20), (name=Test2_data2, size=50,maxsize=300,filegrowth=20), (name=Test2_log1, size=30,maxsize=100,filegrowth=10%） 创建表格 学生表格 create table student( Student_id char(10) not null primary key, Student_name char(10) not null , sex char(1) not null constraint sex check(sex=&#39;F&#39; or sex=&#39;M&#39;) , birth smalldatetime not null, age int, department char(15) not null default &#39;计算机系&#39;) 课程表格 create table course (Course_id char(6)not null primary key clustered, Course_name char(20) not null , PreCloud char(6), credits tinyint not null ) score 表格 create table score (Student_id char(10) references student(Student_id), Course_id char(6) references course(Course_id), Grade tinyint constraint Grade check(Grade&gt;0 and Grade&lt;100)) 修改表格（1） 为表student增加一个memo（备注）字段，类型为varchar（200）。 alter table student add memo varchar(200) （2） 将memo字段的数据类型更改为varchar（300）。 alter table student Alter column memo varchar(300) （3） 删除memo字段 alter table student drop column memo （4） 添加记录 insert into 表格名字 values(数据) 删除表格drop table course","categories":[],"tags":[{"name":"学习日记","slug":"学习日记","permalink":"http://110.42.136.235/tags/%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/"}]}],"categories":[{"name":"AI","slug":"AI","permalink":"http://110.42.136.235/categories/AI/"},{"name":"安全框架","slug":"安全框架","permalink":"http://110.42.136.235/categories/%E5%AE%89%E5%85%A8%E6%A1%86%E6%9E%B6/"},{"name":"java","slug":"java","permalink":"http://110.42.136.235/categories/java/"},{"name":"依赖管理","slug":"依赖管理","permalink":"http://110.42.136.235/categories/%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86/"},{"name":"MyBatisPlus","slug":"MyBatisPlus","permalink":"http://110.42.136.235/categories/MyBatisPlus/"},{"name":"Redis","slug":"Redis","permalink":"http://110.42.136.235/categories/Redis/"},{"name":"spring","slug":"spring","permalink":"http://110.42.136.235/categories/spring/"}],"tags":[{"name":"AI","slug":"AI","permalink":"http://110.42.136.235/tags/AI/"},{"name":"安全框架","slug":"安全框架","permalink":"http://110.42.136.235/tags/%E5%AE%89%E5%85%A8%E6%A1%86%E6%9E%B6/"},{"name":"java","slug":"java","permalink":"http://110.42.136.235/tags/java/"},{"name":"依赖管理","slug":"依赖管理","permalink":"http://110.42.136.235/tags/%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86/"},{"name":"学习笔记","slug":"学习笔记","permalink":"http://110.42.136.235/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"spring","slug":"spring","permalink":"http://110.42.136.235/tags/spring/"},{"name":"学习日记","slug":"学习日记","permalink":"http://110.42.136.235/tags/%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/"}]}